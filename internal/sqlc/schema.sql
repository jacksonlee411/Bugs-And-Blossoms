-- Code generated by scripts/sqlc/export-schema.sh; DO NOT EDIT.
-- Source: modules/*/infrastructure/persistence/schema/*.sql

-- begin: modules/iam/infrastructure/persistence/schema/00001_iam_baseline.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS iam;

CREATE OR REPLACE FUNCTION public.current_tenant_id()
RETURNS uuid
LANGUAGE sql
STABLE
AS $$
  SELECT current_setting('app.current_tenant')::uuid;
$$;

CREATE OR REPLACE FUNCTION public.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  IF p_tenant_id <> public.current_tenant_id() THEN
    RAISE EXCEPTION 'RLS_TENANT_MISMATCH'
      USING
        ERRCODE = 'P0001',
        DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, public.current_tenant_id());
  END IF;
END;
$$;


-- end: modules/iam/infrastructure/persistence/schema/00001_iam_baseline.sql

-- begin: modules/iam/infrastructure/persistence/schema/00002_iam_tenancy.sql
CREATE TABLE IF NOT EXISTS iam.tenants (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT tenants_name_nonempty_check CHECK (btrim(name) <> '')
);

CREATE TABLE IF NOT EXISTS iam.tenant_domains (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  hostname text NOT NULL,
  is_primary boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT tenant_domains_hostname_nonempty_check CHECK (hostname <> ''),
  CONSTRAINT tenant_domains_hostname_lower_check CHECK (hostname = lower(hostname)),
  CONSTRAINT tenant_domains_hostname_trim_check CHECK (hostname = btrim(hostname)),
  CONSTRAINT tenant_domains_hostname_no_port_check CHECK (position(':' in hostname) = 0)
);

CREATE UNIQUE INDEX IF NOT EXISTS tenant_domains_hostname_unique ON iam.tenant_domains (hostname);
CREATE INDEX IF NOT EXISTS tenant_domains_tenant_idx ON iam.tenant_domains (tenant_uuid);
CREATE UNIQUE INDEX IF NOT EXISTS tenant_domains_primary_unique ON iam.tenant_domains (tenant_uuid) WHERE is_primary = true;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT USAGE ON SCHEMA iam TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.tenants TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.tenant_domains TO superadmin_runtime';
  END IF;
END
$$;

-- end: modules/iam/infrastructure/persistence/schema/00002_iam_tenancy.sql

-- begin: modules/iam/infrastructure/persistence/schema/00003_iam_superadmin_audit.sql
CREATE TABLE IF NOT EXISTS iam.superadmin_audit_logs (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  actor text NOT NULL,
  action text NOT NULL,
  target_tenant_uuid uuid NULL REFERENCES iam.tenants(id) ON DELETE SET NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_audit_logs_actor_nonempty_check CHECK (btrim(actor) <> ''),
  CONSTRAINT superadmin_audit_logs_action_nonempty_check CHECK (btrim(action) <> ''),
  CONSTRAINT superadmin_audit_logs_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE UNIQUE INDEX IF NOT EXISTS superadmin_audit_logs_event_uuid_unique ON iam.superadmin_audit_logs (event_uuid);
CREATE INDEX IF NOT EXISTS superadmin_audit_logs_target_tenant_idx ON iam.superadmin_audit_logs (target_tenant_uuid, id);

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT INSERT, SELECT ON iam.superadmin_audit_logs TO superadmin_runtime';
    EXECUTE 'GRANT USAGE, SELECT ON SEQUENCE iam.superadmin_audit_logs_id_seq TO superadmin_runtime';
  END IF;
END
$$;

-- end: modules/iam/infrastructure/persistence/schema/00003_iam_superadmin_audit.sql

-- begin: modules/iam/infrastructure/persistence/schema/00004_iam_principals_and_sessions.sql
CREATE TABLE IF NOT EXISTS iam.principals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  email text NOT NULL,
  role_slug text NOT NULL,
  display_name text NULL,
  status text NOT NULL,
  kratos_identity_id uuid NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT principals_email_nonempty_check CHECK (btrim(email) <> ''),
  CONSTRAINT principals_email_lower_check CHECK (email = lower(email)),
  CONSTRAINT principals_email_trim_check CHECK (email = btrim(email)),
  CONSTRAINT principals_role_slug_nonempty_check CHECK (btrim(role_slug) <> ''),
  CONSTRAINT principals_role_slug_lower_check CHECK (role_slug = lower(role_slug)),
  CONSTRAINT principals_status_check CHECK (status IN ('active', 'disabled'))
);

CREATE UNIQUE INDEX IF NOT EXISTS principals_tenant_email_unique ON iam.principals (tenant_uuid, email);
CREATE INDEX IF NOT EXISTS principals_tenant_idx ON iam.principals (tenant_uuid);

CREATE TABLE IF NOT EXISTS iam.sessions (
  token_sha256 bytea PRIMARY KEY,
  tenant_uuid uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  principal_id uuid NOT NULL REFERENCES iam.principals(id) ON DELETE CASCADE,
  expires_at timestamptz NOT NULL,
  revoked_at timestamptz NULL,
  ip text NULL,
  user_agent text NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT sessions_token_sha256_len_check CHECK (octet_length(token_sha256) = 32)
);

CREATE INDEX IF NOT EXISTS sessions_tenant_idx ON iam.sessions (tenant_uuid);
CREATE INDEX IF NOT EXISTS sessions_principal_idx ON iam.sessions (principal_id);


-- end: modules/iam/infrastructure/persistence/schema/00004_iam_principals_and_sessions.sql

-- begin: modules/iam/infrastructure/persistence/schema/00005_iam_superadmin_principals_and_sessions.sql
CREATE TABLE IF NOT EXISTS iam.superadmin_principals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text NOT NULL UNIQUE,
  display_name text NULL,
  status text NOT NULL,
  kratos_identity_id uuid NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_principals_email_nonempty_check CHECK (btrim(email) <> ''),
  CONSTRAINT superadmin_principals_email_lower_check CHECK (email = lower(email)),
  CONSTRAINT superadmin_principals_email_trim_check CHECK (email = btrim(email)),
  CONSTRAINT superadmin_principals_status_check CHECK (status IN ('active', 'disabled'))
);

CREATE TABLE IF NOT EXISTS iam.superadmin_sessions (
  token_sha256 bytea PRIMARY KEY,
  principal_id uuid NOT NULL REFERENCES iam.superadmin_principals(id) ON DELETE CASCADE,
  expires_at timestamptz NOT NULL,
  revoked_at timestamptz NULL,
  ip text NULL,
  user_agent text NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_sessions_token_sha256_len_check CHECK (octet_length(token_sha256) = 32)
);

CREATE INDEX IF NOT EXISTS superadmin_sessions_principal_idx ON iam.superadmin_sessions (principal_id);

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.superadmin_principals TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.superadmin_sessions TO superadmin_runtime';
  END IF;
END
$$;


-- end: modules/iam/infrastructure/persistence/schema/00005_iam_superadmin_principals_and_sessions.sql

-- begin: modules/iam/infrastructure/persistence/schema/00006_iam_global_tenant.sql
INSERT INTO iam.tenants (id, name, is_active)
VALUES ('00000000-0000-0000-0000-000000000000', 'GLOBAL', true)
ON CONFLICT (id) DO NOTHING;

-- end: modules/iam/infrastructure/persistence/schema/00006_iam_global_tenant.sql

-- begin: modules/iam/infrastructure/persistence/schema/00007_iam_dict_config.sql
CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE TABLE IF NOT EXISTS iam.dict_value_segments (
  tenant_uuid uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  dict_code text NOT NULL,
  code text NOT NULL,
  label text NOT NULL,
  enabled_on date NOT NULL,
  disabled_on date NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, dict_code, code, enabled_on),
  CONSTRAINT dict_value_segments_dict_code_check CHECK (
    dict_code = lower(dict_code)
    AND dict_code = btrim(dict_code)
    AND dict_code ~ '^[a-z][a-z0-9_]{0,63}$'
  ),
  CONSTRAINT dict_value_segments_code_check CHECK (code = btrim(code) AND code <> ''),
  CONSTRAINT dict_value_segments_label_check CHECK (label = btrim(label) AND label <> ''),
  CONSTRAINT dict_value_segments_status_check CHECK (status IN ('active', 'inactive')),
  CONSTRAINT dict_value_segments_window_check CHECK (disabled_on IS NULL OR enabled_on < disabled_on)
);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'dict_value_segments_no_overlap'
      AND connamespace = 'iam'::regnamespace
  ) THEN
    ALTER TABLE iam.dict_value_segments
      ADD CONSTRAINT dict_value_segments_no_overlap
      EXCLUDE USING gist (
        tenant_uuid WITH =,
        dict_code WITH =,
        code WITH =,
        daterange(enabled_on, COALESCE(disabled_on, 'infinity'::date), '[)') WITH &&
      );
  END IF;
END
$$;

CREATE INDEX IF NOT EXISTS dict_value_segments_lookup_idx
  ON iam.dict_value_segments (tenant_uuid, dict_code, code, enabled_on DESC);

CREATE INDEX IF NOT EXISTS dict_value_segments_active_idx
  ON iam.dict_value_segments (tenant_uuid, dict_code, enabled_on, disabled_on);

ALTER TABLE iam.dict_value_segments ENABLE ROW LEVEL SECURITY;
ALTER TABLE iam.dict_value_segments FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON iam.dict_value_segments;
CREATE POLICY tenant_isolation ON iam.dict_value_segments
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

CREATE TABLE IF NOT EXISTS iam.dict_value_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  dict_code text NOT NULL,
  code text NOT NULL,
  event_type text NOT NULL,
  effective_day date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  before_snapshot jsonb NOT NULL DEFAULT '{}'::jsonb,
  after_snapshot jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NULL,
  tx_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT dict_value_events_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT dict_value_events_request_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT dict_value_events_dict_code_check CHECK (
    dict_code = lower(dict_code)
    AND dict_code = btrim(dict_code)
    AND dict_code ~ '^[a-z][a-z0-9_]{0,63}$'
  ),
  CONSTRAINT dict_value_events_code_check CHECK (code = btrim(code) AND code <> ''),
  CONSTRAINT dict_value_events_event_type_check CHECK (
    event_type IN (
      'DICT_VALUE_CREATED',
      'DICT_VALUE_LABEL_CORRECTED',
      'DICT_VALUE_DISABLED',
      'DICT_VALUE_REENABLED',
      'DICT_VALUE_RESCINDED'
    )
  ),
  CONSTRAINT dict_value_events_payload_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT dict_value_events_before_snapshot_object_check CHECK (jsonb_typeof(before_snapshot) = 'object'),
  CONSTRAINT dict_value_events_after_snapshot_object_check CHECK (jsonb_typeof(after_snapshot) = 'object')
);

CREATE INDEX IF NOT EXISTS dict_value_events_lookup_idx
  ON iam.dict_value_events (tenant_uuid, dict_code, code, id DESC);

ALTER TABLE iam.dict_value_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE iam.dict_value_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON iam.dict_value_events;
CREATE POLICY tenant_isolation ON iam.dict_value_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

CREATE OR REPLACE FUNCTION iam.submit_dict_value_event(
  p_tenant_uuid uuid,
  p_dict_code text,
  p_code text,
  p_event_type text,
  p_effective_day date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS TABLE(event_id bigint, was_retry boolean)
LANGUAGE plpgsql
AS $$
DECLARE
  v_dict_code text := lower(btrim(COALESCE(p_dict_code, '')));
  v_code text := btrim(COALESCE(p_code, ''));
  v_event_type text := upper(btrim(COALESCE(p_event_type, '')));
  v_request_code text := btrim(COALESCE(p_request_code, ''));
  v_payload jsonb := COALESCE(p_payload, '{}'::jsonb);
  v_now timestamptz := now();
  v_label text := '';
  v_existing iam.dict_value_events%ROWTYPE;
  v_target iam.dict_value_segments%ROWTYPE;
  v_before jsonb := '{}'::jsonb;
  v_after jsonb := '{}'::jsonb;
BEGIN
  PERFORM public.assert_current_tenant(p_tenant_uuid);

  IF v_dict_code = '' THEN
    RAISE EXCEPTION 'DICT_CODE_REQUIRED' USING ERRCODE = 'P0001';
  END IF;
  IF v_code = '' THEN
    RAISE EXCEPTION 'DICT_VALUE_CODE_REQUIRED' USING ERRCODE = 'P0001';
  END IF;
  IF p_effective_day IS NULL THEN
    RAISE EXCEPTION 'DICT_EFFECTIVE_DAY_REQUIRED' USING ERRCODE = 'P0001';
  END IF;
  IF v_request_code = '' THEN
    RAISE EXCEPTION 'DICT_REQUEST_CODE_REQUIRED' USING ERRCODE = 'P0001';
  END IF;
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION 'DICT_PAYLOAD_INVALID' USING ERRCODE = 'P0001';
  END IF;
  IF v_event_type NOT IN (
    'DICT_VALUE_CREATED',
    'DICT_VALUE_LABEL_CORRECTED',
    'DICT_VALUE_DISABLED',
    'DICT_VALUE_REENABLED',
    'DICT_VALUE_RESCINDED'
  ) THEN
    RAISE EXCEPTION 'DICT_EVENT_TYPE_INVALID' USING ERRCODE = 'P0001';
  END IF;

  SELECT *
  INTO v_existing
  FROM iam.dict_value_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = v_request_code
  LIMIT 1;

  IF FOUND THEN
    IF v_existing.event_type = v_event_type
      AND v_existing.dict_code = v_dict_code
      AND v_existing.code = v_code
      AND v_existing.effective_day = p_effective_day
      AND v_existing.payload = v_payload THEN
      RETURN QUERY SELECT v_existing.id, true;
      RETURN;
    END IF;
    RAISE EXCEPTION 'DICT_VALUE_CONFLICT' USING ERRCODE = 'P0001';
  END IF;

  IF v_event_type IN ('DICT_VALUE_CREATED', 'DICT_VALUE_REENABLED', 'DICT_VALUE_LABEL_CORRECTED') THEN
    v_label := btrim(COALESCE(v_payload->>'label', ''));
    IF v_label = '' THEN
      RAISE EXCEPTION 'DICT_VALUE_LABEL_REQUIRED' USING ERRCODE = 'P0001';
    END IF;
  END IF;

  IF v_event_type IN ('DICT_VALUE_DISABLED', 'DICT_VALUE_LABEL_CORRECTED', 'DICT_VALUE_RESCINDED') THEN
    SELECT *
    INTO v_target
    FROM iam.dict_value_segments
    WHERE tenant_uuid = p_tenant_uuid
      AND dict_code = v_dict_code
      AND code = v_code
      AND enabled_on <= p_effective_day
      AND (disabled_on IS NULL OR p_effective_day < disabled_on)
    ORDER BY enabled_on DESC
    LIMIT 1
    FOR UPDATE;

    IF NOT FOUND THEN
      RAISE EXCEPTION 'DICT_VALUE_NOT_FOUND_AS_OF' USING ERRCODE = 'P0001';
    END IF;
  END IF;

  IF v_event_type IN ('DICT_VALUE_CREATED', 'DICT_VALUE_REENABLED') THEN
    INSERT INTO iam.dict_value_segments (
      tenant_uuid,
      dict_code,
      code,
      label,
      enabled_on,
      disabled_on,
      status,
      created_at,
      updated_at
    )
    VALUES (
      p_tenant_uuid,
      v_dict_code,
      v_code,
      v_label,
      p_effective_day,
      NULL,
      'active',
      v_now,
      v_now
    );

    SELECT *
    INTO v_target
    FROM iam.dict_value_segments
    WHERE tenant_uuid = p_tenant_uuid
      AND dict_code = v_dict_code
      AND code = v_code
      AND enabled_on = p_effective_day
    LIMIT 1;

  ELSIF v_event_type = 'DICT_VALUE_DISABLED' THEN
    IF p_effective_day <= v_target.enabled_on THEN
      RAISE EXCEPTION 'DICT_VALUE_CONFLICT' USING ERRCODE = 'P0001';
    END IF;

    v_before := jsonb_build_object(
      'dict_code', v_target.dict_code,
      'code', v_target.code,
      'label', v_target.label,
      'status', v_target.status,
      'enabled_on', v_target.enabled_on,
      'disabled_on', v_target.disabled_on
    );

    UPDATE iam.dict_value_segments
    SET disabled_on = p_effective_day,
        status = 'inactive',
        updated_at = v_now
    WHERE tenant_uuid = v_target.tenant_uuid
      AND dict_code = v_target.dict_code
      AND code = v_target.code
      AND enabled_on = v_target.enabled_on;

    SELECT *
    INTO v_target
    FROM iam.dict_value_segments
    WHERE tenant_uuid = p_tenant_uuid
      AND dict_code = v_dict_code
      AND code = v_code
      AND enabled_on = v_target.enabled_on
    LIMIT 1;

  ELSIF v_event_type = 'DICT_VALUE_LABEL_CORRECTED' THEN
    v_before := jsonb_build_object(
      'dict_code', v_target.dict_code,
      'code', v_target.code,
      'label', v_target.label,
      'status', v_target.status,
      'enabled_on', v_target.enabled_on,
      'disabled_on', v_target.disabled_on
    );

    UPDATE iam.dict_value_segments
    SET label = v_label,
        updated_at = v_now
    WHERE tenant_uuid = v_target.tenant_uuid
      AND dict_code = v_target.dict_code
      AND code = v_target.code
      AND enabled_on = v_target.enabled_on;

    SELECT *
    INTO v_target
    FROM iam.dict_value_segments
    WHERE tenant_uuid = p_tenant_uuid
      AND dict_code = v_dict_code
      AND code = v_code
      AND enabled_on = v_target.enabled_on
    LIMIT 1;
  ELSE
    RAISE EXCEPTION 'DICT_EVENT_TYPE_INVALID' USING ERRCODE = 'P0001';
  END IF;

  IF v_before = '{}'::jsonb THEN
    v_before := jsonb_build_object();
  END IF;
  v_after := jsonb_build_object(
    'dict_code', v_target.dict_code,
    'code', v_target.code,
    'label', v_target.label,
    'status', v_target.status,
    'enabled_on', v_target.enabled_on,
    'disabled_on', v_target.disabled_on
  );

  INSERT INTO iam.dict_value_events (
    tenant_uuid,
    dict_code,
    code,
    event_type,
    effective_day,
    payload,
    before_snapshot,
    after_snapshot,
    request_code,
    initiator_uuid,
    tx_time,
    created_at
  )
  VALUES (
    p_tenant_uuid,
    v_dict_code,
    v_code,
    v_event_type,
    p_effective_day,
    v_payload,
    v_before,
    v_after,
    v_request_code,
    p_initiator_uuid,
    v_now,
    v_now
  )
  RETURNING id INTO event_id;

  RETURN QUERY SELECT event_id, false;
  RETURN;
EXCEPTION
  WHEN unique_violation OR exclusion_violation THEN
    RAISE EXCEPTION 'DICT_VALUE_CONFLICT' USING ERRCODE = 'P0001';
END;
$$;

REVOKE EXECUTE ON FUNCTION iam.submit_dict_value_event(uuid, text, text, text, date, jsonb, text, uuid) FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION iam.submit_dict_value_event(uuid, text, text, text, date, jsonb, text, uuid) TO app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION iam.submit_dict_value_event(uuid, text, text, text, date, jsonb, text, uuid) TO superadmin_runtime';
  END IF;
END
$$;

DO $$
DECLARE
  v_global uuid := '00000000-0000-0000-0000-000000000000'::uuid;
  v_local uuid := '00000000-0000-0000-0000-000000000001'::uuid;
BEGIN
  PERFORM set_config('app.current_tenant', v_global::text, true);
  IF EXISTS (SELECT 1 FROM iam.tenants WHERE id = v_global) THEN
    INSERT INTO iam.dict_value_segments (tenant_uuid, dict_code, code, label, enabled_on, disabled_on, status)
    VALUES
      (v_global, 'org_type', '10', '部门', '1970-01-01', NULL, 'active'),
      (v_global, 'org_type', '20', '单位', '1970-01-01', NULL, 'active')
    ON CONFLICT (tenant_uuid, dict_code, code, enabled_on) DO UPDATE
    SET label = EXCLUDED.label,
        disabled_on = NULL,
        status = 'active',
        updated_at = now();
  END IF;

  PERFORM set_config('app.current_tenant', v_local::text, true);
  IF EXISTS (SELECT 1 FROM iam.tenants WHERE id = v_local) THEN
    INSERT INTO iam.dict_value_segments (tenant_uuid, dict_code, code, label, enabled_on, disabled_on, status)
    VALUES
      (v_local, 'org_type', '10', '部门', '1970-01-01', NULL, 'active'),
      (v_local, 'org_type', '20', '单位', '1970-01-01', NULL, 'active')
    ON CONFLICT (tenant_uuid, dict_code, code, enabled_on) DO UPDATE
    SET label = EXCLUDED.label,
        disabled_on = NULL,
        status = 'active',
        updated_at = now();
  END IF;
END
$$;

-- end: modules/iam/infrastructure/persistence/schema/00007_iam_dict_config.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00001_orgunit_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS orgunit;

CREATE OR REPLACE FUNCTION orgunit.global_tenant_id()
RETURNS uuid
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT '00000000-0000-0000-0000-000000000000'::uuid;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00001_orgunit_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00002_orgunit_org_schema.sql
CREATE EXTENSION IF NOT EXISTS ltree;
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- org_id -> ltree label (8-digit int)
CREATE OR REPLACE FUNCTION orgunit.org_ltree_label(p_id int)
RETURNS text
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT p_id::text;
$$;

-- ltree path -> int[] (for long name / ancestors join)
CREATE OR REPLACE FUNCTION orgunit.org_path_ids(p_path ltree)
RETURNS int[]
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT array_agg((t.part)::int ORDER BY t.ord)
  FROM unnest(string_to_array(p_path::text, '.')) WITH ORDINALITY AS t(part, ord);
$$;

-- snapshot presence predicate (single source for kernel assert + table CHECK)
CREATE OR REPLACE FUNCTION orgunit.is_org_event_snapshot_presence_valid(
  p_event_type text,
  p_before_snapshot jsonb,
  p_after_snapshot jsonb,
  p_rescind_outcome text
)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT CASE
    WHEN p_event_type = 'CREATE'
      THEN p_after_snapshot IS NOT NULL

    WHEN p_event_type IN ('MOVE','RENAME','DISABLE','ENABLE','SET_BUSINESS_UNIT','CORRECT_EVENT','CORRECT_STATUS')
      THEN p_before_snapshot IS NOT NULL AND p_after_snapshot IS NOT NULL

    WHEN p_event_type IN ('RESCIND_EVENT','RESCIND_ORG')
      THEN p_before_snapshot IS NOT NULL
           AND (
             (p_rescind_outcome = 'ABSENT' AND p_after_snapshot IS NULL)
             OR (p_rescind_outcome = 'PRESENT' AND p_after_snapshot IS NOT NULL)
           )

    ELSE true
  END;
$$;

-- canonical snapshot content predicate for RESCIND_* events
CREATE OR REPLACE FUNCTION orgunit.is_orgunit_snapshot_complete(p_snapshot jsonb)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT p_snapshot IS NOT NULL
    AND jsonb_typeof(p_snapshot) = 'object'
    AND p_snapshot ?& ARRAY[
      'org_id',
      'name',
      'status',
      'parent_id',
      'node_path',
      'validity',
      'full_name_path',
      'is_business_unit'
    ];
$$;

-- snapshot content predicate (presence focuses on nullability; this focuses on completeness)
CREATE OR REPLACE FUNCTION orgunit.is_org_event_snapshot_content_valid(
  p_event_type text,
  p_before_snapshot jsonb,
  p_after_snapshot jsonb,
  p_rescind_outcome text
)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT CASE
    WHEN p_event_type IN ('RESCIND_EVENT','RESCIND_ORG')
      THEN orgunit.is_orgunit_snapshot_complete(p_before_snapshot)
           AND (
             p_rescind_outcome = 'ABSENT'
             OR (
               p_rescind_outcome = 'PRESENT'
               AND orgunit.is_orgunit_snapshot_complete(p_after_snapshot)
             )
           )
    ELSE true
  END;
$$;

CREATE TABLE IF NOT EXISTS orgunit.org_trees (
  tenant_uuid uuid NOT NULL,
  root_org_id int NOT NULL CHECK (root_org_id BETWEEN 10000000 AND 99999999),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid)
);

CREATE TABLE IF NOT EXISTS orgunit.org_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  initiator_name text NULL,
  initiator_employee_id text NULL,
  reason text NULL,
  before_snapshot jsonb NULL,
  after_snapshot jsonb NULL,
  rescind_outcome text NULL,
  tx_time timestamptz NOT NULL DEFAULT now(),
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT org_events_event_type_check CHECK (event_type IN ('CREATE','MOVE','RENAME','DISABLE','ENABLE','SET_BUSINESS_UNIT','CORRECT_EVENT','CORRECT_STATUS','RESCIND_EVENT','RESCIND_ORG')),
  CONSTRAINT org_events_target_event_uuid_required CHECK (
    event_type NOT IN ('CORRECT_EVENT','CORRECT_STATUS','RESCIND_EVENT','RESCIND_ORG')
    OR (
      payload ? 'target_event_uuid'
      AND NULLIF(btrim(payload->>'target_event_uuid'), '') IS NOT NULL
    )
  ),
  CONSTRAINT org_events_rescind_payload_required CHECK (
    event_type NOT IN ('RESCIND_EVENT','RESCIND_ORG')
    OR (
      COALESCE(NULLIF(btrim(payload->>'op'), ''), '') = event_type
      AND COALESCE(NULLIF(btrim(payload->>'reason'), ''), '') <> ''
      AND COALESCE(NULLIF(btrim(payload->>'target_event_uuid'), ''), '') <> ''
      AND COALESCE(NULLIF(btrim(payload->>'target_effective_date'), ''), '') = to_char(effective_date, 'YYYY-MM-DD')
    )
  ),
  CONSTRAINT org_events_snapshot_shape_check CHECK (
    (before_snapshot IS NULL OR jsonb_typeof(before_snapshot) = 'object')
    AND (after_snapshot IS NULL OR jsonb_typeof(after_snapshot) = 'object')
  ),
  CONSTRAINT org_events_rescind_outcome_check CHECK (
    (
      event_type NOT IN ('RESCIND_EVENT','RESCIND_ORG')
      AND rescind_outcome IS NULL
    )
    OR (
      event_type IN ('RESCIND_EVENT','RESCIND_ORG')
      AND rescind_outcome IN ('PRESENT','ABSENT')
    )
  ),
  CONSTRAINT org_events_snapshot_presence_check CHECK (
    orgunit.is_org_event_snapshot_presence_valid(
      event_type,
      before_snapshot,
      after_snapshot,
      rescind_outcome
    )
  ),
  CONSTRAINT org_events_snapshot_content_check CHECK (
    orgunit.is_org_event_snapshot_content_valid(
      event_type,
      before_snapshot,
      after_snapshot,
      rescind_outcome
    )
  ),
  CONSTRAINT org_events_request_code_unique UNIQUE (tenant_uuid, request_code)
);

CREATE UNIQUE INDEX IF NOT EXISTS org_events_event_uuid_unique ON orgunit.org_events (event_uuid);
CREATE INDEX IF NOT EXISTS org_events_tenant_org_effective_idx ON orgunit.org_events (tenant_uuid, org_id, effective_date, id);
CREATE INDEX IF NOT EXISTS org_events_tenant_effective_idx ON orgunit.org_events (tenant_uuid, effective_date, id);
CREATE INDEX IF NOT EXISTS org_events_tenant_tx_time_idx ON orgunit.org_events (tenant_uuid, tx_time DESC, id DESC);
CREATE TABLE IF NOT EXISTS orgunit.org_unit_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  parent_id int NULL CHECK (parent_id BETWEEN 10000000 AND 99999999),
  node_path ltree NOT NULL,
  validity daterange NOT NULL,
  path_ids int[] GENERATED ALWAYS AS (orgunit.org_path_ids(node_path)) STORED,
  name varchar(255) NOT NULL,
  full_name_path text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  is_business_unit boolean NOT NULL DEFAULT false,
  manager_uuid uuid NULL,
  last_event_id bigint NOT NULL,
  CONSTRAINT org_unit_versions_last_event_id_fkey
    FOREIGN KEY (last_event_id)
    REFERENCES orgunit.org_events(id)
    DEFERRABLE INITIALLY DEFERRED,
  CONSTRAINT org_unit_versions_status_check CHECK (status IN ('active','disabled')),
  CONSTRAINT org_unit_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT org_unit_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT org_unit_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      org_id gist_int4_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS org_unit_versions_search_gist
  ON orgunit.org_unit_versions
  USING gist (tenant_uuid gist_uuid_ops, node_path, validity);

CREATE INDEX IF NOT EXISTS org_unit_versions_active_day_gist
  ON orgunit.org_unit_versions
  USING gist (tenant_uuid gist_uuid_ops, validity)
  WHERE status = 'active';

CREATE INDEX IF NOT EXISTS org_unit_versions_lookup_btree
  ON orgunit.org_unit_versions (tenant_uuid, org_id, lower(validity));

CREATE INDEX IF NOT EXISTS org_unit_versions_path_ids_gin
  ON orgunit.org_unit_versions
  USING gin (path_ids);

CREATE TABLE IF NOT EXISTS orgunit.org_unit_codes (
  tenant_uuid uuid NOT NULL,
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  org_code text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, org_id),
  CONSTRAINT org_unit_codes_org_code_format CHECK (
    length(org_code) BETWEEN 1 AND 64
    AND org_code = upper(org_code)
    AND org_code ~ E'^[\t\x20-\x7E\u3000-\u303F\uFF01-\uFF60\uFFE0-\uFFEE]{1,64}$'
    AND org_code !~ E'^[\t\x20\u3000]+$'
  ),
  CONSTRAINT org_unit_codes_org_code_unique UNIQUE (tenant_uuid, org_code)
);

ALTER TABLE orgunit.org_trees ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_trees FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_trees;
CREATE POLICY tenant_isolation ON orgunit.org_trees
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.org_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_events;
CREATE POLICY tenant_isolation ON orgunit.org_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.org_unit_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_unit_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_unit_versions;
CREATE POLICY tenant_isolation ON orgunit.org_unit_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.org_unit_codes ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_unit_codes FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_unit_codes;
CREATE POLICY tenant_isolation ON orgunit.org_unit_codes
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- end: modules/orgunit/infrastructure/persistence/schema/00002_orgunit_org_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00003_orgunit_engine.sql
CREATE OR REPLACE FUNCTION orgunit.assert_current_tenant(p_tenant_uuid uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'tenant_uuid is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_uuid THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_uuid, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.fill_org_event_audit_snapshot()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_name text;
  v_employee text;
BEGIN
  IF NEW.tx_time IS NULL THEN
    NEW.tx_time := COALESCE(NEW.transaction_time, now());
  END IF;

  IF NULLIF(btrim(COALESCE(NEW.initiator_name, '')), '') IS NOT NULL
    AND NULLIF(btrim(COALESCE(NEW.initiator_employee_id, '')), '') IS NOT NULL
  THEN
    RETURN NEW;
  END IF;

  IF to_regclass('iam.principals') IS NOT NULL THEN
    SELECT
      COALESCE(NULLIF(btrim(p.display_name), ''), NULLIF(btrim(p.email), ''), NEW.initiator_uuid::text),
      COALESCE(NULLIF(btrim(p.email), ''), NEW.initiator_uuid::text)
    INTO v_name, v_employee
    FROM iam.principals p
    WHERE p.tenant_uuid = NEW.tenant_uuid
      AND p.id = NEW.initiator_uuid
    LIMIT 1;
  END IF;

  NEW.initiator_name := COALESCE(NULLIF(btrim(COALESCE(NEW.initiator_name, '')), ''), v_name, NEW.initiator_uuid::text);
  NEW.initiator_employee_id := COALESCE(NULLIF(btrim(COALESCE(NEW.initiator_employee_id, '')), ''), v_employee, NEW.initiator_uuid::text);

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS org_events_fill_audit_snapshot ON orgunit.org_events;
CREATE TRIGGER org_events_fill_audit_snapshot
BEFORE INSERT ON orgunit.org_events
FOR EACH ROW
EXECUTE FUNCTION orgunit.fill_org_event_audit_snapshot();

CREATE OR REPLACE FUNCTION orgunit.merge_org_event_payload_with_correction(
  p_base_payload jsonb,
  p_correction_payload jsonb
)
RETURNS jsonb
LANGUAGE sql
IMMUTABLE
AS $$
  WITH base_payload AS (
    SELECT COALESCE(p_base_payload, '{}'::jsonb) AS payload
  ),
  correction_patch AS (
    SELECT COALESCE(p_correction_payload, '{}'::jsonb) - 'effective_date' - 'target_event_uuid' - 'op' AS payload
  ),
  parts AS (
    SELECT
      (b.payload - 'ext' - 'ext_labels_snapshot') AS base_noext,
      (c.payload - 'ext' - 'ext_labels_snapshot') AS patch_noext,
      CASE WHEN jsonb_typeof(b.payload->'ext') = 'object' THEN b.payload->'ext' ELSE '{}'::jsonb END AS base_ext,
      CASE WHEN jsonb_typeof(c.payload->'ext') = 'object' THEN c.payload->'ext' ELSE '{}'::jsonb END AS patch_ext,
      CASE WHEN jsonb_typeof(b.payload->'ext_labels_snapshot') = 'object' THEN b.payload->'ext_labels_snapshot' ELSE '{}'::jsonb END AS base_labels,
      CASE WHEN jsonb_typeof(c.payload->'ext_labels_snapshot') = 'object' THEN c.payload->'ext_labels_snapshot' ELSE '{}'::jsonb END AS patch_labels,
      (b.payload ? 'ext') OR (c.payload ? 'ext') AS has_ext,
      (b.payload ? 'ext_labels_snapshot') OR (c.payload ? 'ext_labels_snapshot') AS has_labels
    FROM base_payload b
    CROSS JOIN correction_patch c
  ),
  merged AS (
    SELECT
      (base_noext || patch_noext) AS merged_noext,
      (base_ext || patch_ext) AS ext_merged,
      (base_labels || patch_labels) AS labels_merged,
      has_ext,
      has_labels
    FROM parts
  )
  SELECT
    merged_noext
    || CASE
         WHEN has_ext
           THEN jsonb_build_object('ext', ext_merged)
         ELSE '{}'::jsonb
       END
    || CASE
         WHEN has_labels
           THEN jsonb_build_object(
             'ext_labels_snapshot',
             labels_merged - COALESCE((
               SELECT array_agg(key)
               FROM jsonb_each(ext_merged)
               WHERE value = 'null'::jsonb
             ), ARRAY[]::text[])
           )
         ELSE '{}'::jsonb
       END
  FROM merged;
$$;

CREATE OR REPLACE VIEW orgunit.org_events_effective AS
WITH correction_events AS (
  SELECT
    e.*,
    (e.payload->>'target_event_uuid')::uuid AS target_event_uuid
  FROM orgunit.org_events e
  WHERE e.event_type IN ('CORRECT_EVENT','CORRECT_STATUS','RESCIND_EVENT','RESCIND_ORG')
    AND e.payload ? 'target_event_uuid'
),
latest_corrections AS (
  SELECT DISTINCT ON (tenant_uuid, target_event_uuid)
    tenant_uuid,
    target_event_uuid,
    event_type AS correction_type,
    payload AS correction_payload,
    tx_time,
    id
  FROM correction_events
  ORDER BY tenant_uuid, target_event_uuid, tx_time DESC, id DESC
)
SELECT
  e.id,
  e.event_uuid,
  e.tenant_uuid,
  e.org_id,
  CASE
    WHEN lc.correction_type = 'CORRECT_STATUS'
      AND COALESCE(lc.correction_payload->>'target_status', '') = 'active'
      THEN 'ENABLE'
    WHEN lc.correction_type = 'CORRECT_STATUS'
      AND COALESCE(lc.correction_payload->>'target_status', '') = 'disabled'
      THEN 'DISABLE'
    ELSE e.event_type
  END AS event_type,
  CASE
    WHEN lc.correction_type = 'CORRECT_EVENT'
      AND lc.correction_payload ? 'effective_date'
      THEN NULLIF(btrim(lc.correction_payload->>'effective_date'), '')::date
    ELSE e.effective_date
  END AS effective_date,
  CASE
    WHEN lc.correction_type = 'CORRECT_EVENT'
      THEN orgunit.merge_org_event_payload_with_correction(e.payload, lc.correction_payload)
    ELSE e.payload
  END AS payload,
  e.request_code,
  e.initiator_uuid,
  e.transaction_time,
  e.created_at
FROM orgunit.org_events e
LEFT JOIN latest_corrections lc
  ON lc.tenant_uuid = e.tenant_uuid
 AND lc.target_event_uuid = e.event_uuid
WHERE e.event_type IN ('CREATE','MOVE','RENAME','DISABLE','ENABLE','SET_BUSINESS_UNIT')
  AND COALESCE(lc.correction_type, '') NOT IN ('RESCIND_EVENT', 'RESCIND_ORG');

CREATE OR REPLACE FUNCTION orgunit.is_org_ext_payload_allowed_for_event(
  p_event_type text,
  p_target_event_type text
)
RETURNS boolean
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT CASE
    WHEN p_event_type IN ('CREATE','MOVE','RENAME','DISABLE','ENABLE','SET_BUSINESS_UNIT') THEN true
    WHEN p_event_type = 'CORRECT_EVENT'
      THEN p_target_event_type IN ('CREATE','MOVE','RENAME','DISABLE','ENABLE','SET_BUSINESS_UNIT')
    ELSE false
  END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_org_event_ext_payload(
  p_tenant_uuid uuid,
  p_org_id int,
  p_effective_date date,
  p_event_type text,
  p_payload jsonb,
  p_target_event_type text DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_payload jsonb;
  v_ext jsonb;
  v_labels jsonb;
  v_has_ext_payload boolean;
  v_field_key text;
  v_label_key text;
  v_field_value jsonb;
  v_label_value jsonb;
  v_label_text text;
  v_value_text text;
  v_physical_col text;
  v_value_type text;
  v_data_source_type text;
  v_enabled_on date;
  v_disabled_on date;
  v_cast_type text;
  v_sql text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'event_type is required';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  v_has_ext_payload := v_payload ? 'ext' OR v_payload ? 'ext_labels_snapshot';
  IF NOT v_has_ext_payload THEN
    RETURN;
  END IF;

  IF NOT orgunit.is_org_ext_payload_allowed_for_event(p_event_type, p_target_event_type) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EXT_PAYLOAD_NOT_ALLOWED_FOR_EVENT',
      DETAIL = format('event_type=%s target_event_type=%s', p_event_type, COALESCE(p_target_event_type, 'NULL'));
  END IF;

  v_ext := COALESCE(v_payload->'ext', '{}'::jsonb);
  v_labels := COALESCE(v_payload->'ext_labels_snapshot', '{}'::jsonb);

  IF jsonb_typeof(v_ext) <> 'object' OR jsonb_typeof(v_labels) <> 'object' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EXT_PAYLOAD_INVALID_SHAPE',
      DETAIL = 'payload.ext and payload.ext_labels_snapshot must be objects';
  END IF;

  FOR v_label_key IN
    SELECT key
    FROM jsonb_object_keys(v_labels) AS t(key)
  LOOP
    IF NOT (v_ext ? v_label_key) THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_EXT_LABEL_SNAPSHOT_NOT_ALLOWED',
        DETAIL = format('field_key=%s', v_label_key);
    END IF;
  END LOOP;

  FOR v_field_key, v_field_value IN
    SELECT key, value
    FROM jsonb_each(v_ext)
  LOOP
    IF v_field_key !~ '^[a-z][a-z0-9_]{0,62}$' THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_EXT_FIELD_NOT_CONFIGURED',
        DETAIL = format('field_key=%s', v_field_key);
    END IF;

    SELECT
      physical_col,
      value_type,
      data_source_type,
      enabled_on,
      disabled_on
    INTO v_physical_col, v_value_type, v_data_source_type, v_enabled_on, v_disabled_on
    FROM orgunit.tenant_field_configs
    WHERE tenant_uuid = p_tenant_uuid
      AND field_key = v_field_key
    LIMIT 1;

    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_EXT_FIELD_NOT_CONFIGURED',
        DETAIL = format('field_key=%s', v_field_key);
    END IF;

    IF NOT (
      v_enabled_on <= p_effective_date
      AND (v_disabled_on IS NULL OR p_effective_date < v_disabled_on)
    ) THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_EXT_FIELD_NOT_ENABLED_AS_OF',
        DETAIL = format('field_key=%s effective_date=%s', v_field_key, p_effective_date);
    END IF;

    IF v_physical_col !~ '^ext_(str|int|uuid|bool|date)_[0-9]{2}$'
      OR (v_value_type = 'text' AND v_physical_col NOT LIKE 'ext_str_%')
      OR (v_value_type = 'int' AND v_physical_col NOT LIKE 'ext_int_%')
      OR (v_value_type = 'uuid' AND v_physical_col NOT LIKE 'ext_uuid_%')
      OR (v_value_type = 'bool' AND v_physical_col NOT LIKE 'ext_bool_%')
      OR (v_value_type = 'date' AND v_physical_col NOT LIKE 'ext_date_%')
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
        DETAIL = format('field_key=%s physical_col=%s value_type=%s', v_field_key, v_physical_col, v_value_type);
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM information_schema.columns c
      WHERE c.table_schema = 'orgunit'
        AND c.table_name = 'org_unit_versions'
        AND c.column_name = v_physical_col
    ) THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
        DETAIL = format('field_key=%s physical_col=%s missing_in_org_unit_versions', v_field_key, v_physical_col);
    END IF;

    v_value_text := NULL;
    IF v_field_value <> 'null'::jsonb THEN
      IF v_value_type = 'text' THEN
        IF jsonb_typeof(v_field_value) <> 'string' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
            DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
        END IF;
        v_value_text := v_field_value #>> '{}';
      ELSIF v_value_type = 'int' THEN
        IF jsonb_typeof(v_field_value) NOT IN ('number', 'string') THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
            DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
        END IF;
        BEGIN
          v_value_text := ((v_field_value #>> '{}')::int)::text;
        EXCEPTION
          WHEN invalid_text_representation OR numeric_value_out_of_range THEN
            RAISE EXCEPTION USING
              MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
              DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
        END;
      ELSIF v_value_type = 'uuid' THEN
        IF jsonb_typeof(v_field_value) <> 'string' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
            DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
        END IF;
        BEGIN
          v_value_text := ((v_field_value #>> '{}')::uuid)::text;
        EXCEPTION
          WHEN invalid_text_representation THEN
            RAISE EXCEPTION USING
              MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
              DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
        END;
      ELSIF v_value_type = 'bool' THEN
        IF jsonb_typeof(v_field_value) <> 'boolean' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
            DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
        END IF;
        v_value_text := ((v_field_value #>> '{}')::boolean)::text;
      ELSIF v_value_type = 'date' THEN
        IF jsonb_typeof(v_field_value) <> 'string' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
            DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
        END IF;
        BEGIN
          v_value_text := ((v_field_value #>> '{}')::date)::text;
        EXCEPTION
          WHEN invalid_text_representation OR datetime_field_overflow THEN
            RAISE EXCEPTION USING
              MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
              DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
        END;
      ELSE
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
          DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
      END IF;
    END IF;

    v_label_text := NULL;
    IF v_data_source_type = 'DICT' THEN
      IF v_field_value <> 'null'::jsonb THEN
        IF NOT (v_labels ? v_field_key) THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_EXT_LABEL_SNAPSHOT_REQUIRED',
            DETAIL = format('field_key=%s', v_field_key);
        END IF;

        v_label_value := v_labels->v_field_key;
        IF jsonb_typeof(v_label_value) <> 'string'
          OR NULLIF(btrim(v_label_value #>> '{}'), '') IS NULL
        THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_EXT_LABEL_SNAPSHOT_REQUIRED',
            DETAIL = format('field_key=%s', v_field_key);
        END IF;
        v_label_text := btrim(v_label_value #>> '{}');
      ELSIF v_labels ? v_field_key THEN
        v_label_value := v_labels->v_field_key;
        IF jsonb_typeof(v_label_value) <> 'null' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_EXT_LABEL_SNAPSHOT_REQUIRED',
            DETAIL = format('field_key=%s', v_field_key);
        END IF;
      END IF;
    ELSIF v_labels ? v_field_key THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_EXT_LABEL_SNAPSHOT_NOT_ALLOWED',
        DETAIL = format('field_key=%s', v_field_key);
    END IF;

    v_cast_type := CASE v_value_type
      WHEN 'text' THEN 'text'
      WHEN 'int' THEN 'int'
      WHEN 'uuid' THEN 'uuid'
      WHEN 'bool' THEN 'boolean'
      WHEN 'date' THEN 'date'
      ELSE NULL
    END;

    IF v_cast_type IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_EXT_FIELD_TYPE_MISMATCH',
        DETAIL = format('field_key=%s value_type=%s', v_field_key, v_value_type);
    END IF;

    IF v_data_source_type = 'DICT' THEN
      IF v_field_value = 'null'::jsonb THEN
        v_sql := format(
          'UPDATE orgunit.org_unit_versions
             SET %1$I = $4::%2$s,
                 ext_labels_snapshot = COALESCE(ext_labels_snapshot, ''{}''::jsonb) - $5::text
           WHERE tenant_uuid = $1::uuid
             AND org_id = $2::int
             AND lower(validity) >= $3::date',
          v_physical_col,
          v_cast_type
        );
        EXECUTE v_sql USING p_tenant_uuid, p_org_id, p_effective_date, v_value_text, v_field_key;
      ELSE
        v_sql := format(
          'UPDATE orgunit.org_unit_versions
             SET %1$I = $4::%2$s,
                 ext_labels_snapshot = COALESCE(ext_labels_snapshot, ''{}''::jsonb)
                   || jsonb_build_object($5::text, to_jsonb($6::text))
           WHERE tenant_uuid = $1::uuid
             AND org_id = $2::int
             AND lower(validity) >= $3::date',
          v_physical_col,
          v_cast_type
        );
        EXECUTE v_sql USING p_tenant_uuid, p_org_id, p_effective_date, v_value_text, v_field_key, v_label_text;
      END IF;
    ELSE
      v_sql := format(
        'UPDATE orgunit.org_unit_versions
           SET %1$I = $4::%2$s
         WHERE tenant_uuid = $1::uuid
           AND org_id = $2::int
           AND lower(validity) >= $3::date',
        v_physical_col,
        v_cast_type
      );
      EXECUTE v_sql USING p_tenant_uuid, p_org_id, p_effective_date, v_value_text;
    END IF;
  END LOOP;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.split_org_unit_version_at(
  p_tenant_uuid uuid,
  p_org_id int,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_row orgunit.org_unit_versions%ROWTYPE;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  SELECT * INTO v_row
  FROM orgunit.org_unit_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND validity @> p_effective_date
    AND lower(validity) < p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  UPDATE orgunit.org_unit_versions
  SET validity = daterange(lower(validity), p_effective_date, '[)')
  WHERE id = v_row.id;

  INSERT INTO orgunit.org_unit_versions (
    tenant_uuid,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    full_name_path,
    status,
    is_business_unit,
    manager_uuid,
    ext_str_01,
    ext_str_02,
    ext_str_03,
    ext_str_04,
    ext_str_05,
    ext_int_01,
    ext_uuid_01,
    ext_bool_01,
    ext_date_01,
    ext_labels_snapshot,
    last_event_id
  )
  VALUES (
    v_row.tenant_uuid,
    v_row.org_id,
    v_row.parent_id,
    v_row.node_path,
    daterange(p_effective_date, upper(v_row.validity), '[)'),
    v_row.name,
    v_row.full_name_path,
    v_row.status,
    v_row.is_business_unit,
    v_row.manager_uuid,
    v_row.ext_str_01,
    v_row.ext_str_02,
    v_row.ext_str_03,
    v_row.ext_str_04,
    v_row.ext_str_05,
    v_row.ext_int_01,
    v_row.ext_uuid_01,
    v_row.ext_bool_01,
    v_row.ext_date_01,
    v_row.ext_labels_snapshot,
    p_event_db_id
  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_create_logic(
  p_tenant_uuid uuid,
  p_org_id int,
  p_org_code text,
  p_parent_id int,
  p_effective_date date,
  p_name text,
  p_manager_uuid uuid,
  p_is_business_unit boolean,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_parent_path ltree;
  v_node_path ltree;
  v_root_org_id int;
  v_is_business_unit boolean;
  v_org_code text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_name IS NULL OR btrim(p_name) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'name is required';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid AND org_id = p_org_id
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_ALREADY_EXISTS', DETAIL = format('org_id=%s', p_org_id);
  END IF;

  IF p_parent_id IS NULL THEN
    SELECT t.root_org_id INTO v_root_org_id
    FROM orgunit.org_trees t
    WHERE t.tenant_uuid = p_tenant_uuid
    FOR UPDATE;

    IF v_root_org_id IS NOT NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_ROOT_ALREADY_EXISTS',
        DETAIL = format('root_org_id=%s', v_root_org_id);
    END IF;

    INSERT INTO orgunit.org_trees (tenant_uuid, root_org_id)
    VALUES (p_tenant_uuid, p_org_id);

    v_node_path := text2ltree(orgunit.org_ltree_label(p_org_id));
    IF p_is_business_unit IS NOT NULL AND p_is_business_unit = false THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_ROOT_BUSINESS_UNIT_REQUIRED',
        DETAIL = format('org_id=%s', p_org_id);
    END IF;
    v_is_business_unit := true;
  ELSE
    SELECT t.root_org_id INTO v_root_org_id
    FROM orgunit.org_trees t
    WHERE t.tenant_uuid = p_tenant_uuid;

    IF v_root_org_id IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_TREE_NOT_INITIALIZED',
        DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
    END IF;

    SELECT v.node_path INTO v_parent_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.org_id = p_parent_id
      AND v.status = 'active'
      AND v.validity @> p_effective_date
    LIMIT 1;

    IF v_parent_path IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_PARENT_NOT_FOUND_AS_OF',
        DETAIL = format('parent_id=%s as_of=%s', p_parent_id, p_effective_date);
    END IF;

    v_node_path := v_parent_path || text2ltree(orgunit.org_ltree_label(p_org_id));
    v_is_business_unit := COALESCE(p_is_business_unit, false);
  END IF;

  v_org_code := NULLIF(p_org_code, '');
  IF v_org_code IS NOT NULL THEN
    v_org_code := upper(v_org_code);
    INSERT INTO orgunit.org_unit_codes (tenant_uuid, org_id, org_code)
    VALUES (p_tenant_uuid, p_org_id, v_org_code);
  END IF;

  INSERT INTO orgunit.org_unit_versions (
    tenant_uuid,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    full_name_path,
    status,
    is_business_unit,
    manager_uuid,
    last_event_id
  )
  VALUES (
    p_tenant_uuid,
    p_org_id,
    p_parent_id,
    v_node_path,
    daterange(p_effective_date, NULL, '[)'),
    p_name,
    p_name,
    'active',
    v_is_business_unit,
    p_manager_uuid,
    p_event_db_id
  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_move_logic(
  p_tenant_uuid uuid,
  p_org_id int,
  p_new_parent_id int,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_root_org_id int;
  v_old_path ltree;
  v_new_parent_path ltree;
  v_new_prefix ltree;
  v_old_level int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_new_parent_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'new_parent_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid;

  IF v_root_org_id IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_TREE_NOT_INITIALIZED',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;
  IF v_root_org_id = p_org_id THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ROOT_CANNOT_BE_MOVED',
      DETAIL = format('root_org_id=%s', v_root_org_id);
  END IF;

  SELECT v.node_path INTO v_old_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_org_id
    AND v.status = 'active'
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1
  FOR UPDATE;

  IF v_old_path IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  SELECT v.node_path INTO v_new_parent_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_new_parent_id
    AND v.status = 'active'
    AND v.validity @> p_effective_date
  LIMIT 1;

  IF v_new_parent_path IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_PARENT_NOT_FOUND_AS_OF',
      DETAIL = format('parent_id=%s as_of=%s', p_new_parent_id, p_effective_date);
  END IF;

  IF v_new_parent_path <@ v_old_path THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_CYCLE_MOVE',
      DETAIL = format('cycle move: org_id=%s new_parent_id=%s', p_org_id, p_new_parent_id);
  END IF;

  v_new_prefix := v_new_parent_path || text2ltree(orgunit.org_ltree_label(p_org_id));
  v_old_level := nlevel(v_old_path);

  WITH split AS (
    SELECT *
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND node_path <@ v_old_path
      AND validity @> p_effective_date
      AND lower(validity) < p_effective_date
  ),
  upd AS (
    UPDATE orgunit.org_unit_versions v
    SET validity = daterange(lower(v.validity), p_effective_date, '[)')
    FROM split s
    WHERE v.id = s.id
    RETURNING s.*
  )
  INSERT INTO orgunit.org_unit_versions (
    tenant_uuid,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    full_name_path,
    status,
    is_business_unit,
    manager_uuid,
    ext_str_01,
    ext_str_02,
    ext_str_03,
    ext_str_04,
    ext_str_05,
    ext_int_01,
    ext_uuid_01,
    ext_bool_01,
    ext_date_01,
    ext_labels_snapshot,
    last_event_id
  )
  SELECT
    u.tenant_uuid,
    u.org_id,
    CASE WHEN u.org_id = p_org_id THEN p_new_parent_id ELSE u.parent_id END,
    CASE
      WHEN u.org_id = p_org_id THEN v_new_prefix
      ELSE v_new_prefix || subpath(u.node_path, v_old_level)
    END,
    daterange(p_effective_date, upper(u.validity), '[)'),
    u.name,
    u.full_name_path,
    u.status,
    u.is_business_unit,
    u.manager_uuid,
    u.ext_str_01,
    u.ext_str_02,
    u.ext_str_03,
    u.ext_str_04,
    u.ext_str_05,
    u.ext_int_01,
    u.ext_uuid_01,
    u.ext_bool_01,
    u.ext_date_01,
    u.ext_labels_snapshot,
    p_event_db_id
  FROM upd u;

  UPDATE orgunit.org_unit_versions v
  SET
    node_path = CASE
      WHEN v.org_id = p_org_id THEN v_new_prefix
        ELSE v_new_prefix || subpath(v.node_path, v_old_level)
      END,
    parent_id = CASE WHEN v.org_id = p_org_id THEN p_new_parent_id ELSE v.parent_id END,
    last_event_id = p_event_db_id
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.node_path <@ v_old_path
    AND lower(v.validity) >= p_effective_date;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_rename_logic(
  p_tenant_uuid uuid,
  p_org_id int,
  p_effective_date date,
  p_new_name text,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_stop_date date;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_new_name IS NULL OR btrim(p_new_name) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'new_name is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND org_id = p_org_id
      AND validity @> p_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_uuid, p_org_id, p_effective_date, p_event_db_id);

  SELECT MIN(e.effective_date) INTO v_stop_date
  FROM orgunit.org_events_effective e
  WHERE e.tenant_uuid = p_tenant_uuid
    AND e.org_id = p_org_id
    AND e.event_type = 'RENAME'
    AND e.effective_date > p_effective_date;

  UPDATE orgunit.org_unit_versions
  SET name = p_new_name, last_event_id = p_event_db_id
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date
    AND (v_stop_date IS NULL OR lower(validity) < v_stop_date);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_disable_logic(
  p_tenant_uuid uuid,
  p_org_id int,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND org_id = p_org_id
      AND validity @> p_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_uuid, p_org_id, p_effective_date, p_event_db_id);

  UPDATE orgunit.org_unit_versions
  SET status = 'disabled', last_event_id = p_event_db_id
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_enable_logic(
  p_tenant_uuid uuid,
  p_org_id int,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND org_id = p_org_id
      AND validity @> p_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_uuid, p_org_id, p_effective_date, p_event_db_id);

  UPDATE orgunit.org_unit_versions
  SET status = 'active', last_event_id = p_event_db_id
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_set_business_unit_logic(
  p_tenant_uuid uuid,
  p_org_id int,
  p_effective_date date,
  p_is_business_unit boolean,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_stop_date date;
  v_status text;
  v_root_org_id int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_is_business_unit IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'is_business_unit is required';
  END IF;

  SELECT v.status INTO v_status
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_org_id
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_status IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;
  IF v_status <> 'active' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INACTIVE_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid;

  IF v_root_org_id IS NOT NULL AND v_root_org_id = p_org_id AND p_is_business_unit = false THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ROOT_BUSINESS_UNIT_REQUIRED',
      DETAIL = format('org_id=%s', p_org_id);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_uuid, p_org_id, p_effective_date, p_event_db_id);

  SELECT MIN(e.effective_date) INTO v_stop_date
  FROM orgunit.org_events_effective e
  WHERE e.tenant_uuid = p_tenant_uuid
    AND e.org_id = p_org_id
    AND e.event_type = 'SET_BUSINESS_UNIT'
    AND e.effective_date > p_effective_date;

  UPDATE orgunit.org_unit_versions
  SET is_business_unit = p_is_business_unit, last_event_id = p_event_db_id
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date
    AND (v_stop_date IS NULL OR lower(validity) < v_stop_date);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.rebuild_full_name_path_subtree(
  p_tenant_uuid uuid,
  p_root_path ltree,
  p_from_date date
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_root_path IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'root_path is required';
  END IF;
  IF p_from_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'from_date is required';
  END IF;

  UPDATE orgunit.org_unit_versions v
  SET full_name_path = (
    SELECT string_agg(a.name, ' / ' ORDER BY t.idx)
    FROM unnest(v.path_ids) WITH ORDINALITY AS t(uid, idx)
    JOIN orgunit.org_unit_versions a
      ON a.tenant_uuid = v.tenant_uuid
     AND a.org_id = t.uid
     AND a.validity @> lower(v.validity)
  )
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.node_path <@ p_root_path
    AND lower(v.validity) >= p_from_date;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.assert_org_unit_validity(
  p_tenant_uuid uuid,
  p_org_ids int[]
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_ids IS NULL OR array_length(p_org_ids, 1) IS NULL THEN
    RETURN;
  END IF;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        org_id,
        validity,
        lag(validity) OVER (PARTITION BY org_id ORDER BY lower(validity)) AS prev_validity
      FROM orgunit.org_unit_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND org_id = ANY(p_org_ids)
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_VALIDITY_GAP',
      DETAIL = 'org_unit_versions must be gapless';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT DISTINCT ON (org_id) org_id, validity
      FROM orgunit.org_unit_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND org_id = ANY(p_org_ids)
      ORDER BY org_id, lower(validity) DESC
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_VALIDITY_NOT_INFINITE',
      DETAIL = 'last version validity must be unbounded (infinity)';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.org_events_effective_for_replay(
  p_tenant_uuid uuid,
  p_org_id int,
  p_pending_event_id bigint,
  p_pending_event_uuid uuid,
  p_pending_event_type text,
  p_pending_effective_date date,
  p_pending_payload jsonb,
  p_pending_request_code text,
  p_pending_initiator_uuid uuid,
  p_pending_tx_time timestamptz,
  p_pending_transaction_time timestamptz,
  p_pending_created_at timestamptz
)
RETURNS TABLE (
  id bigint,
  event_uuid uuid,
  tenant_uuid uuid,
  org_id int,
  event_type text,
  effective_date date,
  payload jsonb,
  request_code text,
  initiator_uuid uuid,
  transaction_time timestamptz,
  created_at timestamptz
)
LANGUAGE sql
STABLE
AS $$
  WITH source_events AS (
    SELECT
      e.id,
      e.event_uuid,
      e.tenant_uuid,
      e.org_id,
      e.event_type,
      e.effective_date,
      COALESCE(e.payload, '{}'::jsonb) AS payload,
      e.request_code,
      e.initiator_uuid,
      e.tx_time,
      e.transaction_time,
      e.created_at
    FROM orgunit.org_events e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.org_id = p_org_id

    UNION ALL

    SELECT
      p_pending_event_id,
      p_pending_event_uuid,
      p_tenant_uuid,
      p_org_id,
      p_pending_event_type,
      p_pending_effective_date,
      COALESCE(p_pending_payload, '{}'::jsonb),
      p_pending_request_code,
      p_pending_initiator_uuid,
      p_pending_tx_time,
      p_pending_transaction_time,
      p_pending_created_at
    WHERE p_pending_event_id IS NOT NULL
  ),
  correction_events AS (
    SELECT
      se.*,
      (se.payload->>'target_event_uuid')::uuid AS target_event_uuid
    FROM source_events se
    WHERE se.event_type IN ('CORRECT_EVENT','CORRECT_STATUS','RESCIND_EVENT','RESCIND_ORG')
      AND se.payload ? 'target_event_uuid'
  ),
  latest_corrections AS (
    SELECT DISTINCT ON (tenant_uuid, target_event_uuid)
      tenant_uuid,
      target_event_uuid,
      event_type AS correction_type,
      payload AS correction_payload,
      tx_time,
      id
    FROM correction_events
    ORDER BY tenant_uuid, target_event_uuid, tx_time DESC, id DESC
  )
  SELECT
    se.id,
    se.event_uuid,
    se.tenant_uuid,
    se.org_id,
    CASE
      WHEN lc.correction_type = 'CORRECT_STATUS'
        AND COALESCE(lc.correction_payload->>'target_status', '') = 'active'
        THEN 'ENABLE'
      WHEN lc.correction_type = 'CORRECT_STATUS'
        AND COALESCE(lc.correction_payload->>'target_status', '') = 'disabled'
        THEN 'DISABLE'
      ELSE se.event_type
    END AS event_type,
    CASE
      WHEN lc.correction_type = 'CORRECT_EVENT'
        AND lc.correction_payload ? 'effective_date'
        THEN NULLIF(btrim(lc.correction_payload->>'effective_date'), '')::date
      ELSE se.effective_date
    END AS effective_date,
    CASE
      WHEN lc.correction_type = 'CORRECT_EVENT'
        THEN orgunit.merge_org_event_payload_with_correction(se.payload, lc.correction_payload)
      ELSE se.payload
    END AS payload,
    se.request_code,
    se.initiator_uuid,
    se.transaction_time,
    se.created_at
  FROM source_events se
  LEFT JOIN latest_corrections lc
    ON lc.tenant_uuid = se.tenant_uuid
   AND lc.target_event_uuid = se.event_uuid
  WHERE se.event_type IN ('CREATE','MOVE','RENAME','DISABLE','ENABLE','SET_BUSINESS_UNIT')
    AND COALESCE(lc.correction_type, '') NOT IN ('RESCIND_EVENT', 'RESCIND_ORG')
  ORDER BY effective_date, id;
$$;

CREATE OR REPLACE FUNCTION orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
  p_tenant_uuid uuid,
  p_org_id int,
  p_pending_event_id bigint,
  p_pending_event_uuid uuid,
  p_pending_event_type text,
  p_pending_effective_date date,
  p_pending_payload jsonb,
  p_pending_request_code text,
  p_pending_initiator_uuid uuid,
  p_pending_tx_time timestamptz,
  p_pending_transaction_time timestamptz,
  p_pending_created_at timestamptz
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_event record;
  v_payload jsonb;
  v_parent_id int;
  v_new_parent_id int;
  v_name text;
  v_new_name text;
  v_manager_uuid uuid;
  v_is_business_unit boolean;
  v_org_code text;
  v_root_path ltree;
  v_org_ids int[];
  v_root_org_id int;
  v_has_create boolean;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;

  IF p_pending_event_id IS NOT NULL THEN
    IF p_pending_event_uuid IS NULL
      OR p_pending_event_type IS NULL
      OR p_pending_effective_date IS NULL
      OR p_pending_request_code IS NULL
      OR p_pending_initiator_uuid IS NULL
      OR p_pending_tx_time IS NULL
      OR p_pending_transaction_time IS NULL
      OR p_pending_created_at IS NULL
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_INVALID_ARGUMENT',
        DETAIL = 'pending event metadata is incomplete';
    END IF;
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid;

  SELECT EXISTS (
    SELECT 1
    FROM orgunit.org_events_effective_for_replay(
      p_tenant_uuid,
      p_org_id,
      p_pending_event_id,
      p_pending_event_uuid,
      p_pending_event_type,
      p_pending_effective_date,
      p_pending_payload,
      p_pending_request_code,
      p_pending_initiator_uuid,
      p_pending_tx_time,
      p_pending_transaction_time,
      p_pending_created_at
    ) e
    WHERE e.event_type = 'CREATE'
  ) INTO v_has_create;

  IF v_has_create AND v_root_org_id = p_org_id THEN
    DELETE FROM orgunit.org_trees
    WHERE tenant_uuid = p_tenant_uuid;
  ELSIF v_root_org_id = p_org_id AND NOT v_has_create THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('root org missing create event: org_id=%s', p_org_id);
  END IF;

  DELETE FROM orgunit.org_unit_codes
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id;

  DELETE FROM orgunit.org_unit_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id;

  FOR v_event IN
    SELECT *
    FROM orgunit.org_events_effective_for_replay(
      p_tenant_uuid,
      p_org_id,
      p_pending_event_id,
      p_pending_event_uuid,
      p_pending_event_type,
      p_pending_effective_date,
      p_pending_payload,
      p_pending_request_code,
      p_pending_initiator_uuid,
      p_pending_tx_time,
      p_pending_transaction_time,
      p_pending_created_at
    )
    ORDER BY effective_date, id
  LOOP
    v_payload := COALESCE(v_event.payload, '{}'::jsonb);

    IF v_event.event_type = 'CREATE' THEN
      v_parent_id := NULLIF(v_payload->>'parent_id', '')::int;
      v_name := NULLIF(btrim(v_payload->>'name'), '');
      v_manager_uuid := NULLIF(v_payload->>'manager_uuid', '')::uuid;
      v_org_code := NULLIF(v_payload->>'org_code', '');
      v_is_business_unit := NULL;
      IF v_payload ? 'is_business_unit' THEN
        BEGIN
          v_is_business_unit := (v_payload->>'is_business_unit')::boolean;
        EXCEPTION
          WHEN invalid_text_representation THEN
            RAISE EXCEPTION USING
              MESSAGE = 'ORG_INVALID_ARGUMENT',
              DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
        END;
      END IF;
      PERFORM orgunit.apply_create_logic(p_tenant_uuid, v_event.org_id, v_org_code, v_parent_id, v_event.effective_date, v_name, v_manager_uuid, v_is_business_unit, v_event.id);
      SELECT v.node_path INTO v_root_path
      FROM orgunit.org_unit_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.org_id = p_org_id
        AND v.validity @> v_event.effective_date
      ORDER BY lower(v.validity) DESC
      LIMIT 1;
      IF v_root_path IS NOT NULL THEN
        PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, v_event.effective_date);
      END IF;
    ELSIF v_event.event_type = 'MOVE' THEN
      v_new_parent_id := NULLIF(v_payload->>'new_parent_id', '')::int;
      PERFORM orgunit.apply_move_logic(p_tenant_uuid, v_event.org_id, v_new_parent_id, v_event.effective_date, v_event.id);
      SELECT v.node_path INTO v_root_path
      FROM orgunit.org_unit_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.org_id = p_org_id
        AND v.validity @> v_event.effective_date
      ORDER BY lower(v.validity) DESC
      LIMIT 1;
      IF v_root_path IS NOT NULL THEN
        PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, v_event.effective_date);
      END IF;
    ELSIF v_event.event_type = 'RENAME' THEN
      v_new_name := NULLIF(btrim(v_payload->>'new_name'), '');
      PERFORM orgunit.apply_rename_logic(p_tenant_uuid, v_event.org_id, v_event.effective_date, v_new_name, v_event.id);
      SELECT v.node_path INTO v_root_path
      FROM orgunit.org_unit_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.org_id = p_org_id
        AND v.validity @> v_event.effective_date
      ORDER BY lower(v.validity) DESC
      LIMIT 1;
      IF v_root_path IS NOT NULL THEN
        PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, v_event.effective_date);
      END IF;
    ELSIF v_event.event_type = 'DISABLE' THEN
      PERFORM orgunit.apply_disable_logic(p_tenant_uuid, v_event.org_id, v_event.effective_date, v_event.id);
    ELSIF v_event.event_type = 'ENABLE' THEN
      PERFORM orgunit.apply_enable_logic(p_tenant_uuid, v_event.org_id, v_event.effective_date, v_event.id);
    ELSIF v_event.event_type = 'SET_BUSINESS_UNIT' THEN
      IF NOT (v_payload ? 'is_business_unit') THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_INVALID_ARGUMENT',
          DETAIL = 'is_business_unit is required';
      END IF;
      BEGIN
        v_is_business_unit := (v_payload->>'is_business_unit')::boolean;
      EXCEPTION
        WHEN invalid_text_representation THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_INVALID_ARGUMENT',
            DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
      END;
      PERFORM orgunit.apply_set_business_unit_logic(p_tenant_uuid, v_event.org_id, v_event.effective_date, v_is_business_unit, v_event.id);
    ELSE
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_event.event_type);
    END IF;

    PERFORM orgunit.apply_org_event_ext_payload(
      p_tenant_uuid,
      v_event.org_id,
      v_event.effective_date,
      v_event.event_type,
      v_payload
    );
  END LOOP;

  SELECT v.node_path INTO v_root_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_org_id
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_root_path IS NULL THEN
    RETURN;
  END IF;

  SELECT array_agg(DISTINCT v.org_id) INTO v_org_ids
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.node_path <@ v_root_path;

  PERFORM orgunit.assert_org_unit_validity(p_tenant_uuid, v_org_ids);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.rebuild_org_unit_versions_for_org(
  p_tenant_uuid uuid,
  p_org_id int
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
    p_tenant_uuid,
    p_org_id,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.extract_orgunit_snapshot(
  p_tenant_uuid uuid,
  p_org_id int,
  p_as_of date
)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
  v_row orgunit.org_unit_versions%ROWTYPE;
  v_snapshot jsonb;
  v_org_code text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_as_of IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'as_of is required';
  END IF;

  SELECT * INTO v_row
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_org_id
    AND v.validity @> p_as_of
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF NOT FOUND THEN
    RETURN NULL;
  END IF;

  SELECT c.org_code INTO v_org_code
  FROM orgunit.org_unit_codes c
  WHERE c.tenant_uuid = p_tenant_uuid
    AND c.org_id = p_org_id
  LIMIT 1;

  v_snapshot := to_jsonb(v_row) - 'id' - 'tenant_uuid' - 'last_event_id' - 'path_ids';
  IF v_org_code IS NOT NULL THEN
    v_snapshot := jsonb_set(v_snapshot, '{org_code}', to_jsonb(v_org_code), true);
  END IF;

  IF jsonb_typeof(v_snapshot) <> 'object' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_AUDIT_SNAPSHOT_INVALID',
      DETAIL = format('org_id=%s as_of=%s snapshot_type=%s', p_org_id, p_as_of, COALESCE(jsonb_typeof(v_snapshot), 'null'));
  END IF;

  RETURN v_snapshot;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.assert_org_event_snapshots(
  p_event_type text,
  p_before_snapshot jsonb,
  p_after_snapshot jsonb,
  p_rescind_outcome text
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  IF p_before_snapshot IS NOT NULL AND jsonb_typeof(p_before_snapshot) <> 'object' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_AUDIT_SNAPSHOT_INVALID',
      DETAIL = format('event_type=%s before_snapshot_type=%s', p_event_type, jsonb_typeof(p_before_snapshot));
  END IF;

  IF p_after_snapshot IS NOT NULL AND jsonb_typeof(p_after_snapshot) <> 'object' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_AUDIT_SNAPSHOT_INVALID',
      DETAIL = format('event_type=%s after_snapshot_type=%s', p_event_type, jsonb_typeof(p_after_snapshot));
  END IF;

  IF NOT orgunit.is_org_event_snapshot_presence_valid(
    p_event_type,
    p_before_snapshot,
    p_after_snapshot,
    p_rescind_outcome
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_AUDIT_SNAPSHOT_MISSING',
      DETAIL = format(
        'event_type=%s before=%s after=%s rescind_outcome=%s',
        p_event_type,
        p_before_snapshot IS NOT NULL,
        p_after_snapshot IS NOT NULL,
        COALESCE(p_rescind_outcome, 'NULL')
      );
  END IF;

  IF NOT orgunit.is_org_event_snapshot_content_valid(
    p_event_type,
    p_before_snapshot,
    p_after_snapshot,
    p_rescind_outcome
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_AUDIT_SNAPSHOT_INVALID',
      DETAIL = format(
        'event_type=%s incomplete_snapshot_content=true rescind_outcome=%s',
        p_event_type,
        COALESCE(p_rescind_outcome, 'NULL')
      );
  END IF;
END;
$$;

-- Backward-compatible wrapper for existing 3-arg callers during rollout.
CREATE OR REPLACE FUNCTION orgunit.assert_org_event_snapshots(
  p_event_type text,
  p_before_snapshot jsonb,
  p_after_snapshot jsonb
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_org_event_snapshots(
    p_event_type,
    p_before_snapshot,
    p_after_snapshot,
    NULL
  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_org_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_org_id int,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing orgunit.org_events%ROWTYPE;
  v_existing_request orgunit.org_events%ROWTYPE;
  v_payload jsonb;
  v_parent_id int;
  v_new_parent_id int;
  v_name text;
  v_new_name text;
  v_manager_uuid uuid;
  v_is_business_unit boolean;
  v_org_code text;
  v_root_path ltree;
  v_org_ids int[];
  v_before_snapshot jsonb;
  v_after_snapshot jsonb;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'event_uuid is required';
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  IF p_event_type NOT IN ('CREATE','MOVE','RENAME','DISABLE','ENABLE','SET_BUSINESS_UNIT') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_lock_key := format('org:write-lock:%s', p_tenant_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF p_event_type = 'SET_BUSINESS_UNIT' THEN
    IF NOT (v_payload ? 'is_business_unit') THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_INVALID_ARGUMENT',
        DETAIL = 'is_business_unit is required';
    END IF;
    BEGIN
      PERFORM (v_payload->>'is_business_unit')::boolean;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_INVALID_ARGUMENT',
          DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
    END;
  END IF;

  SELECT * INTO v_existing_request
  FROM orgunit.org_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = p_request_code
  LIMIT 1;

  IF FOUND THEN
    IF v_existing_request.event_uuid <> p_event_uuid
      OR v_existing_request.org_id <> p_org_id
      OR v_existing_request.event_type <> p_event_type
      OR v_existing_request.effective_date <> p_effective_date
      OR v_existing_request.payload <> v_payload
      OR v_existing_request.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
        DETAIL = format('request_code=%s', p_request_code);
    END IF;

    RETURN v_existing_request.id;
  END IF;

  v_before_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, p_effective_date);

  SELECT * INTO v_existing
  FROM orgunit.org_events
  WHERE event_uuid = p_event_uuid;

  IF FOUND THEN
    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.org_id <> p_org_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  SELECT nextval(pg_get_serial_sequence('orgunit.org_events', 'id')) INTO v_event_db_id;

  IF p_event_type = 'CREATE' THEN
    v_parent_id := NULLIF(v_payload->>'parent_id', '')::int;
    v_name := NULLIF(btrim(v_payload->>'name'), '');
    v_manager_uuid := NULLIF(v_payload->>'manager_uuid', '')::uuid;
    v_org_code := NULLIF(v_payload->>'org_code', '');
    v_is_business_unit := NULL;
    IF v_payload ? 'is_business_unit' THEN
      BEGIN
        v_is_business_unit := (v_payload->>'is_business_unit')::boolean;
      EXCEPTION
        WHEN invalid_text_representation THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_INVALID_ARGUMENT',
            DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
      END;
    END IF;
    PERFORM orgunit.apply_create_logic(p_tenant_uuid, p_org_id, v_org_code, v_parent_id, p_effective_date, v_name, v_manager_uuid, v_is_business_unit, v_event_db_id);
    SELECT v.node_path INTO v_root_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.org_id = p_org_id
      AND v.validity @> p_effective_date
    ORDER BY lower(v.validity) DESC
    LIMIT 1;
    PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, p_effective_date);
    v_org_ids := ARRAY[p_org_id];
  ELSIF p_event_type = 'MOVE' THEN
    v_new_parent_id := NULLIF(v_payload->>'new_parent_id', '')::int;
    PERFORM orgunit.apply_move_logic(p_tenant_uuid, p_org_id, v_new_parent_id, p_effective_date, v_event_db_id);
    SELECT v.node_path INTO v_root_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.org_id = p_org_id
      AND v.validity @> p_effective_date
    ORDER BY lower(v.validity) DESC
    LIMIT 1;
    PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, p_effective_date);
    SELECT array_agg(DISTINCT v.org_id) INTO v_org_ids
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.node_path <@ v_root_path;
  ELSIF p_event_type = 'RENAME' THEN
    v_new_name := NULLIF(btrim(v_payload->>'new_name'), '');
    PERFORM orgunit.apply_rename_logic(p_tenant_uuid, p_org_id, p_effective_date, v_new_name, v_event_db_id);
    SELECT v.node_path INTO v_root_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.org_id = p_org_id
      AND v.validity @> p_effective_date
    ORDER BY lower(v.validity) DESC
    LIMIT 1;
    PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, p_effective_date);
    v_org_ids := ARRAY[p_org_id];
  ELSIF p_event_type = 'DISABLE' THEN
    PERFORM orgunit.apply_disable_logic(p_tenant_uuid, p_org_id, p_effective_date, v_event_db_id);
    v_org_ids := ARRAY[p_org_id];
  ELSIF p_event_type = 'ENABLE' THEN
    PERFORM orgunit.apply_enable_logic(p_tenant_uuid, p_org_id, p_effective_date, v_event_db_id);
    v_org_ids := ARRAY[p_org_id];
  ELSIF p_event_type = 'SET_BUSINESS_UNIT' THEN
    v_is_business_unit := (v_payload->>'is_business_unit')::boolean;
    PERFORM orgunit.apply_set_business_unit_logic(p_tenant_uuid, p_org_id, p_effective_date, v_is_business_unit, v_event_db_id);
    v_org_ids := ARRAY[p_org_id];
  END IF;

  PERFORM orgunit.assert_org_unit_validity(p_tenant_uuid, v_org_ids);

  v_after_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, p_effective_date);
  PERFORM orgunit.assert_org_event_snapshots(p_event_type, v_before_snapshot, v_after_snapshot, NULL);

  INSERT INTO orgunit.org_events (
    id,
    event_uuid,
    tenant_uuid,
    org_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid,
    before_snapshot,
    after_snapshot
  )
  VALUES (
    v_event_db_id,
    p_event_uuid,
    p_tenant_uuid,
    p_org_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid,
    v_before_snapshot,
    v_after_snapshot
  );

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_org_event_rescind(
  p_tenant_uuid uuid,
  p_org_id int,
  p_target_effective_date date,
  p_reason text,
  p_request_id text,
  p_initiator_uuid uuid
)
RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_target orgunit.org_events%ROWTYPE;
  v_existing_request orgunit.org_events%ROWTYPE;
  v_existing_rescind orgunit.org_events%ROWTYPE;
  v_reason text;
  v_event_uuid uuid;
  v_payload jsonb;
  v_before_snapshot jsonb;
  v_after_snapshot jsonb;
  v_event_db_id bigint;
  v_rescind_outcome text;
  v_pending_time timestamptz;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_target_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'target_effective_date is required';
  END IF;
  v_reason := btrim(COALESCE(p_reason, ''));
  IF v_reason = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'reason is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  v_lock_key := format('org:write-lock:%s', p_tenant_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_existing_request
  FROM orgunit.org_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = p_request_id
  LIMIT 1;

  IF FOUND THEN
    IF v_existing_request.event_type <> 'RESCIND_EVENT'
      OR v_existing_request.org_id <> p_org_id
      OR v_existing_request.effective_date <> p_target_effective_date
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
        DETAIL = format('request_id=%s', p_request_id);
    END IF;

    RETURN v_existing_request.event_uuid;
  END IF;

  SELECT e.* INTO v_target
  FROM orgunit.org_events e
  JOIN orgunit.org_events_effective ee
    ON ee.event_uuid = e.event_uuid
   AND ee.tenant_uuid = e.tenant_uuid
   AND ee.org_id = e.org_id
  WHERE ee.tenant_uuid = p_tenant_uuid
    AND ee.org_id = p_org_id
    AND ee.effective_date = p_target_effective_date
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EVENT_NOT_FOUND',
      DETAIL = format('org_id=%s target_effective_date=%s', p_org_id, p_target_effective_date);
  END IF;

  SELECT * INTO v_existing_rescind
  FROM orgunit.org_events r
  WHERE r.tenant_uuid = p_tenant_uuid
    AND r.event_type IN ('RESCIND_EVENT','RESCIND_ORG')
    AND r.payload->>'target_event_uuid' = v_target.event_uuid::text
  LIMIT 1;

  IF FOUND THEN
    RETURN v_existing_rescind.event_uuid;
  END IF;

  v_payload := jsonb_build_object(
    'op', 'RESCIND_EVENT',
    'reason', v_reason,
    'target_event_uuid', v_target.event_uuid,
    'target_effective_date', p_target_effective_date
  );

  v_before_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, p_target_effective_date);
  v_event_uuid := gen_random_uuid();
  v_pending_time := now();
  SELECT nextval(pg_get_serial_sequence('orgunit.org_events', 'id')) INTO v_event_db_id;

  PERFORM orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
    p_tenant_uuid,
    p_org_id,
    v_event_db_id,
    v_event_uuid,
    'RESCIND_EVENT',
    p_target_effective_date,
    v_payload,
    p_request_id,
    p_initiator_uuid,
    v_pending_time,
    v_pending_time,
    v_pending_time
  );

  v_after_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, p_target_effective_date);
  v_rescind_outcome := CASE WHEN v_after_snapshot IS NULL THEN 'ABSENT' ELSE 'PRESENT' END;
  PERFORM orgunit.assert_org_event_snapshots('RESCIND_EVENT', v_before_snapshot, v_after_snapshot, v_rescind_outcome);

  INSERT INTO orgunit.org_events (
    id,
    tenant_uuid,
    org_id,
    event_uuid,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid,
    reason,
    before_snapshot,
    after_snapshot,
    rescind_outcome,
    tx_time,
    transaction_time,
    created_at
  )
  VALUES (
    v_event_db_id,
    p_tenant_uuid,
    p_org_id,
    v_event_uuid,
    'RESCIND_EVENT',
    p_target_effective_date,
    v_payload,
    p_request_id,
    p_initiator_uuid,
    v_reason,
    v_before_snapshot,
    v_after_snapshot,
    v_rescind_outcome,
    v_pending_time,
    v_pending_time,
    v_pending_time
  );

  RETURN v_event_uuid;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_org_rescind(
  p_tenant_uuid uuid,
  p_org_id int,
  p_reason text,
  p_request_id text,
  p_initiator_uuid uuid
)
RETURNS int
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_reason text;
  v_root_org_id int;
  v_node_path ltree;
  v_event_count int;
  v_existing_batch_count int;
  v_need_apply boolean;
  v_request_id_seq text;
  v_payload jsonb;
  v_existing_request orgunit.org_events%ROWTYPE;
  v_existing_rescind orgunit.org_events%ROWTYPE;
  v_before_snapshot jsonb;
  v_after_snapshot jsonb;
  v_rescind_event_uuid uuid;
  v_rescind_event_id bigint;
  v_rescind_outcome text;
  v_pending_time timestamptz;
  rec record;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  v_reason := btrim(COALESCE(p_reason, ''));
  IF v_reason = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'reason is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  v_lock_key := format('org:write-lock:%s', p_tenant_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_existing_request
  FROM orgunit.org_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = p_request_id
  LIMIT 1;

  IF FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
      DETAIL = format('request_id=%s', p_request_id);
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid
  LIMIT 1;

  IF v_root_org_id = p_org_id THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ROOT_DELETE_FORBIDDEN',
      DETAIL = format('org_id=%s', p_org_id);
  END IF;

  SELECT v.node_path INTO v_node_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_org_id
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_node_path IS NOT NULL AND EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions c
    WHERE c.tenant_uuid = p_tenant_uuid
      AND c.node_path <@ v_node_path
      AND c.org_id <> p_org_id
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_HAS_CHILDREN_CANNOT_DELETE',
      DETAIL = format('org_id=%s', p_org_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM orgunit.setid_binding_versions b
    WHERE b.tenant_uuid = p_tenant_uuid
      AND b.org_id = p_org_id
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_HAS_DEPENDENCIES_CANNOT_DELETE',
      DETAIL = format('org_id=%s', p_org_id);
  END IF;

  SELECT COUNT(*) INTO v_event_count
  FROM orgunit.org_events e
  WHERE e.tenant_uuid = p_tenant_uuid
    AND e.org_id = p_org_id;

  IF v_event_count = 0 THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EVENT_NOT_FOUND',
      DETAIL = format('org_id=%s', p_org_id);
  END IF;

  SELECT COUNT(*) INTO v_existing_batch_count
  FROM orgunit.org_events e
  WHERE e.tenant_uuid = p_tenant_uuid
    AND e.request_code LIKE p_request_id || '#%';

  IF v_existing_batch_count > 0 AND v_existing_batch_count <> v_event_count THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
      DETAIL = format('request_id=%s', p_request_id);
  END IF;

  v_need_apply := false;

  FOR rec IN
    SELECT
      row_number() OVER (ORDER BY e.effective_date, e.id) AS seq,
      e.event_uuid,
      COALESCE(ee.effective_date, e.effective_date) AS target_effective_date
    FROM orgunit.org_events e
    LEFT JOIN orgunit.org_events_effective ee
      ON ee.event_uuid = e.event_uuid
     AND ee.tenant_uuid = e.tenant_uuid
     AND ee.org_id = e.org_id
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.org_id = p_org_id
    ORDER BY e.effective_date, e.id
  LOOP
    v_request_id_seq := format('%s#%s', p_request_id, lpad(rec.seq::text, 4, '0'));
    SELECT * INTO v_existing_request
    FROM orgunit.org_events e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.request_code = v_request_id_seq
    LIMIT 1;

    IF FOUND THEN
      IF v_existing_request.event_type <> 'RESCIND_ORG'
        OR v_existing_request.org_id <> p_org_id
        OR COALESCE(v_existing_request.payload->>'target_event_uuid', '') <> rec.event_uuid::text
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
          DETAIL = format('request_id=%s', p_request_id);
      END IF;
      CONTINUE;
    END IF;

    v_need_apply := true;
  END LOOP;

  IF NOT v_need_apply THEN
    RETURN v_event_count;
  END IF;

  FOR rec IN
    SELECT
      row_number() OVER (ORDER BY e.effective_date, e.id) AS seq,
      e.event_uuid,
      COALESCE(ee.effective_date, e.effective_date) AS target_effective_date
    FROM orgunit.org_events e
    LEFT JOIN orgunit.org_events_effective ee
      ON ee.event_uuid = e.event_uuid
     AND ee.tenant_uuid = e.tenant_uuid
     AND ee.org_id = e.org_id
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.org_id = p_org_id
    ORDER BY e.effective_date, e.id
  LOOP
    v_request_id_seq := format('%s#%s', p_request_id, lpad(rec.seq::text, 4, '0'));
    SELECT * INTO v_existing_request
    FROM orgunit.org_events e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.request_code = v_request_id_seq
    LIMIT 1;

    IF FOUND THEN
      CONTINUE;
    END IF;

    SELECT * INTO v_existing_rescind
    FROM orgunit.org_events r
    WHERE r.tenant_uuid = p_tenant_uuid
      AND r.event_type IN ('RESCIND_EVENT','RESCIND_ORG')
      AND r.payload->>'target_event_uuid' = rec.event_uuid::text
    LIMIT 1;

    IF FOUND THEN
      CONTINUE;
    END IF;

    v_payload := jsonb_build_object(
      'op', 'RESCIND_ORG',
      'reason', v_reason,
      'batch_request_id', p_request_id,
      'target_event_uuid', rec.event_uuid,
      'target_effective_date', rec.target_effective_date
    );

    v_before_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, rec.target_effective_date);
    v_rescind_event_uuid := gen_random_uuid();
    v_pending_time := now();
    SELECT nextval(pg_get_serial_sequence('orgunit.org_events', 'id')) INTO v_rescind_event_id;

    PERFORM orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
      p_tenant_uuid,
      p_org_id,
      v_rescind_event_id,
      v_rescind_event_uuid,
      'RESCIND_ORG',
      rec.target_effective_date,
      v_payload,
      v_request_id_seq,
      p_initiator_uuid,
      v_pending_time,
      v_pending_time,
      v_pending_time
    );

    v_after_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, rec.target_effective_date);
    v_rescind_outcome := CASE WHEN v_after_snapshot IS NULL THEN 'ABSENT' ELSE 'PRESENT' END;
    PERFORM orgunit.assert_org_event_snapshots('RESCIND_ORG', v_before_snapshot, v_after_snapshot, v_rescind_outcome);

    INSERT INTO orgunit.org_events (
      id,
      tenant_uuid,
      org_id,
      event_uuid,
      event_type,
      effective_date,
      payload,
      request_code,
      initiator_uuid,
      reason,
      before_snapshot,
      after_snapshot,
      rescind_outcome,
      tx_time,
      transaction_time,
      created_at
    )
    VALUES (
      v_rescind_event_id,
      p_tenant_uuid,
      p_org_id,
      v_rescind_event_uuid,
      'RESCIND_ORG',
      rec.target_effective_date,
      v_payload,
      v_request_id_seq,
      p_initiator_uuid,
      v_reason,
      v_before_snapshot,
      v_after_snapshot,
      v_rescind_outcome,
      v_pending_time,
      v_pending_time,
      v_pending_time
    );
  END LOOP;

  RETURN v_event_count;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_org_event_correction(
  p_tenant_uuid uuid,
  p_org_id int,
  p_target_effective_date date,
  p_patch jsonb,
  p_request_id text,
  p_initiator_uuid uuid
)
RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_target orgunit.org_events%ROWTYPE;
  v_existing_request orgunit.org_events%ROWTYPE;
  v_existing_rescind orgunit.org_events%ROWTYPE;
  v_patch jsonb;
  v_payload jsonb;
  v_effective_payload jsonb;
  v_target_effective date;
  v_prev_effective date;
  v_new_effective date;
  v_next_effective date;
  v_parent_id int;
  v_target_path ltree;
  v_descendant_min_create date;
  v_event_uuid uuid;
  v_before_snapshot jsonb;
  v_after_snapshot jsonb;
  v_event_db_id bigint;
  v_pending_time timestamptz;
  v_base_ext jsonb;
  v_patch_ext jsonb;
  v_ext_merged jsonb;
  v_base_labels jsonb;
  v_patch_labels jsonb;
  v_labels_merged jsonb;
  v_label_key text;
  v_label_remove_keys text[];
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_target_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'target_effective_date is required';
  END IF;
  IF p_patch IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'patch is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  v_patch := p_patch;
  IF jsonb_typeof(v_patch) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'patch must be an object';
  END IF;

  IF v_patch ? 'ext' AND jsonb_typeof(v_patch->'ext') <> 'object' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EXT_PAYLOAD_INVALID_SHAPE',
      DETAIL = 'patch.ext must be an object';
  END IF;
  IF v_patch ? 'ext_labels_snapshot' AND jsonb_typeof(v_patch->'ext_labels_snapshot') <> 'object' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EXT_PAYLOAD_INVALID_SHAPE',
      DETAIL = 'patch.ext_labels_snapshot must be an object';
  END IF;
  IF v_patch ? 'ext_labels_snapshot' THEN
    FOR v_label_key IN
      SELECT key
      FROM jsonb_object_keys(v_patch->'ext_labels_snapshot') AS t(key)
    LOOP
      IF NOT (COALESCE(v_patch->'ext', '{}'::jsonb) ? v_label_key) THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_EXT_LABEL_SNAPSHOT_NOT_ALLOWED',
          DETAIL = format('field_key=%s', v_label_key);
      END IF;
    END LOOP;
  END IF;

  v_lock_key := format('org:write-lock:%s', p_tenant_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT e.* INTO v_target
  FROM orgunit.org_events e
  JOIN orgunit.org_events_effective ee
    ON ee.event_uuid = e.event_uuid
   AND ee.tenant_uuid = e.tenant_uuid
   AND ee.org_id = e.org_id
  WHERE ee.tenant_uuid = p_tenant_uuid
    AND ee.org_id = p_org_id
    AND ee.effective_date = p_target_effective_date
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EVENT_NOT_FOUND',
      DETAIL = format('org_id=%s target_effective_date=%s', p_org_id, p_target_effective_date);
  END IF;

  SELECT * INTO v_existing_rescind
  FROM orgunit.org_events r
  WHERE r.tenant_uuid = p_tenant_uuid
    AND r.event_type IN ('RESCIND_EVENT','RESCIND_ORG')
    AND r.payload->>'target_event_uuid' = v_target.event_uuid::text
  LIMIT 1;

  IF FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EVENT_RESCINDED',
      DETAIL = format('event_uuid=%s', v_target.event_uuid);
  END IF;

  SELECT ee.effective_date, ee.payload
  INTO v_target_effective, v_effective_payload
  FROM orgunit.org_events_effective ee
  WHERE ee.tenant_uuid = p_tenant_uuid
    AND ee.org_id = p_org_id
    AND ee.event_uuid = v_target.event_uuid
  LIMIT 1;

  v_payload := (COALESCE(v_effective_payload, '{}'::jsonb) - 'ext' - 'ext_labels_snapshot')
    || (v_patch - 'ext' - 'ext_labels_snapshot');

  v_base_ext := CASE
    WHEN jsonb_typeof(COALESCE(v_effective_payload, '{}'::jsonb)->'ext') = 'object'
      THEN COALESCE(v_effective_payload, '{}'::jsonb)->'ext'
    ELSE '{}'::jsonb
  END;
  v_patch_ext := CASE
    WHEN jsonb_typeof(v_patch->'ext') = 'object'
      THEN v_patch->'ext'
    ELSE '{}'::jsonb
  END;
  v_ext_merged := v_base_ext || v_patch_ext;

  v_base_labels := CASE
    WHEN jsonb_typeof(COALESCE(v_effective_payload, '{}'::jsonb)->'ext_labels_snapshot') = 'object'
      THEN COALESCE(v_effective_payload, '{}'::jsonb)->'ext_labels_snapshot'
    ELSE '{}'::jsonb
  END;
  v_patch_labels := CASE
    WHEN jsonb_typeof(v_patch->'ext_labels_snapshot') = 'object'
      THEN v_patch->'ext_labels_snapshot'
    ELSE '{}'::jsonb
  END;
  v_labels_merged := v_base_labels || v_patch_labels;

  SELECT array_agg(key) INTO v_label_remove_keys
  FROM jsonb_each(v_ext_merged)
  WHERE value = 'null'::jsonb;
  v_label_remove_keys := COALESCE(v_label_remove_keys, ARRAY[]::text[]);
  v_labels_merged := v_labels_merged - v_label_remove_keys;

  IF COALESCE(v_effective_payload, '{}'::jsonb) ? 'ext' OR v_patch ? 'ext' THEN
    v_payload := v_payload || jsonb_build_object('ext', v_ext_merged);
  END IF;
  IF COALESCE(v_effective_payload, '{}'::jsonb) ? 'ext_labels_snapshot' OR v_patch ? 'ext_labels_snapshot' THEN
    v_payload := v_payload || jsonb_build_object('ext_labels_snapshot', v_labels_merged);
  END IF;
  v_new_effective := v_target_effective;

  IF v_payload ? 'effective_date' THEN
    BEGIN
      v_new_effective := NULLIF(btrim(v_payload->>'effective_date'), '')::date;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          MESSAGE = 'EFFECTIVE_DATE_INVALID',
          DETAIL = format('effective_date=%s', v_payload->>'effective_date');
    END;
    IF v_new_effective IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'EFFECTIVE_DATE_INVALID',
        DETAIL = 'effective_date is required';
    END IF;
    -- keep effective_date in payload for audit and correction view
  END IF;

  SELECT MAX(e.effective_date) INTO v_prev_effective
  FROM orgunit.org_events_effective e
  WHERE e.tenant_uuid = p_tenant_uuid
    AND e.org_id = p_org_id
    AND e.effective_date < v_target_effective;

  SELECT MIN(e.effective_date) INTO v_next_effective
  FROM orgunit.org_events_effective e
  WHERE e.tenant_uuid = p_tenant_uuid
    AND e.org_id = p_org_id
    AND e.effective_date > v_target_effective;

  IF v_prev_effective IS NOT NULL AND v_new_effective <= v_prev_effective THEN
    RAISE EXCEPTION USING
      MESSAGE = 'EFFECTIVE_DATE_OUT_OF_RANGE',
      DETAIL = format('prev=%s new=%s', v_prev_effective, v_new_effective);
  END IF;
  IF v_next_effective IS NOT NULL AND v_new_effective >= v_next_effective THEN
    RAISE EXCEPTION USING
      MESSAGE = 'EFFECTIVE_DATE_OUT_OF_RANGE',
      DETAIL = format('next=%s new=%s', v_next_effective, v_new_effective);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM orgunit.org_events_effective e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.org_id = p_org_id
      AND e.effective_date = v_new_effective
      AND e.event_uuid <> v_target.event_uuid
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'EVENT_DATE_CONFLICT',
      DETAIL = format('org_id=%s effective_date=%s', p_org_id, v_new_effective);
  END IF;

  IF v_payload ? 'parent_id' THEN
    v_parent_id := NULLIF(v_payload->>'parent_id', '')::int;
    IF v_parent_id IS NOT NULL THEN
      IF v_parent_id = p_org_id THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_CYCLE_DETECTED',
          DETAIL = format('org_id=%s parent_id=%s', p_org_id, v_parent_id);
      END IF;
      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.org_unit_versions v
        WHERE v.tenant_uuid = p_tenant_uuid
          AND v.org_id = v_parent_id
          AND v.status = 'active'
          AND v.validity @> v_new_effective
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_PARENT_NOT_FOUND_AS_OF',
          DETAIL = format('parent_id=%s as_of=%s', v_parent_id, v_new_effective);
      END IF;
    END IF;
  END IF;

  -- Guard high-risk create reordering that would force replay to fail after full-table churn.
  IF v_target.event_type = 'CREATE' AND v_new_effective > v_target_effective THEN
    SELECT v.node_path INTO v_target_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.org_id = p_org_id
      AND v.validity @> v_target_effective
    ORDER BY lower(v.validity) DESC
    LIMIT 1;

    IF v_target_path IS NOT NULL THEN
      SELECT MIN(e.effective_date) INTO v_descendant_min_create
      FROM orgunit.org_events_effective e
      WHERE e.tenant_uuid = p_tenant_uuid
        AND e.event_type = 'CREATE'
        AND e.org_id <> p_org_id
        AND EXISTS (
          SELECT 1
          FROM orgunit.org_unit_versions dv
          WHERE dv.tenant_uuid = p_tenant_uuid
            AND dv.org_id = e.org_id
            AND dv.node_path <@ v_target_path
          LIMIT 1
        );

      IF v_descendant_min_create IS NOT NULL AND v_descendant_min_create < v_new_effective THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_HIGH_RISK_REORDER_FORBIDDEN',
          DETAIL = format(
            'org_id=%s target_effective=%s new_effective=%s descendant_create=%s',
            p_org_id,
            v_target_effective,
            v_new_effective,
            v_descendant_min_create
          );
      END IF;
    END IF;
  END IF;

  v_payload := jsonb_build_object(
    'op', 'CORRECT_EVENT',
    'target_event_uuid', v_target.event_uuid,
    'target_effective_date', p_target_effective_date
  ) || v_payload;

  SELECT * INTO v_existing_request
  FROM orgunit.org_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = p_request_id
  LIMIT 1;

  IF FOUND THEN
    IF v_existing_request.event_type <> 'CORRECT_EVENT'
      OR v_existing_request.org_id <> p_org_id
      OR v_existing_request.payload <> v_payload
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
        DETAIL = format('request_id=%s', p_request_id);
    END IF;

    RETURN v_existing_request.event_uuid;
  END IF;

  v_before_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, p_target_effective_date);
  v_event_uuid := gen_random_uuid();
  v_pending_time := now();
  SELECT nextval(pg_get_serial_sequence('orgunit.org_events', 'id')) INTO v_event_db_id;

  PERFORM orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
    p_tenant_uuid,
    p_org_id,
    v_event_db_id,
    v_event_uuid,
    'CORRECT_EVENT',
    p_target_effective_date,
    v_payload,
    p_request_id,
    p_initiator_uuid,
    v_pending_time,
    v_pending_time,
    v_pending_time
  );

  v_after_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, p_target_effective_date);
  PERFORM orgunit.assert_org_event_snapshots('CORRECT_EVENT', v_before_snapshot, v_after_snapshot, NULL);

  INSERT INTO orgunit.org_events (
    id,
    tenant_uuid,
    org_id,
    event_uuid,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid,
    before_snapshot,
    after_snapshot,
    tx_time,
    transaction_time,
    created_at
  )
  VALUES (
    v_event_db_id,
    p_tenant_uuid,
    p_org_id,
    v_event_uuid,
    'CORRECT_EVENT',
    p_target_effective_date,
    v_payload,
    p_request_id,
    p_initiator_uuid,
    v_before_snapshot,
    v_after_snapshot,
    v_pending_time,
    v_pending_time,
    v_pending_time
  );

  RETURN v_event_uuid;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_org_status_correction(
  p_tenant_uuid uuid,
  p_org_id int,
  p_target_effective_date date,
  p_target_status text,
  p_request_id text,
  p_initiator_uuid uuid
)
RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_target orgunit.org_events%ROWTYPE;
  v_existing_request orgunit.org_events%ROWTYPE;
  v_existing_rescind orgunit.org_events%ROWTYPE;
  v_target_status text;
  v_target_effective date;
  v_effective_payload jsonb;
  v_event_uuid uuid;
  v_payload jsonb;
  v_before_snapshot jsonb;
  v_after_snapshot jsonb;
  v_event_db_id bigint;
  v_pending_time timestamptz;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_target_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'target_effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  v_target_status := lower(btrim(COALESCE(p_target_status, '')));
  IF v_target_status IN ('enabled', '有效') THEN
    v_target_status := 'active';
  ELSIF v_target_status IN ('inactive', '无效') THEN
    v_target_status := 'disabled';
  END IF;
  IF v_target_status NOT IN ('active', 'disabled') THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'target_status invalid';
  END IF;

  v_lock_key := format('org:write-lock:%s', p_tenant_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT e.* INTO v_target
  FROM orgunit.org_events e
  JOIN orgunit.org_events_effective ee
    ON ee.event_uuid = e.event_uuid
   AND ee.tenant_uuid = e.tenant_uuid
   AND ee.org_id = e.org_id
  WHERE ee.tenant_uuid = p_tenant_uuid
    AND ee.org_id = p_org_id
    AND ee.effective_date = p_target_effective_date
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EVENT_NOT_FOUND',
      DETAIL = format('org_id=%s target_effective_date=%s', p_org_id, p_target_effective_date);
  END IF;

  IF v_target.event_type NOT IN ('ENABLE', 'DISABLE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_STATUS_CORRECTION_UNSUPPORTED_TARGET',
      DETAIL = format('event_type=%s', v_target.event_type);
  END IF;

  SELECT * INTO v_existing_rescind
  FROM orgunit.org_events r
  WHERE r.tenant_uuid = p_tenant_uuid
    AND r.event_type IN ('RESCIND_EVENT','RESCIND_ORG')
    AND r.payload->>'target_event_uuid' = v_target.event_uuid::text
  LIMIT 1;

  IF FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_EVENT_RESCINDED',
      DETAIL = format('event_uuid=%s', v_target.event_uuid);
  END IF;

  SELECT ee.effective_date, ee.payload
  INTO v_target_effective, v_effective_payload
  FROM orgunit.org_events_effective ee
  WHERE ee.tenant_uuid = p_tenant_uuid
    AND ee.org_id = p_org_id
    AND ee.event_uuid = v_target.event_uuid
  LIMIT 1;

  IF v_target_effective IS NULL THEN
    v_target_effective := v_target.effective_date;
    v_effective_payload := v_target.payload;
  END IF;

  v_payload := jsonb_build_object(
    'op', 'CORRECT_STATUS',
    'target_status', v_target_status,
    'target_event_uuid', v_target.event_uuid,
    'target_effective_date', p_target_effective_date
  );

  SELECT * INTO v_existing_request
  FROM orgunit.org_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = p_request_id
  LIMIT 1;

  IF FOUND THEN
    IF v_existing_request.event_type <> 'CORRECT_STATUS'
      OR v_existing_request.org_id <> p_org_id
      OR v_existing_request.payload <> v_payload
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
        DETAIL = format('request_id=%s', p_request_id);
    END IF;

    RETURN v_existing_request.event_uuid;
  END IF;

  v_before_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, p_target_effective_date);
  v_event_uuid := gen_random_uuid();
  v_pending_time := now();
  SELECT nextval(pg_get_serial_sequence('orgunit.org_events', 'id')) INTO v_event_db_id;

  PERFORM orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
    p_tenant_uuid,
    p_org_id,
    v_event_db_id,
    v_event_uuid,
    'CORRECT_STATUS',
    p_target_effective_date,
    v_payload,
    p_request_id,
    p_initiator_uuid,
    v_pending_time,
    v_pending_time,
    v_pending_time
  );

  v_after_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, p_org_id, p_target_effective_date);
  PERFORM orgunit.assert_org_event_snapshots('CORRECT_STATUS', v_before_snapshot, v_after_snapshot, NULL);

  INSERT INTO orgunit.org_events (
    id,
    tenant_uuid,
    org_id,
    event_uuid,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid,
    before_snapshot,
    after_snapshot,
    tx_time,
    transaction_time,
    created_at
  )
  VALUES (
    v_event_db_id,
    p_tenant_uuid,
    p_org_id,
    v_event_uuid,
    'CORRECT_STATUS',
    p_target_effective_date,
    v_payload,
    p_request_id,
    p_initiator_uuid,
    v_before_snapshot,
    v_after_snapshot,
    v_pending_time,
    v_pending_time,
    v_pending_time
  );

  RETURN v_event_uuid;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00003_orgunit_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00004_orgunit_read.sql
CREATE OR REPLACE FUNCTION orgunit.get_org_snapshot(p_tenant_uuid uuid, p_query_date date)
RETURNS TABLE (
  org_id int,
  parent_id int,
  name varchar(255),
  is_business_unit boolean,
  full_name_path text,
  depth int,
  manager_uuid uuid,
  node_path ltree
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  RETURN QUERY
  SELECT
    v.org_id,
    v.parent_id,
    v.name,
    v.is_business_unit,
    v.full_name_path,
    nlevel(v.node_path) - 1 AS depth,
    v.manager_uuid,
    v.node_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.status = 'active'
    AND v.validity @> p_query_date
  ORDER BY v.node_path;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00004_orgunit_read.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00005_orgunit_setid_schema.sql
CREATE TABLE IF NOT EXISTS orgunit.setid_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  event_type text NOT NULL,
  setid text NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_events_event_type_check CHECK (event_type IN ('BOOTSTRAP','CREATE','RENAME','DISABLE')),
  CONSTRAINT setid_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setid_events_share_forbidden CHECK (setid <> 'SHARE'),
  CONSTRAINT setid_events_request_id_unique UNIQUE (tenant_uuid, request_code)
);

CREATE UNIQUE INDEX IF NOT EXISTS setid_events_event_id_unique ON orgunit.setid_events (event_uuid);
CREATE INDEX IF NOT EXISTS setid_events_tenant_time_idx ON orgunit.setid_events (tenant_uuid, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.setids (
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, setid),
  CONSTRAINT setids_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setids_share_forbidden CHECK (setid <> 'SHARE'),
  CONSTRAINT setids_status_check CHECK (status IN ('active','disabled')),
  CONSTRAINT setids_deflt_active_check CHECK (setid <> 'DEFLT' OR status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.global_setid_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  event_type text NOT NULL,
  setid text NOT NULL DEFAULT 'SHARE',
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT global_setid_events_event_type_check CHECK (event_type IN ('BOOTSTRAP','CREATE','RENAME','DISABLE')),
  CONSTRAINT global_setid_events_setid_check CHECK (setid = 'SHARE'),
  CONSTRAINT global_setid_events_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_setid_events_request_id_unique UNIQUE (tenant_uuid, request_code)
);

CREATE UNIQUE INDEX IF NOT EXISTS global_setid_events_event_id_unique ON orgunit.global_setid_events (event_uuid);
CREATE INDEX IF NOT EXISTS global_setid_events_tenant_time_idx ON orgunit.global_setid_events (tenant_uuid, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.global_setids (
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  setid text NOT NULL DEFAULT 'SHARE',
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  last_event_id bigint NOT NULL REFERENCES orgunit.global_setid_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, setid),
  CONSTRAINT global_setids_share_only CHECK (setid = 'SHARE'),
  CONSTRAINT global_setids_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_setids_status_check CHECK (status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.setid_binding_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_binding_events_event_type_check CHECK (event_type IN ('BIND')),
  CONSTRAINT setid_binding_events_event_id_unique UNIQUE (event_uuid),
  CONSTRAINT setid_binding_events_request_id_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT setid_binding_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS setid_binding_events_tenant_effective_idx ON orgunit.setid_binding_events (tenant_uuid, org_id, effective_date, id);

CREATE TABLE IF NOT EXISTS orgunit.setid_binding_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  setid text NOT NULL,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_binding_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_binding_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setid_binding_setid_fk FOREIGN KEY (tenant_uuid, setid) REFERENCES orgunit.setids (tenant_uuid, setid),
  CONSTRAINT setid_binding_no_share CHECK (setid <> 'SHARE'),
  CONSTRAINT setid_binding_validity_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT setid_binding_no_overlap EXCLUDE USING gist (
    tenant_uuid WITH =,
    org_id gist_int4_ops WITH =,
    validity WITH &&
  )
);

ALTER TABLE orgunit.setid_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_events;
CREATE POLICY tenant_isolation ON orgunit.setid_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setids ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setids FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setids;
CREATE POLICY tenant_isolation ON orgunit.setids
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_binding_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_binding_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_binding_events;
CREATE POLICY tenant_isolation ON orgunit.setid_binding_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_binding_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_binding_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_binding_versions;
CREATE POLICY tenant_isolation ON orgunit.setid_binding_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.global_setid_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setid_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setid_events;
CREATE POLICY share_scope ON orgunit.global_setid_events
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

ALTER TABLE orgunit.global_setids ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setids FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setids;
CREATE POLICY share_scope ON orgunit.global_setids
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

-- end: modules/orgunit/infrastructure/persistence/schema/00005_orgunit_setid_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00006_orgunit_setid_engine.sql
CREATE OR REPLACE FUNCTION orgunit.normalize_setid(p_setid text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v text;
BEGIN
  IF p_setid IS NULL OR btrim(p_setid) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_FORMAT',
      DETAIL = 'setid is required';
  END IF;

  v := upper(btrim(p_setid));
  IF v !~ '^[A-Z0-9]{5}$' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_FORMAT',
      DETAIL = format('setid=%s', v);
  END IF;

  RETURN v;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.lock_setid_governance(p_tenant_uuid uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  k bigint;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  k := hashtextextended('orgunit.setid.governance:' || p_tenant_uuid::text, 0);
  PERFORM pg_advisory_xact_lock(k);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.assert_actor_scope_saas()
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_scope text;
BEGIN
  v_scope := current_setting('app.current_actor_scope', true);
  IF v_scope IS NULL OR btrim(v_scope) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ACTOR_SCOPE_FORBIDDEN',
      DETAIL = 'app.current_actor_scope is required';
  END IF;
  IF v_scope <> 'saas' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ACTOR_SCOPE_FORBIDDEN',
      DETAIL = format('app.current_actor_scope=%s', v_scope);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.ensure_setid_bootstrap(
  p_tenant_uuid uuid,
  p_initiator_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_evt_id uuid;
  v_evt_db_id bigint;
  v_root_org_id int;
  v_root_valid_from date;
  v_scope_code text;
  v_scope_share_mode text;
  v_package_id uuid;
  v_global_tenant_id uuid;
  v_prev_actor text;
  v_prev_allow_share text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  v_global_tenant_id := orgunit.global_tenant_id();
  v_prev_actor := current_setting('app.current_actor_scope', true);
  v_prev_allow_share := current_setting('app.allow_share_read', true);

  IF NOT EXISTS (
    SELECT 1 FROM orgunit.setids WHERE tenant_uuid = p_tenant_uuid AND setid = 'DEFLT'
  ) THEN
    v_evt_id := gen_random_uuid();
    INSERT INTO orgunit.setid_events (event_uuid, tenant_uuid, event_type, setid, payload, request_code, initiator_uuid)
    VALUES (v_evt_id, p_tenant_uuid, 'BOOTSTRAP', 'DEFLT', jsonb_build_object('name', 'Default'), 'bootstrap:deflt', p_initiator_uuid)
    ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

    SELECT id INTO v_evt_db_id
    FROM orgunit.setid_events
    WHERE tenant_uuid = p_tenant_uuid AND request_code = 'bootstrap:deflt'
    ORDER BY id DESC
    LIMIT 1;

    INSERT INTO orgunit.setids (tenant_uuid, setid, name, status, last_event_id)
    VALUES (p_tenant_uuid, 'DEFLT', 'Default', 'active', v_evt_db_id)
    ON CONFLICT (tenant_uuid, setid) DO NOTHING;
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid
  FOR UPDATE;

  IF v_root_org_id IS NULL THEN
    RETURN;
  END IF;

  SELECT lower(v.validity)::date INTO v_root_valid_from
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = v_root_org_id
    AND v.status = 'active'
    AND v.is_business_unit = true
    AND v.validity @> current_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_root_valid_from IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_NOT_BUSINESS_UNIT_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', v_root_org_id, current_date);
  END IF;

  FOR v_scope_code, v_scope_share_mode IN
    SELECT scope_code, share_mode
    FROM orgunit.scope_code_registry()
    WHERE is_stable = true
  LOOP
    IF v_scope_share_mode = 'shared-only' THEN
      PERFORM set_config('app.current_actor_scope', 'saas', true);
      PERFORM set_config('app.current_tenant', v_global_tenant_id::text, true);
      PERFORM set_config('app.allow_share_read', 'on', true);

      SELECT p.package_id INTO v_package_id
      FROM orgunit.global_setid_scope_packages p
      WHERE p.tenant_uuid = v_global_tenant_id
        AND p.scope_code = v_scope_code
        AND p.package_code = 'DEFLT';

      IF v_package_id IS NULL THEN
        v_package_id := gen_random_uuid();
        PERFORM orgunit.submit_global_scope_package_event(
          gen_random_uuid(),
          v_global_tenant_id,
          v_scope_code,
          v_package_id,
          'BOOTSTRAP',
          v_root_valid_from,
          jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
          format('bootstrap:global-scope-package:deflt:%s', v_scope_code),
          v_global_tenant_id
        );

        SELECT p.package_id INTO v_package_id
        FROM orgunit.global_setid_scope_packages p
        WHERE p.tenant_uuid = v_global_tenant_id
          AND p.scope_code = v_scope_code
          AND p.package_code = 'DEFLT';
      END IF;

      IF v_package_id IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'SUBSCRIPTION_DEFLT_MISSING',
          DETAIL = format('scope_code=%s', v_scope_code);
      END IF;

      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.global_setid_scope_package_versions v
        WHERE v.tenant_uuid = v_global_tenant_id
          AND v.scope_code = v_scope_code
          AND v.package_id = v_package_id
          AND v.status = 'active'
          AND v.validity @> v_root_valid_from
      ) THEN
        PERFORM orgunit.submit_global_scope_package_event(
          gen_random_uuid(),
          v_global_tenant_id,
          v_scope_code,
          v_package_id,
          'BOOTSTRAP',
          v_root_valid_from,
          jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
          format('bootstrap:global-scope-package:deflt:%s:%s', v_scope_code, v_root_valid_from),
          v_global_tenant_id
        );
      END IF;

      PERFORM set_config('app.current_tenant', p_tenant_uuid::text, true);
      PERFORM set_config('app.allow_share_read', COALESCE(v_prev_allow_share, 'off'), true);

      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.setid_scope_subscriptions s
        WHERE s.tenant_uuid = p_tenant_uuid
          AND s.setid = 'DEFLT'
          AND s.scope_code = v_scope_code
          AND s.validity @> v_root_valid_from
      ) THEN
        PERFORM orgunit.submit_scope_subscription_event(
          gen_random_uuid(),
          p_tenant_uuid,
          'DEFLT',
          v_scope_code,
          v_package_id,
          v_global_tenant_id,
          'BOOTSTRAP',
          v_root_valid_from,
          format('bootstrap:scope-subscription:deflt:%s', v_scope_code),
          p_initiator_uuid
        );
      END IF;

      CONTINUE;
    END IF;

    SELECT p.package_id INTO v_package_id
    FROM orgunit.setid_scope_packages p
    WHERE p.tenant_uuid = p_tenant_uuid
      AND p.scope_code = v_scope_code
      AND p.package_code = 'DEFLT';

    IF v_package_id IS NULL THEN
      v_package_id := gen_random_uuid();
      PERFORM orgunit.submit_scope_package_event(
        gen_random_uuid(),
        p_tenant_uuid,
        v_scope_code,
        v_package_id,
        'BOOTSTRAP',
        v_root_valid_from,
        jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
        format('bootstrap:scope-package:deflt:%s', v_scope_code),
        p_initiator_uuid
      );

      SELECT p.package_id INTO v_package_id
      FROM orgunit.setid_scope_packages p
      WHERE p.tenant_uuid = p_tenant_uuid
        AND p.scope_code = v_scope_code
        AND p.package_code = 'DEFLT';
    END IF;

    IF v_package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SUBSCRIPTION_DEFLT_MISSING',
        DETAIL = format('scope_code=%s', v_scope_code);
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_package_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.scope_code = v_scope_code
        AND v.package_id = v_package_id
        AND v.status = 'active'
        AND v.validity @> v_root_valid_from
    ) THEN
      PERFORM orgunit.submit_scope_package_event(
        gen_random_uuid(),
        p_tenant_uuid,
        v_scope_code,
        v_package_id,
        'BOOTSTRAP',
        v_root_valid_from,
        jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
        format('bootstrap:scope-package:deflt:%s:%s', v_scope_code, v_root_valid_from),
        p_initiator_uuid
      );
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_subscriptions s
      WHERE s.tenant_uuid = p_tenant_uuid
        AND s.setid = 'DEFLT'
        AND s.scope_code = v_scope_code
        AND s.validity @> v_root_valid_from
    ) THEN
      PERFORM orgunit.submit_scope_subscription_event(
        gen_random_uuid(),
        p_tenant_uuid,
        'DEFLT',
        v_scope_code,
        v_package_id,
        p_tenant_uuid,
        'BOOTSTRAP',
        v_root_valid_from,
        format('bootstrap:scope-subscription:deflt:%s', v_scope_code),
        p_initiator_uuid
      );
    END IF;
  END LOOP;

  PERFORM set_config('app.current_tenant', p_tenant_uuid::text, true);
  PERFORM set_config('app.current_actor_scope', COALESCE(v_prev_actor, ''), true);
  PERFORM set_config('app.allow_share_read', COALESCE(v_prev_allow_share, 'off'), true);

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.setid_binding_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND org_id = v_root_org_id
      AND validity @> v_root_valid_from
  ) THEN
    PERFORM orgunit.submit_setid_binding_event(
      gen_random_uuid(),
      p_tenant_uuid,
      v_root_org_id,
      v_root_valid_from,
      'DEFLT',
      'bootstrap:binding:deflt',
      p_initiator_uuid
    );
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_setid_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_event_type text,
  p_setid text,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_name text;
  v_scope_code text;
  v_scope_share_mode text;
  v_package_id uuid;
  v_effective_date date;
  v_global_tenant_id uuid;
  v_prev_actor text;
  v_prev_allow_share text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  v_global_tenant_id := orgunit.global_tenant_id();
  v_prev_actor := current_setting('app.current_actor_scope', true);
  v_prev_allow_share := current_setting('app.allow_share_read', true);

  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'event_type is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'SHARE is reserved';
  END IF;

  INSERT INTO orgunit.setid_events (event_uuid, tenant_uuid, event_type, setid, payload, request_code, initiator_uuid)
  VALUES (p_event_uuid, p_tenant_uuid, p_event_type, v_setid, COALESCE(p_payload, '{}'::jsonb), p_request_code, p_initiator_uuid)
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF p_event_type IN ('BOOTSTRAP','CREATE') THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    IF p_event_type = 'CREATE' AND EXISTS (
      SELECT 1 FROM orgunit.setids WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_ALREADY_EXISTS',
        DETAIL = format('setid=%s', v_setid);
    END IF;

    INSERT INTO orgunit.setids (tenant_uuid, setid, name, status, last_event_id)
    VALUES (p_tenant_uuid, v_setid, v_name, 'active', v_evt_db_id)
    ON CONFLICT (tenant_uuid, setid) DO UPDATE
    SET name = EXCLUDED.name,
        status = 'active',
        last_event_id = EXCLUDED.last_event_id,
        updated_at = now();

    v_effective_date := current_date;
    IF p_payload ? 'effective_date' THEN
      v_effective_date := NULLIF(btrim(p_payload->>'effective_date'), '')::date;
    END IF;
    IF v_effective_date IS NULL THEN
      v_effective_date := current_date;
    END IF;

    FOR v_scope_code, v_scope_share_mode IN
      SELECT scope_code, share_mode
      FROM orgunit.scope_code_registry()
      WHERE is_stable = true
    LOOP
      IF v_scope_share_mode = 'shared-only' THEN
        PERFORM set_config('app.current_actor_scope', 'saas', true);
        PERFORM set_config('app.current_tenant', v_global_tenant_id::text, true);
        PERFORM set_config('app.allow_share_read', 'on', true);

        SELECT p.package_id INTO v_package_id
        FROM orgunit.global_setid_scope_packages p
        WHERE p.tenant_uuid = v_global_tenant_id
          AND p.scope_code = v_scope_code
          AND p.package_code = 'DEFLT';

        IF v_package_id IS NULL THEN
          v_package_id := gen_random_uuid();
          PERFORM orgunit.submit_global_scope_package_event(
            gen_random_uuid(),
            v_global_tenant_id,
            v_scope_code,
            v_package_id,
            'BOOTSTRAP',
            v_effective_date,
            jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
            format('bootstrap:global-scope-package:deflt:%s', v_scope_code),
            v_global_tenant_id
          );

          SELECT p.package_id INTO v_package_id
          FROM orgunit.global_setid_scope_packages p
          WHERE p.tenant_uuid = v_global_tenant_id
            AND p.scope_code = v_scope_code
            AND p.package_code = 'DEFLT';
        END IF;

        IF v_package_id IS NULL THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'SUBSCRIPTION_DEFLT_MISSING',
            DETAIL = format('setid=%s scope_code=%s', v_setid, v_scope_code);
        END IF;

        PERFORM set_config('app.current_tenant', p_tenant_uuid::text, true);
        PERFORM set_config('app.allow_share_read', COALESCE(v_prev_allow_share, 'off'), true);

        IF NOT EXISTS (
          SELECT 1
          FROM orgunit.setid_scope_subscriptions s
          WHERE s.tenant_uuid = p_tenant_uuid
            AND s.setid = v_setid
            AND s.scope_code = v_scope_code
            AND s.validity @> v_effective_date
        ) THEN
          PERFORM orgunit.submit_scope_subscription_event(
            gen_random_uuid(),
            p_tenant_uuid,
            v_setid,
            v_scope_code,
            v_package_id,
            v_global_tenant_id,
            'BOOTSTRAP',
            v_effective_date,
            format('bootstrap:scope-subscription:%s:%s', v_setid, v_scope_code),
            p_initiator_uuid
          );
        END IF;

        CONTINUE;
      END IF;

      SELECT p.package_id INTO v_package_id
      FROM orgunit.setid_scope_packages p
      WHERE p.tenant_uuid = p_tenant_uuid
        AND p.scope_code = v_scope_code
        AND p.package_code = 'DEFLT';

      IF v_package_id IS NULL THEN
        v_package_id := gen_random_uuid();
        PERFORM orgunit.submit_scope_package_event(
          gen_random_uuid(),
          p_tenant_uuid,
          v_scope_code,
          v_package_id,
          'BOOTSTRAP',
          v_effective_date,
          jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
          format('bootstrap:scope-package:deflt:%s', v_scope_code),
          p_initiator_uuid
        );

        SELECT p.package_id INTO v_package_id
        FROM orgunit.setid_scope_packages p
        WHERE p.tenant_uuid = p_tenant_uuid
          AND p.scope_code = v_scope_code
          AND p.package_code = 'DEFLT';
      END IF;

      IF v_package_id IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'SUBSCRIPTION_DEFLT_MISSING',
          DETAIL = format('setid=%s scope_code=%s', v_setid, v_scope_code);
      END IF;

      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.setid_scope_subscriptions s
        WHERE s.tenant_uuid = p_tenant_uuid
          AND s.setid = v_setid
          AND s.scope_code = v_scope_code
          AND s.validity @> current_date
      ) THEN
        PERFORM orgunit.submit_scope_subscription_event(
          gen_random_uuid(),
          p_tenant_uuid,
          v_setid,
          v_scope_code,
          v_package_id,
          p_tenant_uuid,
          'BOOTSTRAP',
          v_effective_date,
          format('bootstrap:scope-subscription:%s:%s', v_setid, v_scope_code),
          p_initiator_uuid
        );
      END IF;
    END LOOP;

    PERFORM set_config('app.current_tenant', p_tenant_uuid::text, true);
    PERFORM set_config('app.current_actor_scope', COALESCE(v_prev_actor, ''), true);
    PERFORM set_config('app.allow_share_read', COALESCE(v_prev_allow_share, 'off'), true);
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;
    UPDATE orgunit.setids
    SET name = v_name,
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
  ELSIF p_event_type = 'DISABLE' THEN
    IF v_setid = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_RESERVED_WORD',
        DETAIL = 'DEFLT is reserved';
    END IF;
    IF EXISTS (
      SELECT 1 FROM orgunit.setid_binding_versions
      WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_IN_USE',
        DETAIL = format('setid=%s', v_setid);
    END IF;
    UPDATE orgunit.setids
    SET status = 'disabled',
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_global_setid_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_event_type text,
  p_setid text,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_name text;
BEGIN
  IF p_tenant_uuid <> orgunit.global_tenant_id() THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ACTOR_SCOPE_FORBIDDEN',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;

  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.assert_actor_scope_saas();

  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'event_type is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid <> 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'only SHARE is allowed';
  END IF;

  INSERT INTO orgunit.global_setid_events (event_uuid, tenant_uuid, event_type, setid, payload, request_code, initiator_uuid)
  VALUES (p_event_uuid, p_tenant_uuid, p_event_type, v_setid, COALESCE(p_payload, '{}'::jsonb), p_request_code, p_initiator_uuid)
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.global_setid_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF p_event_type IN ('BOOTSTRAP','CREATE') THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    INSERT INTO orgunit.global_setids (tenant_uuid, setid, name, status, last_event_id)
    VALUES (p_tenant_uuid, v_setid, v_name, 'active', v_evt_db_id)
    ON CONFLICT (tenant_uuid, setid) DO UPDATE
    SET name = EXCLUDED.name,
        status = 'active',
        last_event_id = EXCLUDED.last_event_id,
        updated_at = now();
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;
    UPDATE orgunit.global_setids
    SET name = v_name,
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
  ELSIF p_event_type = 'DISABLE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'SHARE cannot be disabled';
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_setid_binding_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_org_id int,
  p_effective_date date,
  p_setid text,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_org_status text;
  v_org_is_bu boolean;
  v_existing orgunit.setid_binding_versions%ROWTYPE;
  v_next_start date;
  v_current_end date;
  v_root_org_id int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_SHARE_FORBIDDEN',
      DETAIL = 'SHARE is reserved';
  END IF;

  SELECT status INTO v_org_status
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_org_id
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_org_status IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;
  IF v_org_status <> 'active' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INACTIVE_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  SELECT is_business_unit INTO v_org_is_bu
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_org_id
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_org_is_bu IS DISTINCT FROM true THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_NOT_BUSINESS_UNIT_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM orgunit.setids WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_NOT_FOUND',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  IF EXISTS (
    SELECT 1 FROM orgunit.setids WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid AND status <> 'active'
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_DISABLED',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid;

  IF v_root_org_id IS NOT NULL AND v_root_org_id = p_org_id AND v_setid <> 'DEFLT' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_ROOT_BINDING_FORBIDDEN',
      DETAIL = format('org_id=%s setid=%s', p_org_id, v_setid);
  END IF;

  INSERT INTO orgunit.setid_binding_events (
    event_uuid,
    tenant_uuid,
    org_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_org_id,
    'BIND',
    p_effective_date,
    jsonb_build_object('setid', v_setid),
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_binding_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  SELECT min(lower(validity)) INTO v_next_start
  FROM orgunit.setid_binding_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND lower(validity) > p_effective_date;

  SELECT * INTO v_existing
  FROM orgunit.setid_binding_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND validity @> p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  BEGIN
    IF FOUND THEN
      v_current_end := upper(v_existing.validity);
      IF lower(v_existing.validity) = p_effective_date THEN
        UPDATE orgunit.setid_binding_versions
        SET setid = v_setid,
            last_event_id = v_evt_db_id,
            updated_at = now()
        WHERE id = v_existing.id;
      ELSE
        UPDATE orgunit.setid_binding_versions
        SET validity = daterange(lower(v_existing.validity), p_effective_date, '[)'),
            updated_at = now()
        WHERE id = v_existing.id;

        INSERT INTO orgunit.setid_binding_versions (
          tenant_uuid,
          org_id,
          setid,
          validity,
          last_event_id
        )
        VALUES (
          p_tenant_uuid,
          p_org_id,
          v_setid,
          daterange(p_effective_date, v_current_end, '[)'),
          v_evt_db_id
        );
      END IF;
    ELSE
      INSERT INTO orgunit.setid_binding_versions (
        tenant_uuid,
        org_id,
        setid,
        validity,
        last_event_id
      )
      VALUES (
        p_tenant_uuid,
        p_org_id,
        v_setid,
        daterange(p_effective_date, v_next_start, '[)'),
        v_evt_db_id
      );
    END IF;
  EXCEPTION
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_BINDING_OVERLAP',
        DETAIL = format('org_id=%s effective_date=%s', p_org_id, p_effective_date);
  END;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.resolve_setid(
  p_tenant_uuid uuid,
  p_org_id int,
  p_as_of_date date
)
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
  v_node_path ltree;
  v_org_status text;
  v_setid text;
  v_setid_status text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'org_id is required';
  END IF;
  IF p_as_of_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'as_of_date is required';
  END IF;

  SELECT v.status, v.node_path INTO v_org_status, v_node_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.org_id = p_org_id
    AND v.validity @> p_as_of_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_org_status IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_as_of_date);
  END IF;
  IF v_org_status <> 'active' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INACTIVE_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_as_of_date);
  END IF;

  SELECT b.setid INTO v_setid
  FROM orgunit.setid_binding_versions b
  JOIN orgunit.org_unit_versions o
    ON o.tenant_uuid = b.tenant_uuid
   AND o.org_id = b.org_id
  WHERE b.tenant_uuid = p_tenant_uuid
    AND b.validity @> p_as_of_date
    AND o.validity @> p_as_of_date
    AND o.status = 'active'
    AND o.is_business_unit = true
    AND o.node_path @> v_node_path
  ORDER BY nlevel(o.node_path) DESC
  LIMIT 1;

  IF v_setid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_BINDING_MISSING',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_as_of_date);
  END IF;

  SELECT status INTO v_setid_status
  FROM orgunit.setids
  WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;

  IF v_setid_status IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_NOT_FOUND',
      DETAIL = format('setid=%s', v_setid);
  END IF;
  IF v_setid_status <> 'active' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_DISABLED',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  RETURN v_setid;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00006_orgunit_setid_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00007_orgunit_setid_kernel_privileges.sql
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'orgunit_kernel') THEN
    CREATE ROLE orgunit_kernel NOLOGIN NOBYPASSRLS;
  END IF;
END $$;

GRANT USAGE ON SCHEMA orgunit TO orgunit_kernel;

GRANT SELECT, INSERT, UPDATE ON TABLE
  orgunit.setid_events,
  orgunit.setids,
  orgunit.setid_binding_events,
  orgunit.setid_binding_versions,
  orgunit.global_setid_events,
  orgunit.global_setids,
  orgunit.org_unit_versions,
  orgunit.org_trees
TO orgunit_kernel;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA orgunit TO orgunit_kernel;

ALTER FUNCTION orgunit.submit_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.submit_global_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_global_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_global_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.submit_setid_binding_event(uuid, uuid, int, date, text, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_setid_binding_event(uuid, uuid, int, date, text, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_setid_binding_event(uuid, uuid, int, date, text, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.ensure_setid_bootstrap(uuid, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.ensure_setid_bootstrap(uuid, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.ensure_setid_bootstrap(uuid, uuid)
  SET search_path = pg_catalog, orgunit;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_events, ' ||
      'orgunit.setids, ' ||
      'orgunit.setid_binding_events, ' ||
      'orgunit.setid_binding_versions, ' ||
      'orgunit.global_setid_events, ' ||
      'orgunit.global_setids ' ||
      'FROM app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_nobypassrls') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_events, ' ||
      'orgunit.setids, ' ||
      'orgunit.setid_binding_events, ' ||
      'orgunit.setid_binding_versions, ' ||
      'orgunit.global_setid_events, ' ||
      'orgunit.global_setids ' ||
      'FROM app_nobypassrls';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_events, ' ||
      'orgunit.setids, ' ||
      'orgunit.setid_binding_events, ' ||
      'orgunit.setid_binding_versions, ' ||
      'orgunit.global_setid_events, ' ||
      'orgunit.global_setids ' ||
      'FROM superadmin_runtime';
  END IF;
END $$;

-- end: modules/orgunit/infrastructure/persistence/schema/00007_orgunit_setid_kernel_privileges.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00008_orgunit_setid_scope_schema.sql
CREATE OR REPLACE FUNCTION orgunit.scope_code_registry()
RETURNS TABLE(scope_code text, owner_module text, share_mode text, is_stable boolean) AS $$
  VALUES
    ('jobcatalog', 'jobcatalog', 'tenant-only', true),
    ('orgunit_geo_admin', 'orgunit', 'shared-only', true),
    ('orgunit_location', 'orgunit', 'shared-only', true),
    ('person_school', 'person', 'shared-only', true),
    ('person_education_type', 'person', 'shared-only', true),
    ('person_credential_type', 'person', 'shared-only', true)
$$ LANGUAGE SQL IMMUTABLE;

CREATE OR REPLACE FUNCTION orgunit.scope_code_is_valid(p_scope_code text)
RETURNS boolean AS $$
  SELECT EXISTS (
    SELECT 1 FROM orgunit.scope_code_registry() WHERE scope_code = p_scope_code
  );
$$ LANGUAGE SQL IMMUTABLE;

CREATE OR REPLACE FUNCTION orgunit.scope_code_share_mode(p_scope_code text)
RETURNS text AS $$
  SELECT share_mode FROM orgunit.scope_code_registry() WHERE scope_code = p_scope_code
$$ LANGUAGE SQL IMMUTABLE;

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_packages (
  tenant_uuid uuid NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_code text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_scope_packages_pk PRIMARY KEY (tenant_uuid, package_id),
  CONSTRAINT setid_scope_packages_code_unique UNIQUE (tenant_uuid, scope_code, package_code),
  CONSTRAINT setid_scope_packages_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_packages_code_check CHECK (package_code ~ '^[A-Z0-9_]{1,16}$'),
  CONSTRAINT setid_scope_packages_status_check CHECK (status IN ('active', 'disabled')),
  CONSTRAINT setid_scope_packages_deflt_active_check CHECK (package_code <> 'DEFLT' OR status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.global_setid_scope_packages (
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_code text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT global_scope_packages_pk PRIMARY KEY (tenant_uuid, package_id),
  CONSTRAINT global_scope_packages_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_scope_packages_code_unique UNIQUE (tenant_uuid, scope_code, package_code),
  CONSTRAINT global_scope_packages_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT global_scope_packages_code_check CHECK (package_code ~ '^[A-Z0-9_]{1,16}$'),
  CONSTRAINT global_scope_packages_status_check CHECK (status IN ('active', 'disabled')),
  CONSTRAINT global_scope_packages_deflt_active_check CHECK (package_code <> 'DEFLT' OR status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_package_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_scope_package_events_event_id_unique UNIQUE (event_uuid),
  CONSTRAINT setid_scope_package_events_request_id_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT setid_scope_package_events_event_type_check CHECK (event_type IN ('BOOTSTRAP', 'CREATE', 'RENAME', 'DISABLE')),
  CONSTRAINT setid_scope_package_events_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_package_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS setid_scope_package_events_tenant_time_idx
  ON orgunit.setid_scope_package_events (tenant_uuid, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.global_setid_scope_package_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT global_scope_package_events_event_id_unique UNIQUE (event_uuid),
  CONSTRAINT global_scope_package_events_request_id_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT global_scope_package_events_event_type_check CHECK (event_type IN ('BOOTSTRAP', 'CREATE', 'RENAME', 'DISABLE')),
  CONSTRAINT global_scope_package_events_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_scope_package_events_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT global_scope_package_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS global_scope_package_events_tenant_time_idx
  ON orgunit.global_setid_scope_package_events (tenant_uuid, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_package_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_code text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_scope_package_events(id),
  CONSTRAINT setid_scope_package_versions_pkg_fk FOREIGN KEY (tenant_uuid, package_id)
    REFERENCES orgunit.setid_scope_packages (tenant_uuid, package_id),
  CONSTRAINT setid_scope_package_versions_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_package_versions_code_check CHECK (package_code ~ '^[A-Z0-9_]{1,16}$'),
  CONSTRAINT setid_scope_package_versions_status_check CHECK (status IN ('active', 'disabled')),
  CONSTRAINT setid_scope_package_versions_deflt_active_check CHECK (package_code <> 'DEFLT' OR status = 'active'),
  CONSTRAINT setid_scope_package_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT setid_scope_package_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT setid_scope_package_versions_no_overlap EXCLUDE USING gist (
    tenant_uuid WITH =,
    package_id WITH =,
    validity WITH &&
  )
);

CREATE INDEX IF NOT EXISTS setid_scope_package_versions_lookup_idx
  ON orgunit.setid_scope_package_versions (tenant_uuid, package_id, lower(validity));

CREATE TABLE IF NOT EXISTS orgunit.global_setid_scope_package_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_code text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.global_setid_scope_package_events(id),
  CONSTRAINT global_scope_package_versions_pkg_fk FOREIGN KEY (tenant_uuid, package_id)
    REFERENCES orgunit.global_setid_scope_packages (tenant_uuid, package_id),
  CONSTRAINT global_scope_package_versions_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_scope_package_versions_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT global_scope_package_versions_code_check CHECK (package_code ~ '^[A-Z0-9_]{1,16}$'),
  CONSTRAINT global_scope_package_versions_status_check CHECK (status IN ('active', 'disabled')),
  CONSTRAINT global_scope_package_versions_deflt_active_check CHECK (package_code <> 'DEFLT' OR status = 'active'),
  CONSTRAINT global_scope_package_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT global_scope_package_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT global_scope_package_versions_no_overlap EXCLUDE USING gist (
    tenant_uuid WITH =,
    package_id WITH =,
    validity WITH &&
  )
);

CREATE INDEX IF NOT EXISTS global_scope_package_versions_lookup_idx
  ON orgunit.global_setid_scope_package_versions (tenant_uuid, package_id, lower(validity));

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_subscription_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_owner_tenant_uuid uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_scope_subscription_events_event_id_unique UNIQUE (event_uuid),
  CONSTRAINT setid_scope_subscription_events_request_id_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT setid_scope_subscription_events_event_type_check CHECK (event_type IN ('BOOTSTRAP', 'SUBSCRIBE')),
  CONSTRAINT setid_scope_subscription_events_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_subscription_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setid_scope_subscription_events_owner_check CHECK (
    package_owner_tenant_uuid = tenant_uuid OR package_owner_tenant_uuid = orgunit.global_tenant_id()
  ),
  CONSTRAINT setid_scope_subscription_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS setid_scope_subscription_events_tenant_idx
  ON orgunit.setid_scope_subscription_events (tenant_uuid, setid, scope_code, effective_date, id);

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_subscriptions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_owner_tenant_uuid uuid NOT NULL,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_scope_subscription_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_scope_subscriptions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setid_scope_subscriptions_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_subscriptions_setid_fk FOREIGN KEY (tenant_uuid, setid) REFERENCES orgunit.setids (tenant_uuid, setid),
  CONSTRAINT setid_scope_subscriptions_validity_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT setid_scope_subscriptions_owner_check CHECK (
    package_owner_tenant_uuid = tenant_uuid OR package_owner_tenant_uuid = orgunit.global_tenant_id()
  ),
  CONSTRAINT setid_scope_subscriptions_no_overlap EXCLUDE USING gist (
    tenant_uuid WITH =,
    setid WITH =,
    scope_code WITH =,
    validity WITH &&
  )
);

CREATE INDEX IF NOT EXISTS setid_scope_subscriptions_lookup_idx
  ON orgunit.setid_scope_subscriptions (tenant_uuid, setid, scope_code, lower(validity));

ALTER TABLE orgunit.setid_scope_packages ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_packages FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_packages;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_packages
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_scope_package_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_package_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_package_events;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_package_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_scope_package_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_package_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_package_versions;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_package_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_scope_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_subscriptions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_subscriptions;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_subscriptions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_scope_subscription_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_subscription_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_subscription_events;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_subscription_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.global_setid_scope_packages ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setid_scope_packages FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setid_scope_packages;
CREATE POLICY share_scope ON orgunit.global_setid_scope_packages
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

ALTER TABLE orgunit.global_setid_scope_package_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setid_scope_package_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setid_scope_package_events;
CREATE POLICY share_scope ON orgunit.global_setid_scope_package_events
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

ALTER TABLE orgunit.global_setid_scope_package_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setid_scope_package_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setid_scope_package_versions;
CREATE POLICY share_scope ON orgunit.global_setid_scope_package_versions
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

-- end: modules/orgunit/infrastructure/persistence/schema/00008_orgunit_setid_scope_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00009_orgunit_setid_scope_engine.sql
CREATE OR REPLACE FUNCTION orgunit.assert_scope_package_active_as_of(
  p_tenant_uuid uuid,
  p_scope_code text,
  p_package_id uuid,
  p_package_owner_tenant_uuid uuid,
  p_as_of_date date
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_scope_mode text;
  v_ctx_tenant text;
  v_allow_share text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_NOT_FOUND';
  END IF;
  IF p_as_of_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'as_of_date is required';
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  v_ctx_tenant := current_setting('app.current_tenant');
  v_allow_share := current_setting('app.allow_share_read', true);

  IF p_package_owner_tenant_uuid = p_tenant_uuid THEN
    IF v_scope_mode = 'shared-only' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
    END IF;
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_packages p
      WHERE p.tenant_uuid = p_tenant_uuid
        AND p.scope_code = p_scope_code
        AND p.package_id = p_package_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_package_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.scope_code = p_scope_code
        AND v.package_id = p_package_id
        AND v.validity @> p_as_of_date
        AND v.status = 'active'
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_INACTIVE_AS_OF';
    END IF;
  ELSIF p_package_owner_tenant_uuid = orgunit.global_tenant_id() THEN
    IF v_scope_mode = 'tenant-only' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
    END IF;
    PERFORM set_config('app.current_tenant', orgunit.global_tenant_id()::text, true);
    PERFORM set_config('app.allow_share_read', 'on', true);
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.global_setid_scope_packages p
      WHERE p.tenant_uuid = orgunit.global_tenant_id()
        AND p.scope_code = p_scope_code
        AND p.package_id = p_package_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.global_setid_scope_package_versions v
      WHERE v.tenant_uuid = orgunit.global_tenant_id()
        AND v.scope_code = p_scope_code
        AND v.package_id = p_package_id
        AND v.validity @> p_as_of_date
        AND v.status = 'active'
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_INACTIVE_AS_OF';
    END IF;
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_OWNER_INVALID';
  END IF;

  PERFORM set_config('app.current_tenant', v_ctx_tenant, true);
  PERFORM set_config('app.allow_share_read', COALESCE(v_allow_share, 'off'), true);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.resolve_scope_package(
  p_tenant_uuid uuid,
  p_setid text,
  p_scope_code text,
  p_as_of_date date
)
RETURNS TABLE(package_id uuid, package_owner_tenant_uuid uuid)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_setid text;
  v_scope_mode text;
  v_ctx_tenant text;
  v_allow_share text;
  v_package_id uuid;
  v_package_owner_tenant_uuid uuid;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_setid IS NULL OR btrim(p_setid) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'setid is required';
  END IF;
  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_as_of_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'as_of_date is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'SHARE is reserved';
  END IF;

  SELECT s.package_id, s.package_owner_tenant_uuid
  INTO v_package_id, v_package_owner_tenant_uuid
  FROM orgunit.setid_scope_subscriptions s
  WHERE s.tenant_uuid = p_tenant_uuid
    AND s.setid = v_setid
    AND s.scope_code = p_scope_code
    AND s.validity @> p_as_of_date
  ORDER BY lower(s.validity) DESC
  LIMIT 1;

  IF v_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_MISSING',
      DETAIL = format('setid=%s scope_code=%s as_of=%s', v_setid, p_scope_code, p_as_of_date);
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  v_ctx_tenant := current_setting('app.current_tenant');
  v_allow_share := current_setting('app.allow_share_read', true);

  IF v_package_owner_tenant_uuid = p_tenant_uuid THEN
    IF v_scope_mode = 'shared-only' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
    END IF;
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_package_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.scope_code = p_scope_code
        AND v.package_id = v_package_id
        AND v.validity @> p_as_of_date
        AND v.status = 'active'
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_INACTIVE_AS_OF';
    END IF;
  ELSIF v_package_owner_tenant_uuid = orgunit.global_tenant_id() THEN
    IF v_scope_mode = 'tenant-only' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
    END IF;
    PERFORM set_config('app.current_tenant', orgunit.global_tenant_id()::text, true);
    PERFORM set_config('app.allow_share_read', 'on', true);
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.global_setid_scope_package_versions v
      WHERE v.tenant_uuid = orgunit.global_tenant_id()
        AND v.scope_code = p_scope_code
        AND v.package_id = v_package_id
        AND v.validity @> p_as_of_date
        AND v.status = 'active'
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_INACTIVE_AS_OF';
    END IF;
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_OWNER_INVALID';
  END IF;

  PERFORM set_config('app.current_tenant', v_ctx_tenant, true);
  PERFORM set_config('app.allow_share_read', COALESCE(v_allow_share, 'off'), true);

  package_id := v_package_id;
  package_owner_tenant_uuid := v_package_owner_tenant_uuid;
  RETURN NEXT;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00009_orgunit_setid_scope_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00010_orgunit_setid_scope_kernel_privileges.sql
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'orgunit_kernel') THEN
    CREATE ROLE orgunit_kernel NOLOGIN NOBYPASSRLS;
  END IF;
END $$;

GRANT USAGE ON SCHEMA orgunit TO orgunit_kernel;

GRANT SELECT, INSERT, UPDATE ON TABLE
  orgunit.setid_scope_packages,
  orgunit.setid_scope_package_events,
  orgunit.setid_scope_package_versions,
  orgunit.setid_scope_subscriptions,
  orgunit.setid_scope_subscription_events,
  orgunit.global_setid_scope_packages,
  orgunit.global_setid_scope_package_events,
  orgunit.global_setid_scope_package_versions
TO orgunit_kernel;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA orgunit TO orgunit_kernel;

ALTER FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.resolve_scope_package(uuid, text, text, date)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.resolve_scope_package(uuid, text, text, date)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.resolve_scope_package(uuid, text, text, date)
  SET search_path = pg_catalog, orgunit;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_scope_packages, ' ||
      'orgunit.setid_scope_package_events, ' ||
      'orgunit.setid_scope_package_versions, ' ||
      'orgunit.setid_scope_subscriptions, ' ||
      'orgunit.setid_scope_subscription_events, ' ||
      'orgunit.global_setid_scope_packages, ' ||
      'orgunit.global_setid_scope_package_events, ' ||
      'orgunit.global_setid_scope_package_versions ' ||
      'FROM app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_nobypassrls') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_scope_packages, ' ||
      'orgunit.setid_scope_package_events, ' ||
      'orgunit.setid_scope_package_versions, ' ||
      'orgunit.setid_scope_subscriptions, ' ||
      'orgunit.setid_scope_subscription_events, ' ||
      'orgunit.global_setid_scope_packages, ' ||
      'orgunit.global_setid_scope_package_events, ' ||
      'orgunit.global_setid_scope_package_versions ' ||
      'FROM app_nobypassrls';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_scope_packages, ' ||
      'orgunit.setid_scope_package_events, ' ||
      'orgunit.setid_scope_package_versions, ' ||
      'orgunit.setid_scope_subscriptions, ' ||
      'orgunit.setid_scope_subscription_events, ' ||
      'orgunit.global_setid_scope_packages, ' ||
      'orgunit.global_setid_scope_package_events, ' ||
      'orgunit.global_setid_scope_package_versions ' ||
      'FROM superadmin_runtime';
  END IF;
END $$;

REVOKE ALL ON TABLE orgunit.global_setid_scope_packages FROM PUBLIC;
REVOKE ALL ON TABLE orgunit.global_setid_scope_package_versions FROM PUBLIC;
REVOKE ALL ON TABLE orgunit.global_setid_scope_package_events FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE ALL ON TABLE orgunit.global_setid_scope_packages FROM app_runtime';
    EXECUTE 'REVOKE ALL ON TABLE orgunit.global_setid_scope_package_versions FROM app_runtime';
    EXECUTE 'REVOKE ALL ON TABLE orgunit.global_setid_scope_package_events FROM app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT SELECT ON TABLE orgunit.global_setid_scope_packages TO superadmin_runtime';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.global_setid_scope_package_versions TO superadmin_runtime';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.global_setid_scope_package_events TO superadmin_runtime';
  END IF;
END $$;

REVOKE EXECUTE ON FUNCTION orgunit.resolve_scope_package(uuid, text, text, date) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date) FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.resolve_scope_package(uuid, text, text, date) TO app_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date) TO app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.resolve_scope_package(uuid, text, text, date) TO superadmin_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date) TO superadmin_runtime';
  END IF;
END $$;

-- end: modules/orgunit/infrastructure/persistence/schema/00010_orgunit_setid_scope_kernel_privileges.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00011_orgunit_setid_scope_write_engine.sql
CREATE OR REPLACE FUNCTION orgunit.submit_scope_package_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_scope_code text,
  p_package_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_evt_db_id bigint;
  v_payload jsonb;
  v_scope_mode text;
  v_package_code text;
  v_owner_setid text;
  v_name text;
  v_status text;
  v_owner_status text;
  v_existing_pkg orgunit.setid_scope_packages%ROWTYPE;
  v_existing_version orgunit.setid_scope_package_versions%ROWTYPE;
  v_next_start date;
  v_current_end date;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'REQUEST_CODE_REQUIRED';
  END IF;
  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_NOT_FOUND';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('BOOTSTRAP', 'CREATE', 'RENAME', 'DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  IF v_scope_mode = 'shared-only' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  INSERT INTO orgunit.setid_scope_package_events (
    event_uuid,
    tenant_uuid,
    scope_code,
    package_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_scope_code,
    p_package_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_scope_package_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF EXISTS (
    SELECT 1
    FROM orgunit.setid_scope_package_versions
    WHERE last_event_id = v_evt_db_id
  ) THEN
    RETURN v_evt_db_id;
  END IF;

  IF p_event_type IN ('BOOTSTRAP', 'CREATE') THEN
    v_package_code := upper(btrim(COALESCE(v_payload->>'package_code', '')));
    v_owner_setid := NULLIF(btrim(COALESCE(v_payload->>'owner_setid', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');

    IF v_package_code = '' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_INVALID';
    END IF;
    IF v_package_code !~ '^[A-Z0-9_]{1,16}$' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_INVALID';
    END IF;
    IF p_event_type = 'CREATE' AND v_package_code = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_RESERVED';
    END IF;
    IF v_owner_setid IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'owner_setid is required';
    END IF;
    v_owner_setid := orgunit.normalize_setid(v_owner_setid);
    IF v_owner_setid = 'SHARE' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_RESERVED_WORD',
        DETAIL = 'SHARE is reserved';
    END IF;
    SELECT status INTO v_owner_status
    FROM orgunit.setids
    WHERE tenant_uuid = p_tenant_uuid AND setid = v_owner_setid;
    IF v_owner_status IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_owner_setid);
    END IF;
    IF v_owner_status <> 'active' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_DISABLED',
        DETAIL = format('setid=%s', v_owner_setid);
    END IF;
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    IF EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_packages
      WHERE tenant_uuid = p_tenant_uuid
        AND scope_code = p_scope_code
        AND package_code = v_package_code
        AND package_id <> p_package_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_DUPLICATE';
    END IF;

    v_status := 'active';

    INSERT INTO orgunit.setid_scope_packages (
      tenant_uuid,
      scope_code,
      package_id,
      package_code,
      owner_setid,
      name,
      status
    )
    VALUES (
      p_tenant_uuid,
      p_scope_code,
      p_package_id,
      v_package_code,
      v_owner_setid,
      v_name,
      v_status
    )
    ON CONFLICT (tenant_uuid, package_id) DO UPDATE
    SET scope_code = EXCLUDED.scope_code,
        package_code = EXCLUDED.package_code,
        owner_setid = EXCLUDED.owner_setid,
        name = EXCLUDED.name,
        status = EXCLUDED.status,
        updated_at = now();
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    SELECT * INTO v_existing_pkg
    FROM orgunit.setid_scope_packages
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id
    FOR UPDATE;

    IF v_existing_pkg.package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;

    v_package_code := v_existing_pkg.package_code;
    v_owner_setid := v_existing_pkg.owner_setid;
    v_status := v_existing_pkg.status;

    UPDATE orgunit.setid_scope_packages
    SET name = v_name,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id;
  ELSIF p_event_type = 'DISABLE' THEN
    SELECT * INTO v_existing_pkg
    FROM orgunit.setid_scope_packages
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id
    FOR UPDATE;

    IF v_existing_pkg.package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;
    IF v_existing_pkg.package_code = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_DEFLT_FORBIDDEN';
    END IF;

    v_package_code := v_existing_pkg.package_code;
    v_owner_setid := v_existing_pkg.owner_setid;
    v_name := v_existing_pkg.name;
    v_status := 'disabled';

    UPDATE orgunit.setid_scope_packages
    SET status = 'disabled',
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id;
  END IF;

  SELECT min(lower(validity)) INTO v_next_start
  FROM orgunit.setid_scope_package_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND package_id = p_package_id
    AND lower(validity) > p_effective_date;

  SELECT * INTO v_existing_version
  FROM orgunit.setid_scope_package_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND package_id = p_package_id
    AND validity @> p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  BEGIN
    IF FOUND THEN
      v_current_end := upper(v_existing_version.validity);
      IF lower(v_existing_version.validity) = p_effective_date THEN
        UPDATE orgunit.setid_scope_package_versions
        SET scope_code = p_scope_code,
            package_code = v_package_code,
            owner_setid = v_owner_setid,
            name = v_name,
            status = v_status,
            last_event_id = v_evt_db_id
        WHERE id = v_existing_version.id;
      ELSE
        UPDATE orgunit.setid_scope_package_versions
        SET validity = daterange(lower(v_existing_version.validity), p_effective_date, '[)')
        WHERE id = v_existing_version.id;

        INSERT INTO orgunit.setid_scope_package_versions (
          tenant_uuid,
          scope_code,
          package_id,
          package_code,
          owner_setid,
          name,
          status,
          validity,
          last_event_id
        )
        VALUES (
          p_tenant_uuid,
          p_scope_code,
          p_package_id,
          v_package_code,
          v_owner_setid,
          v_name,
          v_status,
          daterange(p_effective_date, v_current_end, '[)'),
          v_evt_db_id
        );
      END IF;
    ELSE
      INSERT INTO orgunit.setid_scope_package_versions (
        tenant_uuid,
        scope_code,
        package_id,
        package_code,
        owner_setid,
        name,
        status,
        validity,
        last_event_id
      )
      VALUES (
        p_tenant_uuid,
        p_scope_code,
        p_package_id,
        v_package_code,
        v_owner_setid,
        v_name,
        v_status,
        daterange(p_effective_date, v_next_start, '[)'),
        v_evt_db_id
      );
    END IF;
  EXCEPTION
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_VERSION_OVERLAP',
        DETAIL = format('package_id=%s effective_date=%s', p_package_id, p_effective_date);
  END;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_global_scope_package_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_scope_code text,
  p_package_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_evt_db_id bigint;
  v_payload jsonb;
  v_scope_mode text;
  v_package_code text;
  v_name text;
  v_status text;
  v_existing_pkg orgunit.global_setid_scope_packages%ROWTYPE;
  v_existing_version orgunit.global_setid_scope_package_versions%ROWTYPE;
  v_next_start date;
  v_current_end date;
BEGIN
  IF p_tenant_uuid <> orgunit.global_tenant_id() THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ACTOR_SCOPE_FORBIDDEN',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;

  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.assert_actor_scope_saas();

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'REQUEST_CODE_REQUIRED';
  END IF;
  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_NOT_FOUND';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('BOOTSTRAP', 'CREATE', 'RENAME', 'DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  IF v_scope_mode = 'tenant-only' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  INSERT INTO orgunit.global_setid_scope_package_events (
    event_uuid,
    tenant_uuid,
    scope_code,
    package_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_scope_code,
    p_package_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.global_setid_scope_package_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF EXISTS (
    SELECT 1
    FROM orgunit.global_setid_scope_package_versions
    WHERE last_event_id = v_evt_db_id
  ) THEN
    RETURN v_evt_db_id;
  END IF;

  IF p_event_type IN ('BOOTSTRAP', 'CREATE') THEN
    v_package_code := upper(btrim(COALESCE(v_payload->>'package_code', '')));
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');

    IF v_package_code = '' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_INVALID';
    END IF;
    IF v_package_code !~ '^[A-Z0-9_]{1,16}$' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_INVALID';
    END IF;
    IF p_event_type = 'CREATE' AND v_package_code = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_RESERVED';
    END IF;
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    IF EXISTS (
      SELECT 1
      FROM orgunit.global_setid_scope_packages
      WHERE tenant_uuid = p_tenant_uuid
        AND scope_code = p_scope_code
        AND package_code = v_package_code
        AND package_id <> p_package_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_DUPLICATE';
    END IF;

    v_status := 'active';

    INSERT INTO orgunit.global_setid_scope_packages (
      tenant_uuid,
      scope_code,
      package_id,
      package_code,
      name,
      status
    )
    VALUES (
      p_tenant_uuid,
      p_scope_code,
      p_package_id,
      v_package_code,
      v_name,
      v_status
    )
    ON CONFLICT (tenant_uuid, package_id) DO UPDATE
    SET scope_code = EXCLUDED.scope_code,
        package_code = EXCLUDED.package_code,
        name = EXCLUDED.name,
        status = EXCLUDED.status,
        updated_at = now();
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    SELECT * INTO v_existing_pkg
    FROM orgunit.global_setid_scope_packages
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id
    FOR UPDATE;

    IF v_existing_pkg.package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;

    v_package_code := v_existing_pkg.package_code;
    v_status := v_existing_pkg.status;

    UPDATE orgunit.global_setid_scope_packages
    SET name = v_name,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id;
  ELSIF p_event_type = 'DISABLE' THEN
    SELECT * INTO v_existing_pkg
    FROM orgunit.global_setid_scope_packages
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id
    FOR UPDATE;

    IF v_existing_pkg.package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;
    IF v_existing_pkg.package_code = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_DEFLT_FORBIDDEN';
    END IF;

    v_package_code := v_existing_pkg.package_code;
    v_name := v_existing_pkg.name;
    v_status := 'disabled';

    UPDATE orgunit.global_setid_scope_packages
    SET status = 'disabled',
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id;
  END IF;

  SELECT min(lower(validity)) INTO v_next_start
  FROM orgunit.global_setid_scope_package_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND package_id = p_package_id
    AND lower(validity) > p_effective_date;

  SELECT * INTO v_existing_version
  FROM orgunit.global_setid_scope_package_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND package_id = p_package_id
    AND validity @> p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  BEGIN
    IF FOUND THEN
      v_current_end := upper(v_existing_version.validity);
      IF lower(v_existing_version.validity) = p_effective_date THEN
        UPDATE orgunit.global_setid_scope_package_versions
        SET scope_code = p_scope_code,
            package_code = v_package_code,
            name = v_name,
            status = v_status,
            last_event_id = v_evt_db_id
        WHERE id = v_existing_version.id;
      ELSE
        UPDATE orgunit.global_setid_scope_package_versions
        SET validity = daterange(lower(v_existing_version.validity), p_effective_date, '[)')
        WHERE id = v_existing_version.id;

        INSERT INTO orgunit.global_setid_scope_package_versions (
          tenant_uuid,
          scope_code,
          package_id,
          package_code,
          name,
          status,
          validity,
          last_event_id
        )
        VALUES (
          p_tenant_uuid,
          p_scope_code,
          p_package_id,
          v_package_code,
          v_name,
          v_status,
          daterange(p_effective_date, v_current_end, '[)'),
          v_evt_db_id
        );
      END IF;
    ELSE
      INSERT INTO orgunit.global_setid_scope_package_versions (
        tenant_uuid,
        scope_code,
        package_id,
        package_code,
        name,
        status,
        validity,
        last_event_id
      )
      VALUES (
        p_tenant_uuid,
        p_scope_code,
        p_package_id,
        v_package_code,
        v_name,
        v_status,
        daterange(p_effective_date, v_next_start, '[)'),
        v_evt_db_id
      );
    END IF;
  EXCEPTION
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_VERSION_OVERLAP',
        DETAIL = format('package_id=%s effective_date=%s', p_package_id, p_effective_date);
  END;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_scope_subscription_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_setid text,
  p_scope_code text,
  p_package_id uuid,
  p_package_owner_tenant_uuid uuid,
  p_event_type text,
  p_effective_date date,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_scope_mode text;
  v_existing orgunit.setid_scope_subscriptions%ROWTYPE;
  v_next_start date;
  v_current_end date;
  v_setid_status text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'REQUEST_CODE_REQUIRED';
  END IF;
  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_NOT_FOUND';
  END IF;
  IF p_package_owner_tenant_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_OWNER_INVALID';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('BOOTSTRAP', 'SUBSCRIBE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'SHARE is reserved';
  END IF;

  SELECT status INTO v_setid_status
  FROM orgunit.setids
  WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;

  IF v_setid_status IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_NOT_FOUND',
      DETAIL = format('setid=%s', v_setid);
  END IF;
  IF v_setid_status <> 'active' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_DISABLED',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  IF p_package_owner_tenant_uuid <> p_tenant_uuid
     AND p_package_owner_tenant_uuid <> orgunit.global_tenant_id() THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_OWNER_INVALID';
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  IF v_scope_mode = 'shared-only' THEN
    PERFORM orgunit.assert_actor_scope_saas();
  END IF;

  PERFORM orgunit.assert_scope_package_active_as_of(
    p_tenant_uuid,
    p_scope_code,
    p_package_id,
    p_package_owner_tenant_uuid,
    p_effective_date
  );

  INSERT INTO orgunit.setid_scope_subscription_events (
    event_uuid,
    tenant_uuid,
    setid,
    scope_code,
    package_id,
    package_owner_tenant_uuid,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    v_setid,
    p_scope_code,
    p_package_id,
    p_package_owner_tenant_uuid,
    p_event_type,
    p_effective_date,
    '{}'::jsonb,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_scope_subscription_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF EXISTS (
    SELECT 1
    FROM orgunit.setid_scope_subscriptions
    WHERE last_event_id = v_evt_db_id
  ) THEN
    RETURN v_evt_db_id;
  END IF;

  SELECT min(lower(validity)) INTO v_next_start
  FROM orgunit.setid_scope_subscriptions
  WHERE tenant_uuid = p_tenant_uuid
    AND setid = v_setid
    AND scope_code = p_scope_code
    AND lower(validity) > p_effective_date;

  SELECT * INTO v_existing
  FROM orgunit.setid_scope_subscriptions
  WHERE tenant_uuid = p_tenant_uuid
    AND setid = v_setid
    AND scope_code = p_scope_code
    AND validity @> p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  BEGIN
    IF FOUND THEN
      v_current_end := upper(v_existing.validity);
      IF lower(v_existing.validity) = p_effective_date THEN
        UPDATE orgunit.setid_scope_subscriptions
        SET package_id = p_package_id,
            package_owner_tenant_uuid = p_package_owner_tenant_uuid,
            last_event_id = v_evt_db_id,
            updated_at = now()
        WHERE id = v_existing.id;
      ELSE
        UPDATE orgunit.setid_scope_subscriptions
        SET validity = daterange(lower(v_existing.validity), p_effective_date, '[)'),
            updated_at = now()
        WHERE id = v_existing.id;

        INSERT INTO orgunit.setid_scope_subscriptions (
          tenant_uuid,
          setid,
          scope_code,
          package_id,
          package_owner_tenant_uuid,
          validity,
          last_event_id
        )
        VALUES (
          p_tenant_uuid,
          v_setid,
          p_scope_code,
          p_package_id,
          p_package_owner_tenant_uuid,
          daterange(p_effective_date, v_current_end, '[)'),
          v_evt_db_id
        );
      END IF;
    ELSE
      INSERT INTO orgunit.setid_scope_subscriptions (
        tenant_uuid,
        setid,
        scope_code,
        package_id,
        package_owner_tenant_uuid,
        validity,
        last_event_id
      )
      VALUES (
        p_tenant_uuid,
        v_setid,
        p_scope_code,
        p_package_id,
        p_package_owner_tenant_uuid,
        daterange(p_effective_date, v_next_start, '[)'),
        v_evt_db_id
      );
    END IF;
  EXCEPTION
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SUBSCRIPTION_OVERLAP',
        DETAIL = format('setid=%s scope_code=%s effective_date=%s', v_setid, p_scope_code, p_effective_date);
  END;

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00011_orgunit_setid_scope_write_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00012_orgunit_scope_package_owner_setid.sql
ALTER TABLE orgunit.setid_scope_packages
  ADD COLUMN IF NOT EXISTS owner_setid text;

ALTER TABLE orgunit.setid_scope_packages
  ADD CONSTRAINT setid_scope_packages_owner_format_check
    CHECK (owner_setid ~ '^[A-Z0-9]{5}$');

ALTER TABLE orgunit.setid_scope_packages
  ADD CONSTRAINT setid_scope_packages_owner_fk
    FOREIGN KEY (tenant_uuid, owner_setid)
    REFERENCES orgunit.setids (tenant_uuid, setid);

CREATE INDEX IF NOT EXISTS setid_scope_packages_owner_lookup_idx
  ON orgunit.setid_scope_packages (tenant_uuid, scope_code, owner_setid, status);

ALTER TABLE orgunit.setid_scope_package_versions
  ADD COLUMN IF NOT EXISTS owner_setid text;

ALTER TABLE orgunit.setid_scope_package_versions
  ADD CONSTRAINT setid_scope_package_versions_owner_format_check
    CHECK (owner_setid ~ '^[A-Z0-9]{5}$');

ALTER TABLE orgunit.setid_scope_package_versions
  ADD CONSTRAINT setid_scope_package_versions_owner_fk
    FOREIGN KEY (tenant_uuid, owner_setid)
    REFERENCES orgunit.setids (tenant_uuid, setid);

CREATE INDEX IF NOT EXISTS setid_scope_package_versions_owner_lookup_idx
  ON orgunit.setid_scope_package_versions (tenant_uuid, scope_code, owner_setid, lower(validity));

ALTER TABLE orgunit.setid_scope_package_versions
  ADD CONSTRAINT setid_scope_package_versions_owner_scope_no_overlap
  EXCLUDE USING gist (
    tenant_uuid WITH =,
    scope_code gist_text_ops WITH =,
    owner_setid gist_text_ops WITH =,
    validity WITH &&
  )
  WHERE (status = 'active');

-- end: modules/orgunit/infrastructure/persistence/schema/00012_orgunit_scope_package_owner_setid.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00012_orgunit_setid_scope_write_kernel_privileges.sql
ALTER FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid)
  SET search_path = pg_catalog, orgunit;

REVOKE EXECUTE ON FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid) FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) TO app_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) TO app_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid) TO app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) TO superadmin_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) TO superadmin_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid) TO superadmin_runtime';
  END IF;
END $$;

-- end: modules/orgunit/infrastructure/persistence/schema/00012_orgunit_setid_scope_write_kernel_privileges.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00013_orgunit_scope_package_owner_setid_not_null.sql
ALTER TABLE orgunit.setid_scope_packages
  ALTER COLUMN owner_setid SET NOT NULL;

ALTER TABLE orgunit.setid_scope_package_versions
  ALTER COLUMN owner_setid SET NOT NULL;

-- end: modules/orgunit/infrastructure/persistence/schema/00013_orgunit_scope_package_owner_setid_not_null.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00014_orgunit_org_code_kernel_privileges.sql
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'orgunit_kernel') THEN
    CREATE ROLE orgunit_kernel NOLOGIN NOBYPASSRLS;
  END IF;
END $$;

GRANT USAGE ON SCHEMA orgunit TO orgunit_kernel;

DO $$
BEGIN
  IF to_regnamespace('iam') IS NOT NULL THEN
    GRANT USAGE ON SCHEMA iam TO orgunit_kernel;
  END IF;
  IF to_regclass('iam.principals') IS NOT NULL THEN
    GRANT SELECT ON TABLE iam.principals TO orgunit_kernel;
  END IF;
END $$;

ALTER TABLE IF EXISTS orgunit.org_unit_codes OWNER TO orgunit_kernel;

GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE
  orgunit.org_events,
  orgunit.org_events_effective,
  orgunit.org_unit_versions,
  orgunit.org_trees,
  orgunit.org_unit_codes
TO orgunit_kernel;


ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, int, text, date, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, int, text, date, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, int, text, date, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.extract_orgunit_snapshot(uuid, int, date)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.extract_orgunit_snapshot(uuid, int, date)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.extract_orgunit_snapshot(uuid, int, date)
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.is_org_event_snapshot_presence_valid(text, jsonb, jsonb, text)
  OWNER TO orgunit_kernel;

ALTER FUNCTION orgunit.is_orgunit_snapshot_complete(jsonb)
  OWNER TO orgunit_kernel;

ALTER FUNCTION orgunit.is_org_event_snapshot_content_valid(text, jsonb, jsonb, text)
  OWNER TO orgunit_kernel;

ALTER FUNCTION orgunit.assert_org_event_snapshots(text, jsonb, jsonb, text)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.assert_org_event_snapshots(text, jsonb, jsonb, text)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.assert_org_event_snapshots(text, jsonb, jsonb, text)
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.assert_org_event_snapshots(text, jsonb, jsonb)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.assert_org_event_snapshots(text, jsonb, jsonb)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.assert_org_event_snapshots(text, jsonb, jsonb)
  SET search_path = pg_catalog, orgunit, public;


ALTER FUNCTION orgunit.submit_org_event_correction(uuid, int, date, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_org_event_correction(uuid, int, date, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_org_event_correction(uuid, int, date, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.submit_org_status_correction(uuid, int, date, text, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_org_status_correction(uuid, int, date, text, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_org_status_correction(uuid, int, date, text, text, uuid)
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.submit_org_event_rescind(uuid, int, date, text, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_org_event_rescind(uuid, int, date, text, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_org_event_rescind(uuid, int, date, text, text, uuid)
  SET search_path = pg_catalog, orgunit, public;


ALTER FUNCTION orgunit.submit_org_rescind(uuid, int, text, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_org_rescind(uuid, int, text, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_org_rescind(uuid, int, text, text, uuid)
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.fill_org_event_audit_snapshot()
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.fill_org_event_audit_snapshot()
  SECURITY DEFINER;
ALTER FUNCTION orgunit.fill_org_event_audit_snapshot()
  SET search_path = pg_catalog, orgunit, iam, public;

REVOKE EXECUTE ON FUNCTION orgunit.rebuild_org_unit_versions_for_org(uuid, int) FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app') THEN
    EXECUTE 'REVOKE EXECUTE ON FUNCTION orgunit.rebuild_org_unit_versions_for_org(uuid, int) FROM app';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE EXECUTE ON FUNCTION orgunit.rebuild_org_unit_versions_for_org(uuid, int) FROM app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_nobypassrls') THEN
    EXECUTE 'REVOKE EXECUTE ON FUNCTION orgunit.rebuild_org_unit_versions_for_org(uuid, int) FROM app_nobypassrls';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'REVOKE EXECUTE ON FUNCTION orgunit.rebuild_org_unit_versions_for_org(uuid, int) FROM superadmin_runtime';
  END IF;
END $$;

GRANT EXECUTE ON FUNCTION orgunit.rebuild_org_unit_versions_for_org(uuid, int) TO orgunit_kernel;
ALTER FUNCTION orgunit.rebuild_org_unit_versions_for_org(uuid, int) OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.rebuild_org_unit_versions_for_org(uuid, int) SET search_path = pg_catalog, orgunit, public;

REVOKE EXECUTE ON FUNCTION orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
  uuid,
  int,
  bigint,
  uuid,
  text,
  date,
  jsonb,
  text,
  uuid,
  timestamptz,
  timestamptz,
  timestamptz
) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
  uuid,
  int,
  bigint,
  uuid,
  text,
  date,
  jsonb,
  text,
  uuid,
  timestamptz,
  timestamptz,
  timestamptz
) TO orgunit_kernel;
ALTER FUNCTION orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
  uuid,
  int,
  bigint,
  uuid,
  text,
  date,
  jsonb,
  text,
  uuid,
  timestamptz,
  timestamptz,
  timestamptz
) OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.rebuild_org_unit_versions_for_org_with_pending_event(
  uuid,
  int,
  bigint,
  uuid,
  text,
  date,
  jsonb,
  text,
  uuid,
  timestamptz,
  timestamptz,
  timestamptz
) SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.org_events_effective_for_replay(
  uuid,
  int,
  bigint,
  uuid,
  text,
  date,
  jsonb,
  text,
  uuid,
  timestamptz,
  timestamptz,
  timestamptz
) OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.org_events_effective_for_replay(
  uuid,
  int,
  bigint,
  uuid,
  text,
  date,
  jsonb,
  text,
  uuid,
  timestamptz,
  timestamptz,
  timestamptz
) SET search_path = pg_catalog, orgunit, public;

REVOKE ALL ON TABLE orgunit.org_unit_codes FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE orgunit.org_unit_codes FROM app';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.org_unit_codes TO app';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE orgunit.org_unit_codes FROM app_runtime';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.org_unit_codes TO app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_nobypassrls') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE orgunit.org_unit_codes FROM app_nobypassrls';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.org_unit_codes TO app_nobypassrls';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE orgunit.org_unit_codes FROM superadmin_runtime';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.org_unit_codes TO superadmin_runtime';
  END IF;
END $$;

CREATE OR REPLACE FUNCTION orgunit.guard_org_unit_codes_write()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF current_user <> 'orgunit_kernel' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORGUNIT_CODES_WRITE_FORBIDDEN',
      DETAIL = format('role=%s', current_user);
  END IF;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;

ALTER FUNCTION orgunit.guard_org_unit_codes_write() OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.guard_org_unit_codes_write() SET search_path = pg_catalog, orgunit, public;

DROP TRIGGER IF EXISTS guard_org_unit_codes_write ON orgunit.org_unit_codes;
CREATE TRIGGER guard_org_unit_codes_write
BEFORE INSERT OR UPDATE OR DELETE ON orgunit.org_unit_codes
FOR EACH ROW EXECUTE FUNCTION orgunit.guard_org_unit_codes_write();

-- end: modules/orgunit/infrastructure/persistence/schema/00014_orgunit_org_code_kernel_privileges.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00015_orgunit_org_id_allocator.sql
CREATE TABLE IF NOT EXISTS orgunit.org_id_allocators (
  tenant_uuid uuid NOT NULL,
  next_org_id int NOT NULL CHECK (next_org_id BETWEEN 10000000 AND 100000000),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid)
);

ALTER TABLE orgunit.org_id_allocators ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_id_allocators FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_id_allocators;
CREATE POLICY tenant_isolation ON orgunit.org_id_allocators
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

CREATE OR REPLACE FUNCTION orgunit.allocate_org_id(p_tenant_uuid uuid)
RETURNS int
LANGUAGE plpgsql
AS $$
DECLARE
  v_next int;
  v_max int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  SELECT COALESCE(MAX(org_id), 9999999)
  INTO v_max
  FROM orgunit.org_events
  WHERE tenant_uuid = p_tenant_uuid;

  IF v_max >= 99999999 THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ID_EXHAUSTED',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;

  INSERT INTO orgunit.org_id_allocators (tenant_uuid, next_org_id)
  VALUES (p_tenant_uuid, v_max + 2)
  ON CONFLICT (tenant_uuid) DO UPDATE
  SET next_org_id = GREATEST(orgunit.org_id_allocators.next_org_id, v_max + 1) + 1,
      updated_at = now()
  WHERE orgunit.org_id_allocators.next_org_id <= 99999999
  RETURNING next_org_id - 1 INTO v_next;

  IF v_next IS NULL OR v_next > 99999999 THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ID_EXHAUSTED',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;

  RETURN v_next;
END;
$$;

ALTER TABLE IF EXISTS orgunit.org_id_allocators OWNER TO orgunit_kernel;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE orgunit.org_id_allocators TO orgunit_kernel;

ALTER FUNCTION orgunit.allocate_org_id(uuid) OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.allocate_org_id(uuid) SECURITY DEFINER;
ALTER FUNCTION orgunit.allocate_org_id(uuid) SET search_path = pg_catalog, orgunit, public;

CREATE OR REPLACE FUNCTION orgunit.submit_org_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_org_id int,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing orgunit.org_events%ROWTYPE;
  v_existing_request orgunit.org_events%ROWTYPE;
  v_payload jsonb;
  v_org_id int;
  v_parent_id int;
  v_new_parent_id int;
  v_name text;
  v_new_name text;
  v_manager_uuid uuid;
  v_is_business_unit boolean;
  v_org_code text;
  v_root_path ltree;
  v_org_ids int[];
  v_before_snapshot jsonb;
  v_after_snapshot jsonb;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'event_uuid is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  IF p_event_type NOT IN ('CREATE','MOVE','RENAME','DISABLE','ENABLE','SET_BUSINESS_UNIT') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_lock_key := format('org:write-lock:%s', p_tenant_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF p_event_type = 'SET_BUSINESS_UNIT' THEN
    IF NOT (v_payload ? 'is_business_unit') THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_INVALID_ARGUMENT',
        DETAIL = 'is_business_unit is required';
    END IF;
    BEGIN
      PERFORM (v_payload->>'is_business_unit')::boolean;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_INVALID_ARGUMENT',
          DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
    END;
  END IF;

  IF p_event_type = 'CREATE' AND p_org_id IS NULL THEN
    SELECT * INTO v_existing
    FROM orgunit.org_events
    WHERE event_uuid = p_event_uuid;

    IF FOUND THEN
      IF v_existing.tenant_uuid <> p_tenant_uuid
        OR v_existing.event_type <> p_event_type
        OR v_existing.effective_date <> p_effective_date
        OR v_existing.payload <> v_payload
        OR v_existing.request_code <> p_request_code
        OR v_existing.initiator_uuid <> p_initiator_uuid
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_IDEMPOTENCY_REUSED',
          DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
      END IF;

      RETURN v_existing.id;
    END IF;

    v_org_id := orgunit.allocate_org_id(p_tenant_uuid);
  ELSE
    IF p_org_id IS NULL THEN
      RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
    END IF;
    v_org_id := p_org_id;
  END IF;

  SELECT * INTO v_existing_request
  FROM orgunit.org_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = p_request_code
  LIMIT 1;

  IF FOUND THEN
    IF v_existing_request.event_uuid <> p_event_uuid
      OR v_existing_request.org_id <> v_org_id
      OR v_existing_request.event_type <> p_event_type
      OR v_existing_request.effective_date <> p_effective_date
      OR v_existing_request.payload <> v_payload
      OR v_existing_request.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
        DETAIL = format('request_code=%s', p_request_code);
    END IF;

    RETURN v_existing_request.id;
  END IF;

  v_before_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, v_org_id, p_effective_date);

  SELECT * INTO v_existing
  FROM orgunit.org_events
  WHERE event_uuid = p_event_uuid;

  IF FOUND THEN
    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.org_id <> v_org_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  SELECT nextval(pg_get_serial_sequence('orgunit.org_events', 'id')) INTO v_event_db_id;

  IF p_event_type = 'CREATE' THEN
    v_parent_id := NULLIF(v_payload->>'parent_id', '')::int;
    v_name := NULLIF(btrim(v_payload->>'name'), '');
    v_manager_uuid := NULLIF(v_payload->>'manager_uuid', '')::uuid;
    v_org_code := NULLIF(v_payload->>'org_code', '');
    v_is_business_unit := NULL;
    IF v_payload ? 'is_business_unit' THEN
      BEGIN
        v_is_business_unit := (v_payload->>'is_business_unit')::boolean;
      EXCEPTION
        WHEN invalid_text_representation THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_INVALID_ARGUMENT',
            DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
      END;
    END IF;
    PERFORM orgunit.apply_create_logic(p_tenant_uuid, v_org_id, v_org_code, v_parent_id, p_effective_date, v_name, v_manager_uuid, v_is_business_unit, v_event_db_id);
    SELECT v.node_path INTO v_root_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.org_id = v_org_id
      AND v.validity @> p_effective_date
    ORDER BY lower(v.validity) DESC
    LIMIT 1;
    PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, p_effective_date);
    v_org_ids := ARRAY[v_org_id];
  ELSIF p_event_type = 'MOVE' THEN
    v_new_parent_id := NULLIF(v_payload->>'new_parent_id', '')::int;
    PERFORM orgunit.apply_move_logic(p_tenant_uuid, v_org_id, v_new_parent_id, p_effective_date, v_event_db_id);
    SELECT v.node_path INTO v_root_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.org_id = v_org_id
      AND v.validity @> p_effective_date
    ORDER BY lower(v.validity) DESC
    LIMIT 1;
    PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, p_effective_date);
    SELECT array_agg(DISTINCT v.org_id) INTO v_org_ids
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.node_path <@ v_root_path;
  ELSIF p_event_type = 'RENAME' THEN
    v_new_name := NULLIF(btrim(v_payload->>'new_name'), '');
    PERFORM orgunit.apply_rename_logic(p_tenant_uuid, v_org_id, p_effective_date, v_new_name, v_event_db_id);
    SELECT v.node_path INTO v_root_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.org_id = v_org_id
      AND v.validity @> p_effective_date
    ORDER BY lower(v.validity) DESC
    LIMIT 1;
    PERFORM orgunit.rebuild_full_name_path_subtree(p_tenant_uuid, v_root_path, p_effective_date);
    v_org_ids := ARRAY[v_org_id];
  ELSIF p_event_type = 'DISABLE' THEN
    PERFORM orgunit.apply_disable_logic(p_tenant_uuid, v_org_id, p_effective_date, v_event_db_id);
    v_org_ids := ARRAY[v_org_id];
  ELSIF p_event_type = 'ENABLE' THEN
    PERFORM orgunit.apply_enable_logic(p_tenant_uuid, v_org_id, p_effective_date, v_event_db_id);
    v_org_ids := ARRAY[v_org_id];
  ELSIF p_event_type = 'SET_BUSINESS_UNIT' THEN
    v_is_business_unit := (v_payload->>'is_business_unit')::boolean;
    PERFORM orgunit.apply_set_business_unit_logic(p_tenant_uuid, v_org_id, p_effective_date, v_is_business_unit, v_event_db_id);
    v_org_ids := ARRAY[v_org_id];
  END IF;

  PERFORM orgunit.apply_org_event_ext_payload(
    p_tenant_uuid,
    v_org_id,
    p_effective_date,
    p_event_type,
    v_payload
  );

  PERFORM orgunit.assert_org_unit_validity(p_tenant_uuid, v_org_ids);

  v_after_snapshot := orgunit.extract_orgunit_snapshot(p_tenant_uuid, v_org_id, p_effective_date);
  PERFORM orgunit.assert_org_event_snapshots(p_event_type, v_before_snapshot, v_after_snapshot, NULL);

  INSERT INTO orgunit.org_events (
    id,
    event_uuid,
    tenant_uuid,
    org_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid,
    before_snapshot,
    after_snapshot
  )
  VALUES (
    v_event_db_id,
    p_event_uuid,
    p_tenant_uuid,
    v_org_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid,
    v_before_snapshot,
    v_after_snapshot
  );

  RETURN v_event_db_id;
END;
$$;

ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, int, text, date, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, int, text, date, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, int, text, date, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit, public;

-- end: modules/orgunit/infrastructure/persistence/schema/00015_orgunit_org_id_allocator.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00016_orgunit_field_configs_schema.sql
-- OrgUnit tenant field configs (metadata) + wide-table ext slots (Phase 1)
-- SSOT: docs/dev-plans/100a-org-metadata-wide-table-phase0-contract-freeze-readiness.md
-- SSOT: docs/dev-plans/100b-org-metadata-wide-table-phase1-schema-and-metadata-skeleton.md

CREATE TABLE IF NOT EXISTS orgunit.tenant_field_configs (
  tenant_uuid uuid NOT NULL,
  field_key text NOT NULL,
  physical_col text NOT NULL,
  value_type text NOT NULL,
  data_source_type text NOT NULL,
  data_source_config jsonb NOT NULL DEFAULT '{}'::jsonb,
  enabled_on date NOT NULL,
  disabled_on date NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  disabled_at timestamptz NULL,
  PRIMARY KEY (tenant_uuid, field_key),
  -- field_key will be used as payload.ext key; keep it simple and safe.
  CONSTRAINT tenant_field_configs_field_key_format_check CHECK (field_key ~ '^[a-z][a-z0-9_]{0,62}$'),
  CONSTRAINT tenant_field_configs_value_type_check CHECK (value_type IN ('text','int','uuid','bool','date')),
  CONSTRAINT tenant_field_configs_data_source_type_check CHECK (data_source_type IN ('PLAIN','DICT','ENTITY')),
  CONSTRAINT tenant_field_configs_data_source_config_is_object_check CHECK (jsonb_typeof(data_source_config) = 'object'),
  -- data_source_config shape (SSOT: DEV-PLAN-100A §4.3)
  CONSTRAINT tenant_field_configs_plain_config_check CHECK (
    data_source_type <> 'PLAIN' OR data_source_config = '{}'::jsonb
  ),
  CONSTRAINT tenant_field_configs_dict_config_check CHECK (
    data_source_type <> 'DICT' OR (
      value_type = 'text'
      AND data_source_config ? 'dict_code'
      AND jsonb_typeof(data_source_config->'dict_code') = 'string'
      AND NULLIF(btrim(data_source_config->>'dict_code'), '') IS NOT NULL
      -- forbid extra keys to avoid "hidden config" drift
      AND data_source_config = jsonb_build_object('dict_code', data_source_config->'dict_code')
    )
  ),
  CONSTRAINT tenant_field_configs_entity_config_check CHECK (
    data_source_type <> 'ENTITY' OR (
      data_source_config ? 'entity'
      AND jsonb_typeof(data_source_config->'entity') = 'string'
      AND NULLIF(btrim(data_source_config->>'entity'), '') IS NOT NULL
      AND data_source_config ? 'id_kind'
      AND jsonb_typeof(data_source_config->'id_kind') = 'string'
      AND (data_source_config->>'id_kind') IN ('uuid','int')
      AND (
        ((data_source_config->>'id_kind') = 'uuid' AND value_type = 'uuid')
        OR
        ((data_source_config->>'id_kind') = 'int' AND value_type = 'int')
      )
      -- forbid extra keys to avoid "hidden config" drift
      AND data_source_config = jsonb_build_object(
        'entity', data_source_config->'entity',
        'id_kind', data_source_config->'id_kind'
      )
    )
  ),
  -- physical_col is used for dynamic SQL allowlist; keep the format strict.
  CONSTRAINT tenant_field_configs_physical_col_format_check CHECK (
    physical_col ~ '^ext_(str|int|uuid|bool|date)_[0-9]{2}$'
  ),
  CONSTRAINT tenant_field_configs_physical_col_group_check CHECK (
    (value_type = 'text' AND physical_col LIKE 'ext_str_%')
    OR (value_type = 'int' AND physical_col LIKE 'ext_int_%')
    OR (value_type = 'uuid' AND physical_col LIKE 'ext_uuid_%')
    OR (value_type = 'bool' AND physical_col LIKE 'ext_bool_%')
    OR (value_type = 'date' AND physical_col LIKE 'ext_date_%')
  ),
  CONSTRAINT tenant_field_configs_disabled_on_check CHECK (disabled_on IS NULL OR disabled_on >= enabled_on),
  CONSTRAINT tenant_field_configs_physical_col_unique UNIQUE (tenant_uuid, physical_col)
);

CREATE TABLE IF NOT EXISTS orgunit.tenant_field_config_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  event_type text NOT NULL,
  field_key text NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT tenant_field_config_events_event_type_check CHECK (event_type IN ('ENABLE','DISABLE')),
  CONSTRAINT tenant_field_config_events_field_key_format_check CHECK (field_key ~ '^[a-z][a-z0-9_]{0,62}$'),
  CONSTRAINT tenant_field_config_events_request_code_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT tenant_field_config_events_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT tenant_field_config_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS tenant_field_config_events_tenant_time_idx
  ON orgunit.tenant_field_config_events (tenant_uuid, transaction_time DESC, id DESC);

ALTER TABLE orgunit.tenant_field_config_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.tenant_field_config_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.tenant_field_config_events;
CREATE POLICY tenant_isolation ON orgunit.tenant_field_config_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.tenant_field_configs ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.tenant_field_configs FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.tenant_field_configs;
CREATE POLICY tenant_isolation ON orgunit.tenant_field_configs
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- -------------------------------------------------------------------
-- DB guards (fail-closed): no direct DML; only orgunit_kernel can write.
-- -------------------------------------------------------------------

CREATE OR REPLACE FUNCTION orgunit.guard_tenant_field_configs_write()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF current_user <> 'orgunit_kernel' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORGUNIT_FIELD_CONFIGS_WRITE_FORBIDDEN',
      DETAIL = format('role=%s table=%s', current_user, TG_TABLE_NAME);
  END IF;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS guard_tenant_field_configs_write ON orgunit.tenant_field_configs;
CREATE TRIGGER guard_tenant_field_configs_write
BEFORE INSERT OR UPDATE OR DELETE ON orgunit.tenant_field_configs
FOR EACH ROW EXECUTE FUNCTION orgunit.guard_tenant_field_configs_write();

DROP TRIGGER IF EXISTS guard_tenant_field_config_events_write ON orgunit.tenant_field_config_events;
CREATE TRIGGER guard_tenant_field_config_events_write
BEFORE INSERT OR UPDATE OR DELETE ON orgunit.tenant_field_config_events
FOR EACH ROW EXECUTE FUNCTION orgunit.guard_tenant_field_configs_write();

-- -------------------------------------------------------------------
-- Mapping immutability + disabled_on rules (defense-in-depth).
-- -------------------------------------------------------------------

CREATE OR REPLACE FUNCTION orgunit.assert_tenant_field_configs_update_allowed()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF TG_OP <> 'UPDATE' THEN
    RETURN NEW;
  END IF;

  -- Mapping is immutable after enable.
  IF NEW.field_key <> OLD.field_key
    OR NEW.physical_col <> OLD.physical_col
    OR NEW.value_type <> OLD.value_type
    OR NEW.data_source_type <> OLD.data_source_type
    OR NEW.data_source_config <> OLD.data_source_config
    OR NEW.enabled_on <> OLD.enabled_on
  THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_FIELD_CONFIG_MAPPING_IMMUTABLE',
      DETAIL = format('field_key=%s', OLD.field_key);
  END IF;

  -- disabled_on cannot be "unset".
  IF OLD.disabled_on IS NOT NULL AND NEW.disabled_on IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_FIELD_CONFIG_DISABLED_ON_INVALID',
      DETAIL = format('field_key=%s', OLD.field_key);
  END IF;

  -- When setting disabled_on for the first time, forbid backdating.
  IF OLD.disabled_on IS NULL AND NEW.disabled_on IS NOT NULL THEN
    IF NEW.disabled_on < current_date THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_FIELD_CONFIG_DISABLED_ON_INVALID',
        DETAIL = format('field_key=%s disabled_on=%s', OLD.field_key, NEW.disabled_on);
    END IF;
    RETURN NEW;
  END IF;

  -- If disabled_on changes, it must be "not effective yet" and only postponed.
  IF OLD.disabled_on IS NOT NULL AND NEW.disabled_on IS NOT NULL AND NEW.disabled_on <> OLD.disabled_on THEN
    IF current_date >= OLD.disabled_on THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_FIELD_CONFIG_DISABLED_ON_INVALID',
        DETAIL = format('field_key=%s disabled_on=%s', OLD.field_key, OLD.disabled_on);
    END IF;
    IF NEW.disabled_on <= OLD.disabled_on THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_FIELD_CONFIG_DISABLED_ON_INVALID',
        DETAIL = format('field_key=%s old=%s new=%s', OLD.field_key, OLD.disabled_on, NEW.disabled_on);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS tenant_field_configs_update_allowed ON orgunit.tenant_field_configs;
CREATE TRIGGER tenant_field_configs_update_allowed
BEFORE UPDATE ON orgunit.tenant_field_configs
FOR EACH ROW EXECUTE FUNCTION orgunit.assert_tenant_field_configs_update_allowed();

-- -------------------------------------------------------------------
-- Wide-table ext slots (MVP batch).
-- -------------------------------------------------------------------

ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_str_01 text NULL;
ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_str_02 text NULL;
ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_str_03 text NULL;
ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_str_04 text NULL;
ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_str_05 text NULL;

ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_int_01 int NULL;
ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_uuid_01 uuid NULL;
ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_bool_01 boolean NULL;
ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_date_01 date NULL;

ALTER TABLE orgunit.org_unit_versions
  ADD COLUMN IF NOT EXISTS ext_labels_snapshot jsonb NOT NULL DEFAULT '{}'::jsonb;

-- MVP: at least one DICT field requires list filter/sort (see DEV-PLAN-100A §9.1).
-- Since physical_col is assigned dynamically, we pre-index all ext_str slots.
CREATE INDEX IF NOT EXISTS org_unit_versions_ext_str_01_idx
  ON orgunit.org_unit_versions (tenant_uuid, ext_str_01)
  WHERE ext_str_01 IS NOT NULL;
CREATE INDEX IF NOT EXISTS org_unit_versions_ext_str_02_idx
  ON orgunit.org_unit_versions (tenant_uuid, ext_str_02)
  WHERE ext_str_02 IS NOT NULL;
CREATE INDEX IF NOT EXISTS org_unit_versions_ext_str_03_idx
  ON orgunit.org_unit_versions (tenant_uuid, ext_str_03)
  WHERE ext_str_03 IS NOT NULL;
CREATE INDEX IF NOT EXISTS org_unit_versions_ext_str_04_idx
  ON orgunit.org_unit_versions (tenant_uuid, ext_str_04)
  WHERE ext_str_04 IS NOT NULL;
CREATE INDEX IF NOT EXISTS org_unit_versions_ext_str_05_idx
  ON orgunit.org_unit_versions (tenant_uuid, ext_str_05)
  WHERE ext_str_05 IS NOT NULL;

-- -------------------------------------------------------------------
-- Kernel write entrypoints (One Door for metadata writes).
-- -------------------------------------------------------------------

CREATE OR REPLACE FUNCTION orgunit.enable_tenant_field_config(
  p_tenant_uuid uuid,
  p_field_key text,
  p_value_type text,
  p_enabled_on date,
  p_data_source_type text,
  p_data_source_config jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_existing orgunit.tenant_field_config_events%ROWTYPE;
  v_config jsonb;
  v_physical_col text;
  v_candidate_cols text[];
  v_col text;
  v_payload jsonb;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_field_key IS NULL OR btrim(p_field_key) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'field_key is required';
  END IF;
  IF p_field_key !~ '^[a-z][a-z0-9_]{0,62}$' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = format('field_key=%s', p_field_key);
  END IF;
  IF p_value_type IS NULL OR btrim(p_value_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'value_type is required';
  END IF;
  IF p_enabled_on IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'enabled_on is required';
  END IF;
  IF p_data_source_type IS NULL OR btrim(p_data_source_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'data_source_type is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  v_lock_key := format('org:field-config-lock:%s', p_tenant_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_config := COALESCE(p_data_source_config, '{}'::jsonb);
  IF jsonb_typeof(v_config) <> 'object' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_FIELD_CONFIG_INVALID_DATA_SOURCE_CONFIG',
      DETAIL = 'data_source_config must be an object';
  END IF;

  SELECT * INTO v_existing
  FROM orgunit.tenant_field_config_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = p_request_code
  LIMIT 1;

  IF FOUND THEN
    IF v_existing.event_type <> 'ENABLE'
      OR v_existing.field_key <> p_field_key
      OR v_existing.initiator_uuid <> p_initiator_uuid
      OR COALESCE(v_existing.payload->>'value_type', '') <> p_value_type
      OR COALESCE(v_existing.payload->>'data_source_type', '') <> p_data_source_type
      OR COALESCE(v_existing.payload->>'enabled_on', '') <> p_enabled_on::text
      OR COALESCE(v_existing.payload->'data_source_config', '{}'::jsonb) <> v_config
      OR v_existing.payload->>'disabled_on' IS NOT NULL
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
        DETAIL = format('request_code=%s', p_request_code);
    END IF;

    RETURN;
  END IF;

  IF p_value_type NOT IN ('text','int','uuid','bool','date') THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = format('value_type=%s', p_value_type);
  END IF;
  IF p_data_source_type NOT IN ('PLAIN','DICT','ENTITY') THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = format('data_source_type=%s', p_data_source_type);
  END IF;

  IF p_data_source_type = 'PLAIN' THEN
    IF v_config <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_FIELD_CONFIG_INVALID_DATA_SOURCE_CONFIG',
        DETAIL = format('field_key=%s data_source_type=PLAIN requires {}', p_field_key);
    END IF;
  ELSIF p_data_source_type = 'DICT' THEN
    IF p_value_type <> 'text'
      OR NOT (v_config ? 'dict_code')
      OR jsonb_typeof(v_config->'dict_code') <> 'string'
      OR NULLIF(btrim(v_config->>'dict_code'), '') IS NULL
      OR v_config <> jsonb_build_object('dict_code', v_config->'dict_code')
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_FIELD_CONFIG_INVALID_DATA_SOURCE_CONFIG',
        DETAIL = format('field_key=%s data_source_type=DICT', p_field_key);
    END IF;
  ELSIF p_data_source_type = 'ENTITY' THEN
    IF NOT (v_config ? 'entity')
      OR jsonb_typeof(v_config->'entity') <> 'string'
      OR NULLIF(btrim(v_config->>'entity'), '') IS NULL
      OR NOT (v_config ? 'id_kind')
      OR jsonb_typeof(v_config->'id_kind') <> 'string'
      OR (v_config->>'id_kind') NOT IN ('uuid','int')
      OR (
        ((v_config->>'id_kind') = 'uuid' AND p_value_type <> 'uuid')
        OR
        ((v_config->>'id_kind') = 'int' AND p_value_type <> 'int')
      )
      OR v_config <> jsonb_build_object(
        'entity', v_config->'entity',
        'id_kind', v_config->'id_kind'
      )
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_FIELD_CONFIG_INVALID_DATA_SOURCE_CONFIG',
        DETAIL = format('field_key=%s data_source_type=ENTITY', p_field_key);
    END IF;
  END IF;

  IF EXISTS (
    SELECT 1
    FROM orgunit.tenant_field_configs
    WHERE tenant_uuid = p_tenant_uuid
      AND field_key = p_field_key
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_FIELD_CONFIG_ALREADY_ENABLED',
      DETAIL = format('field_key=%s', p_field_key);
  END IF;

  IF p_value_type = 'text' THEN
    v_candidate_cols := ARRAY['ext_str_01','ext_str_02','ext_str_03','ext_str_04','ext_str_05'];
  ELSIF p_value_type = 'int' THEN
    v_candidate_cols := ARRAY['ext_int_01'];
  ELSIF p_value_type = 'uuid' THEN
    v_candidate_cols := ARRAY['ext_uuid_01'];
  ELSIF p_value_type = 'bool' THEN
    v_candidate_cols := ARRAY['ext_bool_01'];
  ELSIF p_value_type = 'date' THEN
    v_candidate_cols := ARRAY['ext_date_01'];
  END IF;

  v_physical_col := NULL;
  FOREACH v_col IN ARRAY v_candidate_cols LOOP
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.tenant_field_configs
      WHERE tenant_uuid = p_tenant_uuid
        AND physical_col = v_col
    ) THEN
      v_physical_col := v_col;
      EXIT;
    END IF;
  END LOOP;

  IF v_physical_col IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_FIELD_CONFIG_SLOT_EXHAUSTED',
      DETAIL = format('field_key=%s value_type=%s', p_field_key, p_value_type);
  END IF;

  v_payload := jsonb_build_object(
    'physical_col', v_physical_col,
    'value_type', p_value_type,
    'data_source_type', p_data_source_type,
    'data_source_config', v_config,
    'enabled_on', p_enabled_on::text,
    'disabled_on', NULL
  );

  INSERT INTO orgunit.tenant_field_config_events (
    event_uuid,
    tenant_uuid,
    event_type,
    field_key,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    gen_random_uuid(),
    p_tenant_uuid,
    'ENABLE',
    p_field_key,
    v_payload,
    p_request_code,
    p_initiator_uuid
  );

  INSERT INTO orgunit.tenant_field_configs (
    tenant_uuid,
    field_key,
    physical_col,
    value_type,
    data_source_type,
    data_source_config,
    enabled_on,
    disabled_on,
    created_at,
    updated_at
  )
  VALUES (
    p_tenant_uuid,
    p_field_key,
    v_physical_col,
    p_value_type,
    p_data_source_type,
    v_config,
    p_enabled_on,
    NULL,
    now(),
    now()
  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.disable_tenant_field_config(
  p_tenant_uuid uuid,
  p_field_key text,
  p_disabled_on date,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_existing orgunit.tenant_field_config_events%ROWTYPE;
  v_cfg orgunit.tenant_field_configs%ROWTYPE;
  v_payload jsonb;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_field_key IS NULL OR btrim(p_field_key) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'field_key is required';
  END IF;
  IF p_field_key !~ '^[a-z][a-z0-9_]{0,62}$' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = format('field_key=%s', p_field_key);
  END IF;
  IF p_disabled_on IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'disabled_on is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  v_lock_key := format('org:field-config-lock:%s', p_tenant_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_existing
  FROM orgunit.tenant_field_config_events
  WHERE tenant_uuid = p_tenant_uuid
    AND request_code = p_request_code
  LIMIT 1;

  IF FOUND THEN
    IF v_existing.event_type <> 'DISABLE'
      OR v_existing.field_key <> p_field_key
      OR v_existing.initiator_uuid <> p_initiator_uuid
      OR COALESCE(v_existing.payload->>'disabled_on', '') <> p_disabled_on::text
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_REQUEST_ID_CONFLICT',
        DETAIL = format('request_code=%s', p_request_code);
    END IF;

    RETURN;
  END IF;

  SELECT * INTO v_cfg
  FROM orgunit.tenant_field_configs
  WHERE tenant_uuid = p_tenant_uuid
    AND field_key = p_field_key
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_FIELD_CONFIG_NOT_FOUND',
      DETAIL = format('field_key=%s', p_field_key);
  END IF;

  IF p_disabled_on < v_cfg.enabled_on THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_FIELD_CONFIG_DISABLED_ON_INVALID',
      DETAIL = format('field_key=%s enabled_on=%s disabled_on=%s', p_field_key, v_cfg.enabled_on, p_disabled_on);
  END IF;
  -- MVP freeze: forbid backdating disables.
  IF p_disabled_on < current_date THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_FIELD_CONFIG_DISABLED_ON_INVALID',
      DETAIL = format('field_key=%s disabled_on=%s', p_field_key, p_disabled_on);
  END IF;

  IF v_cfg.disabled_on IS NOT NULL THEN
    IF current_date >= v_cfg.disabled_on THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_FIELD_CONFIG_DISABLED_ON_INVALID',
        DETAIL = format('field_key=%s disabled_on=%s', p_field_key, v_cfg.disabled_on);
    END IF;
    IF p_disabled_on <= v_cfg.disabled_on THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_FIELD_CONFIG_DISABLED_ON_INVALID',
        DETAIL = format('field_key=%s old=%s new=%s', p_field_key, v_cfg.disabled_on, p_disabled_on);
    END IF;
  END IF;

  v_payload := jsonb_build_object('disabled_on', p_disabled_on::text);

  INSERT INTO orgunit.tenant_field_config_events (
    event_uuid,
    tenant_uuid,
    event_type,
    field_key,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    gen_random_uuid(),
    p_tenant_uuid,
    'DISABLE',
    p_field_key,
    v_payload,
    p_request_code,
    p_initiator_uuid
  );

  UPDATE orgunit.tenant_field_configs
  SET disabled_on = p_disabled_on,
      disabled_at = now(),
      updated_at = now()
  WHERE tenant_uuid = p_tenant_uuid
    AND field_key = p_field_key;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00016_orgunit_field_configs_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00017_orgunit_field_configs_kernel_privileges.sql
-- OrgUnit tenant field configs (metadata) kernel privileges (Phase 1)
-- SSOT: docs/dev-plans/100b-org-metadata-wide-table-phase1-schema-and-metadata-skeleton.md

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'orgunit_kernel') THEN
    CREATE ROLE orgunit_kernel NOLOGIN NOBYPASSRLS;
  END IF;
END $$;

GRANT USAGE ON SCHEMA orgunit TO orgunit_kernel;

ALTER TABLE IF EXISTS orgunit.tenant_field_config_events OWNER TO orgunit_kernel;
ALTER TABLE IF EXISTS orgunit.tenant_field_configs OWNER TO orgunit_kernel;

GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE
  orgunit.tenant_field_config_events,
  orgunit.tenant_field_configs
TO orgunit_kernel;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA orgunit TO orgunit_kernel;

ALTER FUNCTION orgunit.guard_tenant_field_configs_write()
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.guard_tenant_field_configs_write()
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.assert_tenant_field_configs_update_allowed()
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.assert_tenant_field_configs_update_allowed()
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.enable_tenant_field_config(uuid, text, text, date, text, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.enable_tenant_field_config(uuid, text, text, date, text, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.enable_tenant_field_config(uuid, text, text, date, text, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit, public;

ALTER FUNCTION orgunit.disable_tenant_field_config(uuid, text, date, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.disable_tenant_field_config(uuid, text, date, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.disable_tenant_field_config(uuid, text, date, text, uuid)
  SET search_path = pg_catalog, orgunit, public;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.tenant_field_config_events, ' ||
      'orgunit.tenant_field_configs ' ||
      'FROM app';
    EXECUTE 'GRANT SELECT ON TABLE ' ||
      'orgunit.tenant_field_config_events, ' ||
      'orgunit.tenant_field_configs ' ||
      'TO app';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.tenant_field_config_events, ' ||
      'orgunit.tenant_field_configs ' ||
      'FROM app_runtime';
    EXECUTE 'GRANT SELECT ON TABLE ' ||
      'orgunit.tenant_field_config_events, ' ||
      'orgunit.tenant_field_configs ' ||
      'TO app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_nobypassrls') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.tenant_field_config_events, ' ||
      'orgunit.tenant_field_configs ' ||
      'FROM app_nobypassrls';
    EXECUTE 'GRANT SELECT ON TABLE ' ||
      'orgunit.tenant_field_config_events, ' ||
      'orgunit.tenant_field_configs ' ||
      'TO app_nobypassrls';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.tenant_field_config_events, ' ||
      'orgunit.tenant_field_configs ' ||
      'FROM superadmin_runtime';
    EXECUTE 'GRANT SELECT ON TABLE ' ||
      'orgunit.tenant_field_config_events, ' ||
      'orgunit.tenant_field_configs ' ||
      'TO superadmin_runtime';
  END IF;
END $$;


-- end: modules/orgunit/infrastructure/persistence/schema/00017_orgunit_field_configs_kernel_privileges.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00001_jobcatalog_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE SCHEMA IF NOT EXISTS jobcatalog;


-- end: modules/jobcatalog/infrastructure/persistence/schema/00001_jobcatalog_schema.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00002_jobcatalog_job_family_groups.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_family_groups (
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_family_group_uuid uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_family_group_code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_groups_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_groups_tenant_setid_code_key UNIQUE (tenant_uuid, job_family_group_code),
  CONSTRAINT job_family_groups_tenant_setid_id_unique UNIQUE (tenant_uuid, setid, job_family_group_uuid)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_group_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_family_group_uuid uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_group_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_group_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_family_group_events_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT job_family_group_events_one_per_day_unique UNIQUE (tenant_uuid, setid, job_family_group_uuid, effective_date),
  CONSTRAINT job_family_group_events_request_code_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT job_family_group_events_group_fk
    FOREIGN KEY (tenant_uuid, setid, job_family_group_uuid) REFERENCES jobcatalog.job_family_groups(tenant_uuid, setid, job_family_group_uuid) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_family_group_events_tenant_effective_idx
  ON jobcatalog.job_family_group_events (tenant_uuid, setid, job_family_group_uuid, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_group_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_family_group_uuid uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_family_group_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_group_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_group_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_family_group_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_family_group_versions_group_fk
    FOREIGN KEY (tenant_uuid, setid, job_family_group_uuid) REFERENCES jobcatalog.job_family_groups(tenant_uuid, setid, job_family_group_uuid) ON DELETE RESTRICT,
  CONSTRAINT job_family_group_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_family_group_uuid gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_family_group_versions_active_day_gist
  ON jobcatalog.job_family_group_versions
  USING gist (tenant_uuid gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_family_group_versions_lookup_btree
  ON jobcatalog.job_family_group_versions (tenant_uuid, setid, job_family_group_uuid, lower(validity));

ALTER TABLE jobcatalog.job_family_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_groups FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_groups;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_groups
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_group_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_group_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_group_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_group_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_group_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_group_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_group_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_group_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00002_jobcatalog_job_family_groups.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00003_jobcatalog_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.assert_current_tenant(p_tenant_uuid uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'tenant_uuid is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_uuid THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_uuid, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.normalize_package_uuid(p_package_uuid text)
RETURNS uuid
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v uuid;
BEGIN
  IF p_package_uuid IS NULL OR btrim(p_package_uuid) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'package_uuid is required';
  END IF;
  BEGIN
    v := btrim(p_package_uuid)::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('package_uuid=%s', p_package_uuid);
  END;
  RETURN v;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_group_versions(
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_job_family_group_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_package_uuid uuid;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_uuid, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_family_group_versions
  WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_family_group_uuid = p_job_family_group_uuid;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_family_group_events
    WHERE tenant_uuid = p_tenant_uuid
      AND package_uuid = v_package_uuid
      AND job_family_group_uuid = p_job_family_group_uuid
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb)
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_family_group_events e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.package_uuid = v_package_uuid
      AND e.job_family_group_uuid = p_job_family_group_uuid
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_family_group_versions (
      tenant_uuid,
      package_uuid,
      job_family_group_uuid,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_uuid,
      v_package_uuid,
      p_job_family_group_uuid,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_family_group_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND package_uuid = v_package_uuid
        AND job_family_group_uuid = p_job_family_group_uuid
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_family_group_uuid=%s', p_job_family_group_uuid);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_family_group_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND package_uuid = v_package_uuid
        AND job_family_group_uuid = p_job_family_group_uuid
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_family_group_uuid=%s', p_job_family_group_uuid);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_group_versions(
  p_tenant_uuid uuid,
  p_package_uuid uuid,
  p_job_family_group_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM jobcatalog.replay_job_family_group_versions(p_tenant_uuid, p_package_uuid::text, p_job_family_group_uuid);
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_family_group_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_job_family_group_uuid uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_package_uuid uuid;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_family_group_events%ROWTYPE;
  v_existing_group jobcatalog.job_family_groups%ROWTYPE;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_job_family_group_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_family_group_uuid is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_uuid, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('job_family_group_code', 'name', 'description', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'job_family_group_code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_group_code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'job_family_group_code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_group_code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_family_groups (tenant_uuid, package_uuid, job_family_group_uuid, job_family_group_code)
    VALUES (p_tenant_uuid, v_package_uuid, p_job_family_group_uuid, v_code)
    ON CONFLICT (job_family_group_uuid) DO NOTHING;

    SELECT * INTO v_existing_group
    FROM jobcatalog.job_family_groups
    WHERE job_family_group_uuid = p_job_family_group_uuid;

    IF v_existing_group.tenant_uuid <> p_tenant_uuid
      OR v_existing_group.package_uuid <> v_package_uuid
      OR v_existing_group.job_family_group_code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_family_group_uuid=%s', p_job_family_group_uuid);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_family_groups
      WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_family_group_uuid = p_job_family_group_uuid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_family_group_uuid=%s', p_job_family_group_uuid);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_family_group_events (
    event_uuid, tenant_uuid, package_uuid, job_family_group_uuid, event_type, effective_date, payload, request_code, initiator_uuid
  )
  VALUES (
    p_event_uuid, p_tenant_uuid, v_package_uuid, p_job_family_group_uuid, p_event_type, p_effective_date, v_payload, p_request_code, p_initiator_uuid
  )
  ON CONFLICT (event_uuid) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_family_group_events
    WHERE event_uuid = p_event_uuid;

    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.package_uuid <> v_package_uuid
      OR v_existing.job_family_group_uuid <> p_job_family_group_uuid
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_family_group_versions(p_tenant_uuid, v_package_uuid, p_job_family_group_uuid);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00003_jobcatalog_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00004_jobcatalog_job_families.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_families (
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_family_uuid uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_family_code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_families_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_families_tenant_setid_code_key UNIQUE (tenant_uuid, job_family_code),
  CONSTRAINT job_families_tenant_setid_id_unique UNIQUE (tenant_uuid, setid, job_family_uuid)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_family_uuid uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_family_events_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT job_family_events_one_per_day_unique UNIQUE (tenant_uuid, setid, job_family_uuid, effective_date),
  CONSTRAINT job_family_events_request_code_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT job_family_events_family_fk
    FOREIGN KEY (tenant_uuid, setid, job_family_uuid) REFERENCES jobcatalog.job_families(tenant_uuid, setid, job_family_uuid) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_family_events_tenant_effective_idx
  ON jobcatalog.job_family_events (tenant_uuid, setid, job_family_uuid, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_family_uuid uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  job_family_group_uuid uuid NOT NULL,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_family_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_family_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_family_versions_family_fk
    FOREIGN KEY (tenant_uuid, setid, job_family_uuid) REFERENCES jobcatalog.job_families(tenant_uuid, setid, job_family_uuid) ON DELETE RESTRICT,
  CONSTRAINT job_family_versions_group_fk
    FOREIGN KEY (tenant_uuid, setid, job_family_group_uuid) REFERENCES jobcatalog.job_family_groups(tenant_uuid, setid, job_family_group_uuid) ON DELETE RESTRICT,
  CONSTRAINT job_family_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_family_uuid gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_family_versions_active_day_gist
  ON jobcatalog.job_family_versions
  USING gist (tenant_uuid gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_family_versions_lookup_btree
  ON jobcatalog.job_family_versions (tenant_uuid, setid, job_family_uuid, lower(validity));

ALTER TABLE jobcatalog.job_families ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_families FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_families;
CREATE POLICY tenant_isolation ON jobcatalog.job_families
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00004_jobcatalog_job_families.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00005_jobcatalog_job_family_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_versions(
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_job_family_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_package_uuid uuid;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
  v_group_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_uuid, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_family_versions
  WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_family_uuid = p_job_family_uuid;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_family_events
    WHERE tenant_uuid = p_tenant_uuid
      AND package_uuid = v_package_uuid
      AND job_family_uuid = p_job_family_uuid
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_group_id := NULLIF(btrim(COALESCE(v_row.payload->>'job_family_group_uuid', '')), '')::uuid;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb),
        'job_family_group_uuid', v_group_id::text
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
      IF v_row.payload ? 'job_family_group_uuid' THEN
        v_state := jsonb_set(v_state, '{job_family_group_uuid}', to_jsonb(v_row.payload->>'job_family_group_uuid'), true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_family_events e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.package_uuid = v_package_uuid
      AND e.job_family_uuid = p_job_family_uuid
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_family_versions (
      tenant_uuid,
      package_uuid,
      job_family_uuid,
      validity,
      name,
      description,
      is_active,
      external_refs,
      job_family_group_uuid,
      last_event_id
    ) VALUES (
      p_tenant_uuid,
      v_package_uuid,
      p_job_family_uuid,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      NULLIF(btrim(COALESCE(v_state->>'job_family_group_uuid', '')), '')::uuid,
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_family_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND package_uuid = v_package_uuid
        AND job_family_uuid = p_job_family_uuid
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_family_uuid=%s', p_job_family_uuid);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_family_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND package_uuid = v_package_uuid
        AND job_family_uuid = p_job_family_uuid
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_family_uuid=%s', p_job_family_uuid);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_versions(
  p_tenant_uuid uuid,
  p_package_uuid uuid,
  p_job_family_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM jobcatalog.replay_job_family_versions(p_tenant_uuid, p_package_uuid::text, p_job_family_uuid);
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_family_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_job_family_uuid uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_package_uuid uuid;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_family_events%ROWTYPE;
  v_existing_family jobcatalog.job_families%ROWTYPE;
  v_group_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_job_family_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_family_uuid is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_uuid, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('job_family_code', 'name', 'description', 'external_refs', 'job_family_group_uuid')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'job_family_code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs', 'job_family_group_uuid')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF v_payload ? 'job_family_group_uuid' AND NULLIF(btrim(COALESCE(v_payload->>'job_family_group_uuid', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_group_uuid must be non-empty';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs' OR v_payload ? 'job_family_group_uuid') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'job_family_code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_code/name is required';
    END IF;

    BEGIN
      v_group_id := NULLIF(btrim(COALESCE(v_payload->>'job_family_group_uuid', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_group_uuid must be uuid';
    END;

    IF v_group_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_group_uuid is required';
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_family_groups
      WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_family_group_uuid = v_group_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_group_uuid=%s', v_group_id);
    END IF;

    INSERT INTO jobcatalog.job_families (tenant_uuid, package_uuid, job_family_uuid, job_family_code)
    VALUES (p_tenant_uuid, v_package_uuid, p_job_family_uuid, v_code)
    ON CONFLICT (job_family_uuid) DO NOTHING;

    SELECT * INTO v_existing_family
    FROM jobcatalog.job_families
    WHERE job_family_uuid = p_job_family_uuid;

    IF v_existing_family.tenant_uuid <> p_tenant_uuid
      OR v_existing_family.package_uuid <> v_package_uuid
      OR v_existing_family.job_family_code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_family_uuid=%s', p_job_family_uuid);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_families
      WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_family_uuid = p_job_family_uuid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_family_uuid=%s', p_job_family_uuid);
    END IF;
  END IF;

  IF (p_event_type = 'CREATE' OR p_event_type = 'UPDATE') AND v_payload ? 'job_family_group_uuid' THEN
    BEGIN
      v_group_id := NULLIF(btrim(COALESCE(v_payload->>'job_family_group_uuid', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_group_uuid must be uuid';
    END;

    IF v_group_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_group_uuid must be non-empty';
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_family_groups
      WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_family_group_uuid = v_group_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_group_uuid=%s', v_group_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_family_events (
    event_uuid, tenant_uuid, package_uuid, job_family_uuid, event_type, effective_date, payload, request_code, initiator_uuid
  )
  VALUES (
    p_event_uuid, p_tenant_uuid, v_package_uuid, p_job_family_uuid, p_event_type, p_effective_date, v_payload, p_request_code, p_initiator_uuid
  )
  ON CONFLICT (event_uuid) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_family_events
    WHERE event_uuid = p_event_uuid;

    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.package_uuid <> v_package_uuid
      OR v_existing.job_family_uuid <> p_job_family_uuid
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_family_versions(p_tenant_uuid, v_package_uuid, p_job_family_uuid);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00005_jobcatalog_job_family_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00006_jobcatalog_job_levels.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_levels (
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_level_uuid uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_level_code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_levels_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_levels_tenant_setid_code_key UNIQUE (tenant_uuid, job_level_code),
  CONSTRAINT job_levels_tenant_setid_id_unique UNIQUE (tenant_uuid, setid, job_level_uuid)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_level_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_level_uuid uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_level_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_level_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_level_events_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT job_level_events_one_per_day_unique UNIQUE (tenant_uuid, setid, job_level_uuid, effective_date),
  CONSTRAINT job_level_events_request_code_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT job_level_events_level_fk
    FOREIGN KEY (tenant_uuid, setid, job_level_uuid) REFERENCES jobcatalog.job_levels(tenant_uuid, setid, job_level_uuid) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_level_events_tenant_effective_idx
  ON jobcatalog.job_level_events (tenant_uuid, setid, job_level_uuid, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_level_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_level_uuid uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_level_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_level_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_level_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_level_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_level_versions_level_fk
    FOREIGN KEY (tenant_uuid, setid, job_level_uuid) REFERENCES jobcatalog.job_levels(tenant_uuid, setid, job_level_uuid) ON DELETE RESTRICT,
  CONSTRAINT job_level_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_level_uuid gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_level_versions_active_day_gist
  ON jobcatalog.job_level_versions
  USING gist (tenant_uuid gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_level_versions_lookup_btree
  ON jobcatalog.job_level_versions (tenant_uuid, setid, job_level_uuid, lower(validity));

ALTER TABLE jobcatalog.job_levels ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_levels FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_levels;
CREATE POLICY tenant_isolation ON jobcatalog.job_levels
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_level_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_level_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_level_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_level_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_level_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_level_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_level_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_level_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00006_jobcatalog_job_levels.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00007_jobcatalog_job_level_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_level_versions(
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_job_level_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_package_uuid uuid;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_uuid, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_level_versions
  WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_level_uuid = p_job_level_uuid;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_level_events
    WHERE tenant_uuid = p_tenant_uuid
      AND package_uuid = v_package_uuid
      AND job_level_uuid = p_job_level_uuid
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb)
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_level_events e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.package_uuid = v_package_uuid
      AND e.job_level_uuid = p_job_level_uuid
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_level_versions (
      tenant_uuid,
      package_uuid,
      job_level_uuid,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_uuid,
      v_package_uuid,
      p_job_level_uuid,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_level_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND package_uuid = v_package_uuid
        AND job_level_uuid = p_job_level_uuid
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_level_uuid=%s', p_job_level_uuid);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_level_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND package_uuid = v_package_uuid
        AND job_level_uuid = p_job_level_uuid
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_level_uuid=%s', p_job_level_uuid);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_level_versions(
  p_tenant_uuid uuid,
  p_package_uuid uuid,
  p_job_level_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM jobcatalog.replay_job_level_versions(p_tenant_uuid, p_package_uuid::text, p_job_level_uuid);
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_level_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_job_level_uuid uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_package_uuid uuid;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_level_events%ROWTYPE;
  v_existing_level jobcatalog.job_levels%ROWTYPE;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_job_level_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_level_uuid is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_uuid, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('job_level_code', 'name', 'description', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'job_level_code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_level_code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'job_level_code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_level_code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_levels (tenant_uuid, package_uuid, job_level_uuid, job_level_code)
    VALUES (p_tenant_uuid, v_package_uuid, p_job_level_uuid, v_code)
    ON CONFLICT (job_level_uuid) DO NOTHING;

    SELECT * INTO v_existing_level
    FROM jobcatalog.job_levels
    WHERE job_level_uuid = p_job_level_uuid;

    IF v_existing_level.tenant_uuid <> p_tenant_uuid
      OR v_existing_level.package_uuid <> v_package_uuid
      OR v_existing_level.job_level_code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_level_uuid=%s', p_job_level_uuid);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_levels
      WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_level_uuid = p_job_level_uuid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_level_uuid=%s', p_job_level_uuid);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_level_events (
    event_uuid, tenant_uuid, package_uuid, job_level_uuid, event_type, effective_date, payload, request_code, initiator_uuid
  )
  VALUES (
    p_event_uuid, p_tenant_uuid, v_package_uuid, p_job_level_uuid, p_event_type, p_effective_date, v_payload, p_request_code, p_initiator_uuid
  )
  ON CONFLICT (event_uuid) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_level_events
    WHERE event_uuid = p_event_uuid;

    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.package_uuid <> v_package_uuid
      OR v_existing.job_level_uuid <> p_job_level_uuid
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_level_versions(p_tenant_uuid, v_package_uuid, p_job_level_uuid);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00007_jobcatalog_job_level_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00008_jobcatalog_job_profiles.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_profiles (
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_profile_uuid uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_profile_code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profiles_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_profiles_tenant_setid_code_key UNIQUE (tenant_uuid, job_profile_code),
  CONSTRAINT job_profiles_tenant_setid_id_unique UNIQUE (tenant_uuid, setid, job_profile_uuid)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_profile_uuid uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_profile_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_profile_events_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT job_profile_events_one_per_day_unique UNIQUE (tenant_uuid, setid, job_profile_uuid, effective_date),
  CONSTRAINT job_profile_events_request_code_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT job_profile_events_profile_fk
    FOREIGN KEY (tenant_uuid, setid, job_profile_uuid) REFERENCES jobcatalog.job_profiles(tenant_uuid, setid, job_profile_uuid) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_profile_events_tenant_effective_idx
  ON jobcatalog.job_profile_events (tenant_uuid, setid, job_profile_uuid, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_profile_uuid uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_profile_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_profile_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_profile_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_profile_versions_profile_fk
    FOREIGN KEY (tenant_uuid, setid, job_profile_uuid) REFERENCES jobcatalog.job_profiles(tenant_uuid, setid, job_profile_uuid) ON DELETE RESTRICT,
  CONSTRAINT job_profile_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_profile_uuid gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_profile_versions_active_day_gist
  ON jobcatalog.job_profile_versions
  USING gist (tenant_uuid gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_profile_versions_lookup_btree
  ON jobcatalog.job_profile_versions (tenant_uuid, setid, job_profile_uuid, lower(validity));

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_version_job_families (
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  job_profile_version_id bigint NOT NULL,
  job_family_uuid uuid NOT NULL,
  is_primary boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_version_job_families_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_profile_version_job_families_version_fk
    FOREIGN KEY (job_profile_version_id) REFERENCES jobcatalog.job_profile_versions(id) ON DELETE CASCADE,
  CONSTRAINT job_profile_version_job_families_family_fk
    FOREIGN KEY (tenant_uuid, setid, job_family_uuid) REFERENCES jobcatalog.job_families(tenant_uuid, setid, job_family_uuid) ON DELETE RESTRICT,
  CONSTRAINT job_profile_version_job_families_unique UNIQUE (tenant_uuid, setid, job_profile_version_id, job_family_uuid)
);

CREATE UNIQUE INDEX IF NOT EXISTS job_profile_version_job_families_one_primary_unique
  ON jobcatalog.job_profile_version_job_families (tenant_uuid, setid, job_profile_version_id)
  WHERE is_primary = true;

CREATE INDEX IF NOT EXISTS job_profile_version_job_families_family_lookup_btree
  ON jobcatalog.job_profile_version_job_families (tenant_uuid, setid, job_family_uuid);

ALTER TABLE jobcatalog.job_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profiles FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profiles;
CREATE POLICY tenant_isolation ON jobcatalog.job_profiles
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_version_job_families ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_version_job_families FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_version_job_families;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_version_job_families
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00008_jobcatalog_job_profiles.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00009_jobcatalog_job_profile_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_profile_versions(
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_job_profile_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_package_uuid uuid;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
  v_version_id bigint;
  v_family_ids uuid[];
  v_primary_family_id uuid;
  v_family_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_uuid, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_profile_versions
  WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_profile_uuid = p_job_profile_uuid;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_profile_events
    WHERE tenant_uuid = p_tenant_uuid
      AND package_uuid = v_package_uuid
      AND job_profile_uuid = p_job_profile_uuid
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb),
        'job_family_uuids', COALESCE(v_row.payload->'job_family_uuids', '[]'::jsonb),
        'primary_job_family_uuid', v_row.payload->>'primary_job_family_uuid'
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
      IF v_row.payload ? 'job_family_uuids' THEN
        v_state := jsonb_set(v_state, '{job_family_uuids}', v_row.payload->'job_family_uuids', true);
      END IF;
      IF v_row.payload ? 'primary_job_family_uuid' THEN
        v_state := jsonb_set(v_state, '{primary_job_family_uuid}', to_jsonb(v_row.payload->>'primary_job_family_uuid'), true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    IF jsonb_typeof(v_state->'job_family_uuids') <> 'array' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_uuids must be an array';
    END IF;
    IF jsonb_array_length(COALESCE(v_state->'job_family_uuids', '[]'::jsonb)) = 0 THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_uuids must be non-empty';
    END IF;

    BEGIN
      SELECT array_agg(NULLIF(btrim(value), '')::uuid) INTO v_family_ids
      FROM jsonb_array_elements_text(v_state->'job_family_uuids') AS t(value);
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_uuids contains invalid uuid';
    END;
    IF v_family_ids IS NULL OR array_length(v_family_ids, 1) IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_uuids must be non-empty';
    END IF;
    IF (SELECT count(*) <> count(DISTINCT id) FROM unnest(v_family_ids) AS t(id)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_uuids contains duplicates';
    END IF;

    BEGIN
      v_primary_family_id := NULLIF(btrim(COALESCE(v_state->>'primary_job_family_uuid', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'primary_job_family_uuid is invalid';
    END;
    IF v_primary_family_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'primary_job_family_uuid is required';
    END IF;
    IF NOT (v_primary_family_id = ANY(v_family_ids)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'primary_job_family_uuid must be included in job_family_uuids';
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_profile_events e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.package_uuid = v_package_uuid
      AND e.job_profile_uuid = p_job_profile_uuid
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_profile_versions (
      tenant_uuid,
      package_uuid,
      job_profile_uuid,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_uuid,
      v_package_uuid,
      p_job_profile_uuid,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    )
    RETURNING id INTO v_version_id;

    FOREACH v_family_id IN ARRAY v_family_ids LOOP
      INSERT INTO jobcatalog.job_profile_version_job_families (
        tenant_uuid,
        package_uuid,
        job_profile_version_id,
        job_family_uuid,
        is_primary
      ) VALUES (
        p_tenant_uuid,
        v_package_uuid,
        v_version_id,
        v_family_id,
        v_family_id = v_primary_family_id
      );
    END LOOP;

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_profile_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND package_uuid = v_package_uuid
        AND job_profile_uuid = p_job_profile_uuid
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_profile_uuid=%s', p_job_profile_uuid);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_profile_versions
      WHERE tenant_uuid = p_tenant_uuid
        AND package_uuid = v_package_uuid
        AND job_profile_uuid = p_job_profile_uuid
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_profile_uuid=%s', p_job_profile_uuid);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_profile_versions(
  p_tenant_uuid uuid,
  p_package_uuid uuid,
  p_job_profile_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM jobcatalog.replay_job_profile_versions(p_tenant_uuid, p_package_uuid::text, p_job_profile_uuid);
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_profile_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_job_profile_uuid uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_package_uuid uuid;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_profile_events%ROWTYPE;
  v_existing_profile jobcatalog.job_profiles%ROWTYPE;
  v_family_ids uuid[];
  v_primary_family_id uuid;
  v_missing_family_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_job_profile_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_profile_uuid is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_uuid, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('job_profile_code', 'name', 'description', 'external_refs', 'job_family_uuids', 'primary_job_family_uuid')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF jsonb_typeof(v_payload->'job_family_uuids') <> 'array' OR jsonb_array_length(v_payload->'job_family_uuids') = 0 THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_uuids must be a non-empty array';
    END IF;
    IF NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_uuid', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_uuid is required';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'job_profile_code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_profile_code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs', 'job_family_uuids', 'primary_job_family_uuid')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF v_payload ? 'job_family_uuids' THEN
      IF jsonb_typeof(v_payload->'job_family_uuids') <> 'array' OR jsonb_array_length(v_payload->'job_family_uuids') = 0 THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.job_family_uuids must be a non-empty array';
      END IF;
      IF NOT (v_payload ? 'primary_job_family_uuid') THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.primary_job_family_uuid is required when job_family_uuids is present';
      END IF;
    END IF;
    IF v_payload ? 'primary_job_family_uuid' AND NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_uuid', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_uuid must be non-empty';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs' OR v_payload ? 'job_family_uuids' OR v_payload ? 'primary_job_family_uuid') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF v_payload ? 'job_family_uuids' THEN
    BEGIN
      SELECT array_agg(NULLIF(btrim(value), '')::uuid) INTO v_family_ids
      FROM jsonb_array_elements_text(v_payload->'job_family_uuids') AS t(value);
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.job_family_uuids contains invalid uuid';
    END;
    IF v_family_ids IS NULL OR array_length(v_family_ids, 1) IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_uuids must be non-empty';
    END IF;
    IF (SELECT count(*) <> count(DISTINCT id) FROM unnest(v_family_ids) AS t(id)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_uuids contains duplicates';
    END IF;
  END IF;

  IF v_payload ? 'primary_job_family_uuid' THEN
    BEGIN
      v_primary_family_id := NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_uuid', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.primary_job_family_uuid is invalid';
    END;
    IF v_primary_family_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_uuid must be non-empty';
    END IF;
  END IF;

  IF v_family_ids IS NOT NULL AND v_primary_family_id IS NOT NULL THEN
    IF NOT (v_primary_family_id = ANY(v_family_ids)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_uuid must be included in payload.job_family_uuids';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'job_profile_code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_profile_code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_profiles (tenant_uuid, package_uuid, job_profile_uuid, job_profile_code)
    VALUES (p_tenant_uuid, v_package_uuid, p_job_profile_uuid, v_code)
    ON CONFLICT (job_profile_uuid) DO NOTHING;

    SELECT * INTO v_existing_profile
    FROM jobcatalog.job_profiles
    WHERE job_profile_uuid = p_job_profile_uuid;

    IF v_existing_profile.tenant_uuid <> p_tenant_uuid
      OR v_existing_profile.package_uuid <> v_package_uuid
      OR v_existing_profile.job_profile_code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_profile_uuid=%s', p_job_profile_uuid);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_profiles
      WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_profile_uuid = p_job_profile_uuid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_profile_uuid=%s', p_job_profile_uuid);
    END IF;
  END IF;

  IF v_family_ids IS NOT NULL THEN
    SELECT missing.job_family_uuid INTO v_missing_family_id
    FROM (
      SELECT t.id AS job_family_uuid
      FROM unnest(v_family_ids) AS t(id)
      LEFT JOIN jobcatalog.job_families f
        ON f.tenant_uuid = p_tenant_uuid
       AND f.package_uuid = v_package_uuid
       AND f.job_family_uuid = t.id
      WHERE f.job_family_uuid IS NULL
      LIMIT 1
    ) missing;
    IF v_missing_family_id IS NOT NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_uuid=%s', v_missing_family_id);
    END IF;
  END IF;

  IF v_primary_family_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_families
      WHERE tenant_uuid = p_tenant_uuid AND package_uuid = v_package_uuid AND job_family_uuid = v_primary_family_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_uuid=%s', v_primary_family_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_profile_events (
    event_uuid, tenant_uuid, package_uuid, job_profile_uuid, event_type, effective_date, payload, request_code, initiator_uuid
  )
  VALUES (
    p_event_uuid, p_tenant_uuid, v_package_uuid, p_job_profile_uuid, p_event_type, p_effective_date, v_payload, p_request_code, p_initiator_uuid
  )
  ON CONFLICT (event_uuid) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_profile_events
    WHERE event_uuid = p_event_uuid;

    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.package_uuid <> v_package_uuid
      OR v_existing.job_profile_uuid <> p_job_profile_uuid
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_profile_versions(p_tenant_uuid, v_package_uuid, p_job_profile_uuid);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00009_jobcatalog_job_profile_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00010_jobcatalog_read.sql
CREATE OR REPLACE FUNCTION jobcatalog.get_job_catalog_snapshot(
  p_tenant_uuid uuid,
  p_package_uuid text,
  p_query_date date
)
RETURNS TABLE (
  groups jsonb,
  families jsonb,
  levels jsonb,
  profiles jsonb
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_package_uuid uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_uuid);
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  v_package_uuid := jobcatalog.normalize_package_uuid(p_package_uuid);

  RETURN QUERY
  SELECT
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_family_group_uuid', g.job_family_group_uuid,
          'job_family_group_code', g.job_family_group_code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY g.job_family_group_code
      )
      FROM jobcatalog.job_family_groups g
      JOIN jobcatalog.job_family_group_versions v
        ON v.tenant_uuid = p_tenant_uuid
       AND v.package_uuid = v_package_uuid
       AND v.job_family_group_uuid = g.job_family_group_uuid
       AND v.validity @> p_query_date
      WHERE g.tenant_uuid = p_tenant_uuid
        AND g.package_uuid = v_package_uuid
    ), '[]'::jsonb) AS groups,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_family_uuid', f.job_family_uuid,
          'job_family_code', f.job_family_code,
          'job_family_group_uuid', v.job_family_group_uuid,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY f.job_family_code
      )
      FROM jobcatalog.job_families f
      JOIN jobcatalog.job_family_versions v
        ON v.tenant_uuid = p_tenant_uuid
       AND v.package_uuid = v_package_uuid
       AND v.job_family_uuid = f.job_family_uuid
       AND v.validity @> p_query_date
      WHERE f.tenant_uuid = p_tenant_uuid
        AND f.package_uuid = v_package_uuid
    ), '[]'::jsonb) AS families,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_level_uuid', l.job_level_uuid,
          'job_level_code', l.job_level_code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY l.job_level_code
      )
      FROM jobcatalog.job_levels l
      JOIN jobcatalog.job_level_versions v
        ON v.tenant_uuid = p_tenant_uuid
       AND v.package_uuid = v_package_uuid
       AND v.job_level_uuid = l.job_level_uuid
       AND v.validity @> p_query_date
      WHERE l.tenant_uuid = p_tenant_uuid
        AND l.package_uuid = v_package_uuid
    ), '[]'::jsonb) AS levels,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_profile_uuid', p.job_profile_uuid,
          'job_profile_code', p.job_profile_code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id,
          'job_family_uuids', COALESCE(fam.job_family_uuids, '[]'::jsonb),
          'primary_job_family_uuid', fam.primary_job_family_uuid
        )
        ORDER BY p.job_profile_code
      )
      FROM jobcatalog.job_profiles p
      JOIN jobcatalog.job_profile_versions v
        ON v.tenant_uuid = p_tenant_uuid
       AND v.package_uuid = v_package_uuid
       AND v.job_profile_uuid = p.job_profile_uuid
       AND v.validity @> p_query_date
      LEFT JOIN LATERAL (
        SELECT
          jsonb_agg(f.job_family_uuid ORDER BY f.job_family_uuid) AS job_family_uuids,
          (
            SELECT f2.job_family_uuid
            FROM jobcatalog.job_profile_version_job_families f2
            WHERE f2.tenant_uuid = p_tenant_uuid
              AND f2.package_uuid = v_package_uuid
              AND f2.job_profile_version_id = v.id
              AND f2.is_primary = true
            LIMIT 1
          ) AS primary_job_family_uuid
        FROM jobcatalog.job_profile_version_job_families f
        WHERE f.tenant_uuid = p_tenant_uuid
          AND f.package_uuid = v_package_uuid
          AND f.job_profile_version_id = v.id
      ) fam ON true
      WHERE p.tenant_uuid = p_tenant_uuid
        AND p.package_uuid = v_package_uuid
    ), '[]'::jsonb) AS profiles;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00010_jobcatalog_read.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00011_jobcatalog_package_id_schema.sql
ALTER TABLE jobcatalog.job_family_groups
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_family_groups
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_groups
  DROP CONSTRAINT IF EXISTS job_family_groups_setid_format_check;
ALTER TABLE jobcatalog.job_family_groups
  DROP CONSTRAINT IF EXISTS job_family_groups_tenant_setid_code_key;
ALTER TABLE jobcatalog.job_family_groups
  DROP CONSTRAINT IF EXISTS job_family_groups_tenant_setid_id_unique CASCADE;
ALTER TABLE jobcatalog.job_family_groups
  ADD CONSTRAINT job_family_groups_tenant_pkg_code_key UNIQUE (tenant_uuid, package_uuid, job_family_group_code);
ALTER TABLE jobcatalog.job_family_groups
  ADD CONSTRAINT job_family_groups_tenant_pkg_id_unique UNIQUE (tenant_uuid, package_uuid, job_family_group_uuid);

ALTER TABLE jobcatalog.job_family_group_events
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_family_group_events
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_group_events
  DROP CONSTRAINT IF EXISTS job_family_group_events_setid_format_check;
ALTER TABLE jobcatalog.job_family_group_events
  DROP CONSTRAINT IF EXISTS job_family_group_events_one_per_day_unique;
ALTER TABLE jobcatalog.job_family_group_events
  DROP CONSTRAINT IF EXISTS job_family_group_events_group_fk;
ALTER TABLE jobcatalog.job_family_group_events
  ADD CONSTRAINT job_family_group_events_one_per_day_unique UNIQUE (tenant_uuid, package_uuid, job_family_group_uuid, effective_date);
ALTER TABLE jobcatalog.job_family_group_events
  ADD CONSTRAINT job_family_group_events_group_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_family_group_uuid)
    REFERENCES jobcatalog.job_family_groups(tenant_uuid, package_uuid, job_family_group_uuid) ON DELETE RESTRICT;

DROP INDEX IF EXISTS jobcatalog.job_family_group_events_tenant_effective_idx;
CREATE INDEX IF NOT EXISTS job_family_group_events_tenant_effective_idx
  ON jobcatalog.job_family_group_events (tenant_uuid, package_uuid, job_family_group_uuid, effective_date, id);

ALTER TABLE jobcatalog.job_family_group_versions
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_family_group_versions
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_group_versions
  DROP CONSTRAINT IF EXISTS job_family_group_versions_setid_format_check;
ALTER TABLE jobcatalog.job_family_group_versions
  DROP CONSTRAINT IF EXISTS job_family_group_versions_group_fk;
ALTER TABLE jobcatalog.job_family_group_versions
  DROP CONSTRAINT IF EXISTS job_family_group_versions_no_overlap;
ALTER TABLE jobcatalog.job_family_group_versions
  ADD CONSTRAINT job_family_group_versions_group_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_family_group_uuid)
    REFERENCES jobcatalog.job_family_groups(tenant_uuid, package_uuid, job_family_group_uuid) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_family_group_versions
  ADD CONSTRAINT job_family_group_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      package_uuid gist_uuid_ops WITH =,
      job_family_group_uuid gist_uuid_ops WITH =,
      validity WITH &&
    );

DROP INDEX IF EXISTS jobcatalog.job_family_group_versions_active_day_gist;
CREATE INDEX IF NOT EXISTS job_family_group_versions_active_day_gist
  ON jobcatalog.job_family_group_versions
  USING gist (tenant_uuid gist_uuid_ops, package_uuid gist_uuid_ops, validity)
  WHERE is_active = true;

DROP INDEX IF EXISTS jobcatalog.job_family_group_versions_lookup_btree;
CREATE INDEX IF NOT EXISTS job_family_group_versions_lookup_btree
  ON jobcatalog.job_family_group_versions (tenant_uuid, package_uuid, job_family_group_uuid, lower(validity));

ALTER TABLE jobcatalog.job_families
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_families
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_families
  DROP CONSTRAINT IF EXISTS job_families_setid_format_check;
ALTER TABLE jobcatalog.job_families
  DROP CONSTRAINT IF EXISTS job_families_tenant_setid_code_key;
ALTER TABLE jobcatalog.job_families
  DROP CONSTRAINT IF EXISTS job_families_tenant_setid_id_unique CASCADE;
ALTER TABLE jobcatalog.job_families
  ADD CONSTRAINT job_families_tenant_pkg_code_key UNIQUE (tenant_uuid, package_uuid, job_family_code);
ALTER TABLE jobcatalog.job_families
  ADD CONSTRAINT job_families_tenant_pkg_id_unique UNIQUE (tenant_uuid, package_uuid, job_family_uuid);

ALTER TABLE jobcatalog.job_family_events
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_family_events
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_events
  DROP CONSTRAINT IF EXISTS job_family_events_setid_format_check;
ALTER TABLE jobcatalog.job_family_events
  DROP CONSTRAINT IF EXISTS job_family_events_one_per_day_unique;
ALTER TABLE jobcatalog.job_family_events
  DROP CONSTRAINT IF EXISTS job_family_events_family_fk;
ALTER TABLE jobcatalog.job_family_events
  ADD CONSTRAINT job_family_events_one_per_day_unique UNIQUE (tenant_uuid, package_uuid, job_family_uuid, effective_date);
ALTER TABLE jobcatalog.job_family_events
  ADD CONSTRAINT job_family_events_family_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_family_uuid)
    REFERENCES jobcatalog.job_families(tenant_uuid, package_uuid, job_family_uuid) ON DELETE RESTRICT;

DROP INDEX IF EXISTS jobcatalog.job_family_events_tenant_effective_idx;
CREATE INDEX IF NOT EXISTS job_family_events_tenant_effective_idx
  ON jobcatalog.job_family_events (tenant_uuid, package_uuid, job_family_uuid, effective_date, id);

ALTER TABLE jobcatalog.job_family_versions
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_family_versions
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_versions
  DROP CONSTRAINT IF EXISTS job_family_versions_setid_format_check;
ALTER TABLE jobcatalog.job_family_versions
  DROP CONSTRAINT IF EXISTS job_family_versions_family_fk;
ALTER TABLE jobcatalog.job_family_versions
  DROP CONSTRAINT IF EXISTS job_family_versions_group_fk;
ALTER TABLE jobcatalog.job_family_versions
  DROP CONSTRAINT IF EXISTS job_family_versions_no_overlap;
ALTER TABLE jobcatalog.job_family_versions
  ADD CONSTRAINT job_family_versions_family_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_family_uuid)
    REFERENCES jobcatalog.job_families(tenant_uuid, package_uuid, job_family_uuid) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_family_versions
  ADD CONSTRAINT job_family_versions_group_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_family_group_uuid)
    REFERENCES jobcatalog.job_family_groups(tenant_uuid, package_uuid, job_family_group_uuid) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_family_versions
  ADD CONSTRAINT job_family_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      package_uuid gist_uuid_ops WITH =,
      job_family_uuid gist_uuid_ops WITH =,
      validity WITH &&
    );

DROP INDEX IF EXISTS jobcatalog.job_family_versions_active_day_gist;
CREATE INDEX IF NOT EXISTS job_family_versions_active_day_gist
  ON jobcatalog.job_family_versions
  USING gist (tenant_uuid gist_uuid_ops, package_uuid gist_uuid_ops, validity)
  WHERE is_active = true;

DROP INDEX IF EXISTS jobcatalog.job_family_versions_lookup_btree;
CREATE INDEX IF NOT EXISTS job_family_versions_lookup_btree
  ON jobcatalog.job_family_versions (tenant_uuid, package_uuid, job_family_uuid, lower(validity));

ALTER TABLE jobcatalog.job_levels
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_levels
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_levels
  DROP CONSTRAINT IF EXISTS job_levels_setid_format_check;
ALTER TABLE jobcatalog.job_levels
  DROP CONSTRAINT IF EXISTS job_levels_tenant_setid_code_key;
ALTER TABLE jobcatalog.job_levels
  DROP CONSTRAINT IF EXISTS job_levels_tenant_setid_id_unique CASCADE;
ALTER TABLE jobcatalog.job_levels
  ADD CONSTRAINT job_levels_tenant_pkg_code_key UNIQUE (tenant_uuid, package_uuid, job_level_code);
ALTER TABLE jobcatalog.job_levels
  ADD CONSTRAINT job_levels_tenant_pkg_id_unique UNIQUE (tenant_uuid, package_uuid, job_level_uuid);

ALTER TABLE jobcatalog.job_level_events
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_level_events
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_level_events
  DROP CONSTRAINT IF EXISTS job_level_events_setid_format_check;
ALTER TABLE jobcatalog.job_level_events
  DROP CONSTRAINT IF EXISTS job_level_events_one_per_day_unique;
ALTER TABLE jobcatalog.job_level_events
  DROP CONSTRAINT IF EXISTS job_level_events_level_fk;
ALTER TABLE jobcatalog.job_level_events
  ADD CONSTRAINT job_level_events_one_per_day_unique UNIQUE (tenant_uuid, package_uuid, job_level_uuid, effective_date);
ALTER TABLE jobcatalog.job_level_events
  ADD CONSTRAINT job_level_events_level_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_level_uuid)
    REFERENCES jobcatalog.job_levels(tenant_uuid, package_uuid, job_level_uuid) ON DELETE RESTRICT;

DROP INDEX IF EXISTS jobcatalog.job_level_events_tenant_effective_idx;
CREATE INDEX IF NOT EXISTS job_level_events_tenant_effective_idx
  ON jobcatalog.job_level_events (tenant_uuid, package_uuid, job_level_uuid, effective_date, id);

ALTER TABLE jobcatalog.job_level_versions
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_level_versions
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_level_versions
  DROP CONSTRAINT IF EXISTS job_level_versions_setid_format_check;
ALTER TABLE jobcatalog.job_level_versions
  DROP CONSTRAINT IF EXISTS job_level_versions_level_fk;
ALTER TABLE jobcatalog.job_level_versions
  DROP CONSTRAINT IF EXISTS job_level_versions_no_overlap;
ALTER TABLE jobcatalog.job_level_versions
  ADD CONSTRAINT job_level_versions_level_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_level_uuid)
    REFERENCES jobcatalog.job_levels(tenant_uuid, package_uuid, job_level_uuid) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_level_versions
  ADD CONSTRAINT job_level_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      package_uuid gist_uuid_ops WITH =,
      job_level_uuid gist_uuid_ops WITH =,
      validity WITH &&
    );

DROP INDEX IF EXISTS jobcatalog.job_level_versions_active_day_gist;
CREATE INDEX IF NOT EXISTS job_level_versions_active_day_gist
  ON jobcatalog.job_level_versions
  USING gist (tenant_uuid gist_uuid_ops, package_uuid gist_uuid_ops, validity)
  WHERE is_active = true;

DROP INDEX IF EXISTS jobcatalog.job_level_versions_lookup_btree;
CREATE INDEX IF NOT EXISTS job_level_versions_lookup_btree
  ON jobcatalog.job_level_versions (tenant_uuid, package_uuid, job_level_uuid, lower(validity));

ALTER TABLE jobcatalog.job_profiles
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_profiles
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_profiles
  DROP CONSTRAINT IF EXISTS job_profiles_setid_format_check;
ALTER TABLE jobcatalog.job_profiles
  DROP CONSTRAINT IF EXISTS job_profiles_tenant_setid_code_key;
ALTER TABLE jobcatalog.job_profiles
  DROP CONSTRAINT IF EXISTS job_profiles_tenant_setid_id_unique CASCADE;
ALTER TABLE jobcatalog.job_profiles
  ADD CONSTRAINT job_profiles_tenant_pkg_code_key UNIQUE (tenant_uuid, package_uuid, job_profile_code);
ALTER TABLE jobcatalog.job_profiles
  ADD CONSTRAINT job_profiles_tenant_pkg_id_unique UNIQUE (tenant_uuid, package_uuid, job_profile_uuid);

ALTER TABLE jobcatalog.job_profile_events
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_profile_events
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_profile_events
  DROP CONSTRAINT IF EXISTS job_profile_events_setid_format_check;
ALTER TABLE jobcatalog.job_profile_events
  DROP CONSTRAINT IF EXISTS job_profile_events_one_per_day_unique;
ALTER TABLE jobcatalog.job_profile_events
  DROP CONSTRAINT IF EXISTS job_profile_events_profile_fk;
ALTER TABLE jobcatalog.job_profile_events
  ADD CONSTRAINT job_profile_events_one_per_day_unique UNIQUE (tenant_uuid, package_uuid, job_profile_uuid, effective_date);
ALTER TABLE jobcatalog.job_profile_events
  ADD CONSTRAINT job_profile_events_profile_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_profile_uuid)
    REFERENCES jobcatalog.job_profiles(tenant_uuid, package_uuid, job_profile_uuid) ON DELETE RESTRICT;

DROP INDEX IF EXISTS jobcatalog.job_profile_events_tenant_effective_idx;
CREATE INDEX IF NOT EXISTS job_profile_events_tenant_effective_idx
  ON jobcatalog.job_profile_events (tenant_uuid, package_uuid, job_profile_uuid, effective_date, id);

ALTER TABLE jobcatalog.job_profile_versions
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_profile_versions
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_profile_versions
  DROP CONSTRAINT IF EXISTS job_profile_versions_setid_format_check;
ALTER TABLE jobcatalog.job_profile_versions
  DROP CONSTRAINT IF EXISTS job_profile_versions_profile_fk;
ALTER TABLE jobcatalog.job_profile_versions
  DROP CONSTRAINT IF EXISTS job_profile_versions_no_overlap;
ALTER TABLE jobcatalog.job_profile_versions
  ADD CONSTRAINT job_profile_versions_profile_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_profile_uuid)
    REFERENCES jobcatalog.job_profiles(tenant_uuid, package_uuid, job_profile_uuid) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_profile_versions
  ADD CONSTRAINT job_profile_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      package_uuid gist_uuid_ops WITH =,
      job_profile_uuid gist_uuid_ops WITH =,
      validity WITH &&
    );

DROP INDEX IF EXISTS jobcatalog.job_profile_versions_active_day_gist;
CREATE INDEX IF NOT EXISTS job_profile_versions_active_day_gist
  ON jobcatalog.job_profile_versions
  USING gist (tenant_uuid gist_uuid_ops, package_uuid gist_uuid_ops, validity)
  WHERE is_active = true;

DROP INDEX IF EXISTS jobcatalog.job_profile_versions_lookup_btree;
CREATE INDEX IF NOT EXISTS job_profile_versions_lookup_btree
  ON jobcatalog.job_profile_versions (tenant_uuid, package_uuid, job_profile_uuid, lower(validity));

ALTER TABLE jobcatalog.job_profile_version_job_families
  ADD COLUMN package_uuid uuid;
ALTER TABLE jobcatalog.job_profile_version_job_families
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_profile_version_job_families
  DROP CONSTRAINT IF EXISTS job_profile_version_job_families_setid_format_check;
ALTER TABLE jobcatalog.job_profile_version_job_families
  DROP CONSTRAINT IF EXISTS job_profile_version_job_families_family_fk;
ALTER TABLE jobcatalog.job_profile_version_job_families
  DROP CONSTRAINT IF EXISTS job_profile_version_job_families_unique;
ALTER TABLE jobcatalog.job_profile_version_job_families
  ADD CONSTRAINT job_profile_version_job_families_family_fk
    FOREIGN KEY (tenant_uuid, package_uuid, job_family_uuid)
    REFERENCES jobcatalog.job_families(tenant_uuid, package_uuid, job_family_uuid) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_profile_version_job_families
  ADD CONSTRAINT job_profile_version_job_families_unique
    UNIQUE (tenant_uuid, package_uuid, job_profile_version_id, job_family_uuid);

DROP INDEX IF EXISTS jobcatalog.job_profile_version_job_families_one_primary_unique;
CREATE UNIQUE INDEX IF NOT EXISTS job_profile_version_job_families_one_primary_unique
  ON jobcatalog.job_profile_version_job_families (tenant_uuid, package_uuid, job_profile_version_id)
  WHERE is_primary = true;

DROP INDEX IF EXISTS jobcatalog.job_profile_version_job_families_family_lookup_btree;
CREATE INDEX IF NOT EXISTS job_profile_version_job_families_family_lookup_btree
  ON jobcatalog.job_profile_version_job_families (tenant_uuid, package_uuid, job_family_uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00011_jobcatalog_package_id_schema.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00012_jobcatalog_package_code_schema.sql
ALTER TABLE jobcatalog.job_family_groups
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_family_group_events
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_family_group_versions
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_families
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_family_events
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_family_versions
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_levels
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_level_events
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_level_versions
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_profiles
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_profile_events
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_profile_versions
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_profile_version_job_families
  ADD COLUMN IF NOT EXISTS package_code text;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00012_jobcatalog_package_code_schema.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00001_staffing_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE SCHEMA IF NOT EXISTS staffing;


-- end: modules/staffing/infrastructure/persistence/schema/00001_staffing_schema.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00002_staffing_tables.sql
CREATE TABLE IF NOT EXISTS staffing.positions (
  tenant_uuid uuid NOT NULL,
  position_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, position_uuid)
);

CREATE TABLE IF NOT EXISTS staffing.position_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL,
  position_uuid uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT position_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE')),
  CONSTRAINT position_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT position_events_payload_allowed_keys_check CHECK (
    (
      payload
      - 'org_unit_id'
      - 'name'
      - 'reports_to_position_uuid'
      - 'job_profile_uuid'
      - 'lifecycle_status'
      - 'capacity_fte'
    ) = '{}'::jsonb
  ),
  CONSTRAINT position_events_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT position_events_one_per_day_unique UNIQUE (tenant_uuid, position_uuid, effective_date),
  CONSTRAINT position_events_request_code_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT position_events_position_fk FOREIGN KEY (tenant_uuid, position_uuid) REFERENCES staffing.positions(tenant_uuid, position_uuid) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS position_events_tenant_position_effective_idx
  ON staffing.position_events (tenant_uuid, position_uuid, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.position_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  position_uuid uuid NOT NULL,
  org_unit_id int NOT NULL CHECK (org_unit_id BETWEEN 10000000 AND 99999999),
  reports_to_position_uuid uuid NULL,
  name text NULL,
  lifecycle_status text NOT NULL DEFAULT 'active',
  capacity_fte numeric(9,2) NOT NULL DEFAULT 1.0,
  profile jsonb NOT NULL DEFAULT '{}'::jsonb,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.position_events(id),
  CONSTRAINT position_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT position_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT position_versions_capacity_fte_check CHECK (capacity_fte > 0),
  CONSTRAINT position_versions_profile_is_object_check CHECK (jsonb_typeof(profile) = 'object'),
  CONSTRAINT position_versions_lifecycle_status_check CHECK (lifecycle_status IN ('active','disabled')),
  CONSTRAINT position_versions_position_fk FOREIGN KEY (tenant_uuid, position_uuid) REFERENCES staffing.positions(tenant_uuid, position_uuid) ON DELETE RESTRICT,
  CONSTRAINT position_versions_reports_to_fk FOREIGN KEY (tenant_uuid, reports_to_position_uuid) REFERENCES staffing.positions(tenant_uuid, position_uuid) ON DELETE RESTRICT,
  CONSTRAINT position_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      position_uuid gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS position_versions_lookup_btree
  ON staffing.position_versions (tenant_uuid, position_uuid, lower(validity));

ALTER TABLE staffing.position_versions
  ADD COLUMN IF NOT EXISTS jobcatalog_setid text NULL,
  ADD COLUMN IF NOT EXISTS jobcatalog_setid_as_of date NULL,
  ADD COLUMN IF NOT EXISTS job_profile_uuid uuid NULL;

ALTER TABLE staffing.position_versions
  DROP CONSTRAINT IF EXISTS position_versions_jobcatalog_setid_format_check,
  DROP CONSTRAINT IF EXISTS position_versions_jobcatalog_setid_requires_bu_check,
  DROP CONSTRAINT IF EXISTS position_versions_job_profile_requires_setid_check,
  DROP CONSTRAINT IF EXISTS position_versions_job_profile_fk;

ALTER TABLE staffing.position_versions
  ADD CONSTRAINT position_versions_jobcatalog_setid_format_check CHECK (jobcatalog_setid IS NULL OR jobcatalog_setid ~ '^[A-Z0-9]{5}$'),
  ADD CONSTRAINT position_versions_jobcatalog_setid_as_of_check CHECK (jobcatalog_setid IS NULL OR jobcatalog_setid_as_of IS NOT NULL),
  ADD CONSTRAINT position_versions_job_profile_requires_setid_check CHECK (job_profile_uuid IS NULL OR jobcatalog_setid IS NOT NULL);

CREATE TABLE IF NOT EXISTS staffing.assignments (
  tenant_uuid uuid NOT NULL,
  assignment_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  person_uuid uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, assignment_uuid),
  CONSTRAINT assignments_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignments_tenant_person_type_unique UNIQUE (tenant_uuid, person_uuid, assignment_type)
);

CREATE TABLE IF NOT EXISTS staffing.assignment_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_uuid uuid NOT NULL,
  assignment_uuid uuid NOT NULL,
  person_uuid uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT assignment_events_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignment_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE')),
  CONSTRAINT assignment_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT assignment_events_payload_allowed_keys_check CHECK (
    (
      payload
      - 'position_uuid'
      - 'status'
      - 'allocated_fte'
      - 'profile'
    ) = '{}'::jsonb
  ),
  CONSTRAINT assignment_events_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT assignment_events_one_per_day_unique UNIQUE (tenant_uuid, assignment_uuid, effective_date),
  CONSTRAINT assignment_events_request_code_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT assignment_events_assignment_fk FOREIGN KEY (tenant_uuid, assignment_uuid) REFERENCES staffing.assignments(tenant_uuid, assignment_uuid) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS assignment_events_tenant_assignment_effective_idx
  ON staffing.assignment_events (tenant_uuid, assignment_uuid, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.assignment_event_corrections (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  assignment_uuid uuid NOT NULL,
  target_effective_date date NOT NULL,
  replacement_payload jsonb NOT NULL,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT assignment_event_corrections_replacement_payload_obj_check CHECK (jsonb_typeof(replacement_payload) = 'object'),
  CONSTRAINT assignment_event_corrections_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT assignment_event_corrections_target_unique UNIQUE (tenant_uuid, assignment_uuid, target_effective_date),
  CONSTRAINT assignment_event_corrections_request_code_unique UNIQUE (tenant_uuid, request_code)
);

CREATE TABLE IF NOT EXISTS staffing.assignment_event_rescinds (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  assignment_uuid uuid NOT NULL,
  target_effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT assignment_event_rescinds_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT assignment_event_rescinds_event_uuid_unique UNIQUE (event_uuid),
  CONSTRAINT assignment_event_rescinds_target_unique UNIQUE (tenant_uuid, assignment_uuid, target_effective_date),
  CONSTRAINT assignment_event_rescinds_request_code_unique UNIQUE (tenant_uuid, request_code)
);

CREATE TABLE IF NOT EXISTS staffing.assignment_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  assignment_uuid uuid NOT NULL,
  person_uuid uuid NOT NULL,
  position_uuid uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  status text NOT NULL DEFAULT 'active',
  allocated_fte numeric(9,2) NOT NULL DEFAULT 1.0,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.assignment_events(id),
  CONSTRAINT assignment_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT assignment_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT assignment_versions_allocated_fte_check CHECK (allocated_fte > 0),
  CONSTRAINT assignment_versions_status_check CHECK (status IN ('active','inactive')),
  CONSTRAINT assignment_versions_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignment_versions_assignment_fk FOREIGN KEY (tenant_uuid, assignment_uuid) REFERENCES staffing.assignments(tenant_uuid, assignment_uuid) ON DELETE RESTRICT,
  CONSTRAINT assignment_versions_position_fk FOREIGN KEY (tenant_uuid, position_uuid) REFERENCES staffing.positions(tenant_uuid, position_uuid) ON DELETE RESTRICT,
  CONSTRAINT assignment_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      assignment_uuid gist_uuid_ops WITH =,
      validity WITH &&
    ),
  CONSTRAINT assignment_versions_position_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      position_uuid gist_uuid_ops WITH =,
      validity WITH &&
    )
    WHERE (status = 'active')
);

CREATE INDEX IF NOT EXISTS assignment_versions_person_lookup_btree
  ON staffing.assignment_versions (tenant_uuid, person_uuid, lower(validity));

ALTER TABLE staffing.assignment_versions
  ADD COLUMN IF NOT EXISTS profile jsonb NOT NULL DEFAULT '{}'::jsonb;

ALTER TABLE staffing.assignment_versions
  DROP CONSTRAINT IF EXISTS assignment_versions_profile_is_object_check;

ALTER TABLE staffing.assignment_versions
  ADD CONSTRAINT assignment_versions_profile_is_object_check CHECK (jsonb_typeof(profile) = 'object');

ALTER TABLE staffing.positions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.positions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.positions;
CREATE POLICY tenant_isolation ON staffing.positions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.position_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.position_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.position_events;
CREATE POLICY tenant_isolation ON staffing.position_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.position_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.position_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.position_versions;
CREATE POLICY tenant_isolation ON staffing.position_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignments FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignments;
CREATE POLICY tenant_isolation ON staffing.assignments
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_events;
CREATE POLICY tenant_isolation ON staffing.assignment_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_event_corrections ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_event_corrections FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_event_corrections;
CREATE POLICY tenant_isolation ON staffing.assignment_event_corrections
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_event_rescinds ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_event_rescinds FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_event_rescinds;
CREATE POLICY tenant_isolation ON staffing.assignment_event_rescinds
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_versions;
CREATE POLICY tenant_isolation ON staffing.assignment_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- end: modules/staffing/infrastructure/persistence/schema/00002_staffing_tables.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00003_staffing_engine.sql
CREATE OR REPLACE FUNCTION staffing.assert_current_tenant(p_tenant_uuid uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'tenant_uuid is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_uuid THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_uuid, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_position_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_position_uuid uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_reports_to_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.position_events%ROWTYPE;
  v_payload jsonb;
  v_prev_effective_max date;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_uuid is required';
  END IF;
  IF p_position_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'position_uuid is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);

  IF v_payload ? 'reports_to_position_uuid' THEN
    v_reports_to_lock_key := format('staffing:position-reports-to:%s', p_tenant_uuid);
    PERFORM pg_advisory_xact_lock(hashtextextended(v_reports_to_lock_key, 0));
  END IF;

  v_lock_key := format('staffing:position:%s:%s', p_tenant_uuid, p_position_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  INSERT INTO staffing.positions (tenant_uuid, position_uuid)
  VALUES (p_tenant_uuid, p_position_uuid)
  ON CONFLICT DO NOTHING;

  INSERT INTO staffing.position_events (
    event_uuid,
    tenant_uuid,
    position_uuid,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_position_uuid,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (event_uuid) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.position_events
    WHERE event_uuid = p_event_uuid;

    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.position_uuid <> p_position_uuid
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  IF p_event_type = 'UPDATE' AND v_payload ? 'reports_to_position_uuid' THEN
    SELECT max(effective_date) INTO v_prev_effective_max
    FROM staffing.position_events
    WHERE tenant_uuid = p_tenant_uuid
      AND position_uuid = p_position_uuid
      AND id <> v_event_db_id;

    IF v_prev_effective_max IS NOT NULL AND p_effective_date <= v_prev_effective_max THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('reports_to_position_uuid updates must be forward-only: effective_date=%s last_effective_date=%s', p_effective_date, v_prev_effective_max);
    END IF;
  END IF;

  PERFORM staffing.replay_position_versions(p_tenant_uuid, p_position_uuid);

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.replay_position_versions(
  p_tenant_uuid uuid,
  p_position_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_prev_effective date;
  v_last_validity daterange;
  v_org_unit_id int;
  v_reports_to_position_uuid uuid;
  v_jobcatalog_setid text;
  v_jobcatalog_setid_as_of date;
  v_jobcatalog_package_uuid uuid;
  v_job_profile_uuid uuid;
  v_name text;
  v_lifecycle_status text;
  v_capacity_fte numeric(9,2);
  v_profile jsonb;
  v_tmp_text text;
  v_target_status text;
  v_row RECORD;
  v_validity daterange;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);

  IF p_position_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'position_uuid is required';
  END IF;

  v_lock_key := format('staffing:position:%s:%s', p_tenant_uuid, p_position_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM staffing.position_versions
  WHERE tenant_uuid = p_tenant_uuid AND position_uuid = p_position_uuid;

  v_org_unit_id := NULL;
  v_reports_to_position_uuid := NULL;
  v_jobcatalog_setid := NULL;
  v_jobcatalog_setid_as_of := NULL;
  v_job_profile_uuid := NULL;
  v_name := NULL;
  v_lifecycle_status := 'active';
  v_capacity_fte := 1.0;
  v_profile := '{}'::jsonb;
  v_prev_effective := NULL;

  FOR v_row IN
    SELECT
      e.id AS event_db_id,
      e.event_type,
      e.effective_date,
      e.payload,
      lead(effective_date) OVER (ORDER BY effective_date ASC, id ASC) AS next_effective
    FROM staffing.position_events e
    WHERE e.tenant_uuid = p_tenant_uuid
      AND e.position_uuid = p_position_uuid
    ORDER BY effective_date ASC, id ASC
  LOOP
    IF v_row.event_type = 'CREATE' THEN
      IF v_prev_effective IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_tmp_text := NULLIF(btrim(v_row.payload->>'org_unit_id'), '');
      IF v_tmp_text IS NULL THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_INVALID_ARGUMENT',
          DETAIL = 'org_unit_id is required';
      END IF;
      BEGIN
        v_org_unit_id := v_tmp_text::int;
      EXCEPTION
        WHEN invalid_text_representation THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('org_unit_id=%s', v_row.payload->>'org_unit_id');
      END;

      v_name := NULLIF(btrim(v_row.payload->>'name'), '');

      IF v_row.payload ? 'reports_to_position_uuid' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'reports_to_position_uuid'), '');
        IF v_tmp_text IS NULL THEN
          v_reports_to_position_uuid := NULL;
        ELSE
          BEGIN
            v_reports_to_position_uuid := v_tmp_text::uuid;
          EXCEPTION
            WHEN invalid_text_representation THEN
              RAISE EXCEPTION USING
                MESSAGE = 'STAFFING_INVALID_ARGUMENT',
                DETAIL = format('reports_to_position_uuid=%s', v_row.payload->>'reports_to_position_uuid');
          END;
        END IF;
      ELSE
        v_reports_to_position_uuid := NULL;
      END IF;

      IF v_row.payload ? 'lifecycle_status' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'lifecycle_status'), '');
        IF v_tmp_text IS NULL OR v_tmp_text NOT IN ('active','disabled') THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('lifecycle_status=%s', v_row.payload->>'lifecycle_status');
        END IF;
        v_lifecycle_status := v_tmp_text;
      ELSE
        v_lifecycle_status := 'active';
      END IF;

      IF v_row.payload ? 'capacity_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'capacity_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'capacity_fte is required';
        END IF;
        BEGIN
          v_capacity_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_INVALID_ARGUMENT',
              DETAIL = format('capacity_fte=%s', v_row.payload->>'capacity_fte');
        END;
        IF v_capacity_fte <= 0 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('capacity_fte=%s', v_row.payload->>'capacity_fte');
        END IF;
      ELSE
        v_capacity_fte := 1.0;
      END IF;

      IF v_row.payload ? 'job_profile_uuid' THEN
        IF v_row.payload->'job_profile_uuid' IS NULL THEN
          v_job_profile_uuid := NULL;
        ELSE
          v_tmp_text := NULLIF(btrim(v_row.payload->>'job_profile_uuid'), '');
          IF v_tmp_text IS NULL THEN
            v_job_profile_uuid := NULL;
          ELSE
            BEGIN
              v_job_profile_uuid := v_tmp_text::uuid;
            EXCEPTION
              WHEN invalid_text_representation THEN
                RAISE EXCEPTION USING
                  MESSAGE = 'STAFFING_INVALID_ARGUMENT',
                  DETAIL = format('job_profile_uuid=%s', v_row.payload->>'job_profile_uuid');
            END;
          END IF;
        END IF;
      END IF;
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev_effective IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;

      IF v_row.payload ? 'org_unit_id' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'org_unit_id'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'org_unit_id is required';
        END IF;
        BEGIN
          v_org_unit_id := v_tmp_text::int;
        EXCEPTION
          WHEN invalid_text_representation THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_INVALID_ARGUMENT',
              DETAIL = format('org_unit_id=%s', v_row.payload->>'org_unit_id');
        END;
      END IF;

      IF v_row.payload ? 'reports_to_position_uuid' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'reports_to_position_uuid'), '');
        IF v_tmp_text IS NULL THEN
          v_reports_to_position_uuid := NULL;
        ELSE
          BEGIN
            v_reports_to_position_uuid := v_tmp_text::uuid;
          EXCEPTION
            WHEN invalid_text_representation THEN
              RAISE EXCEPTION USING
                MESSAGE = 'STAFFING_INVALID_ARGUMENT',
                DETAIL = format('reports_to_position_uuid=%s', v_row.payload->>'reports_to_position_uuid');
          END;
        END IF;
      END IF;

      IF v_row.payload ? 'name' THEN
        v_name := NULLIF(btrim(v_row.payload->>'name'), '');
      END IF;

      IF v_row.payload ? 'lifecycle_status' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'lifecycle_status'), '');
        IF v_tmp_text IS NULL OR v_tmp_text NOT IN ('active','disabled') THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('lifecycle_status=%s', v_row.payload->>'lifecycle_status');
        END IF;
        v_lifecycle_status := v_tmp_text;
      END IF;

      IF v_row.payload ? 'capacity_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'capacity_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'capacity_fte is required';
        END IF;
        BEGIN
          v_capacity_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_INVALID_ARGUMENT',
              DETAIL = format('capacity_fte=%s', v_row.payload->>'capacity_fte');
        END;
        IF v_capacity_fte <= 0 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('capacity_fte=%s', v_row.payload->>'capacity_fte');
        END IF;
      END IF;

      IF v_row.payload ? 'job_profile_uuid' THEN
        IF v_row.payload->'job_profile_uuid' IS NULL THEN
          v_job_profile_uuid := NULL;
        ELSE
          v_tmp_text := NULLIF(btrim(v_row.payload->>'job_profile_uuid'), '');
          IF v_tmp_text IS NULL THEN
            v_job_profile_uuid := NULL;
          ELSE
            BEGIN
              v_job_profile_uuid := v_tmp_text::uuid;
            EXCEPTION
              WHEN invalid_text_representation THEN
                RAISE EXCEPTION USING
                  MESSAGE = 'STAFFING_INVALID_ARGUMENT',
                  DETAIL = format('job_profile_uuid=%s', v_row.payload->>'job_profile_uuid');
            END;
          END IF;
        END IF;
      END IF;
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_row.event_type);
    END IF;

    IF v_org_unit_id IS NOT NULL THEN
      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.org_unit_versions ouv
        WHERE ouv.tenant_uuid = p_tenant_uuid
          AND ouv.org_id = v_org_unit_id
          AND ouv.status = 'active'
          AND ouv.validity @> v_row.effective_date
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_ORG_UNIT_NOT_FOUND_AS_OF',
          DETAIL = format('org_unit_id=%s as_of=%s', v_org_unit_id, v_row.effective_date);
      END IF;
    END IF;

    IF v_job_profile_uuid IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = 'job_profile_uuid is required';
    END IF;

    v_jobcatalog_setid := orgunit.resolve_setid(p_tenant_uuid, v_org_unit_id, v_row.effective_date);
    v_jobcatalog_setid_as_of := v_row.effective_date;
    SELECT package_id
    INTO v_jobcatalog_package_uuid
    FROM orgunit.resolve_scope_package(p_tenant_uuid, v_jobcatalog_setid, 'jobcatalog', v_row.effective_date);

    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_profile_versions jpv
      WHERE jpv.tenant_uuid = p_tenant_uuid
        AND jpv.package_uuid = v_jobcatalog_package_uuid
        AND jpv.job_profile_uuid = v_job_profile_uuid
        AND jpv.is_active = true
        AND jpv.validity @> v_row.effective_date
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_profile_uuid=%s', v_job_profile_uuid);
    END IF;

    IF v_reports_to_position_uuid IS NOT NULL THEN
      IF v_reports_to_position_uuid = p_position_uuid THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_REPORTS_TO_SELF',
          DETAIL = format('position_uuid=%s', p_position_uuid);
      END IF;

      SELECT lifecycle_status INTO v_target_status
      FROM staffing.position_versions pv
      WHERE pv.tenant_uuid = p_tenant_uuid
        AND pv.position_uuid = v_reports_to_position_uuid
        AND pv.validity @> v_row.effective_date
      ORDER BY lower(pv.validity) DESC
      LIMIT 1;
      IF NOT FOUND THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_NOT_FOUND_AS_OF',
          DETAIL = format('position_uuid=%s as_of=%s', v_reports_to_position_uuid, v_row.effective_date);
      END IF;
      IF v_target_status <> 'active' THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_DISABLED_AS_OF',
          DETAIL = format('position_uuid=%s as_of=%s', v_reports_to_position_uuid, v_row.effective_date);
      END IF;

      IF EXISTS (
        WITH RECURSIVE chain AS (
          SELECT pv.position_uuid, pv.reports_to_position_uuid
          FROM staffing.position_versions pv
          WHERE pv.tenant_uuid = p_tenant_uuid
            AND pv.position_uuid = v_reports_to_position_uuid
            AND pv.validity @> v_row.effective_date
          UNION ALL
          SELECT pv.position_uuid, pv.reports_to_position_uuid
          FROM staffing.position_versions pv
          JOIN chain c ON pv.position_uuid = c.reports_to_position_uuid
          WHERE pv.tenant_uuid = p_tenant_uuid
            AND pv.validity @> v_row.effective_date
            AND c.reports_to_position_uuid IS NOT NULL
        )
        SELECT 1
        FROM chain
        WHERE position_uuid = p_position_uuid
           OR reports_to_position_uuid = p_position_uuid
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_REPORTS_TO_CYCLE',
          DETAIL = format('position_uuid=%s', p_position_uuid);
      END IF;
    END IF;

    IF v_row.next_effective IS NULL THEN
      v_validity := daterange(v_row.effective_date, NULL, '[)');
    ELSE
      v_validity := daterange(v_row.effective_date, v_row.next_effective, '[)');
    END IF;

    IF v_lifecycle_status = 'disabled' THEN
      IF EXISTS (
        SELECT 1
        FROM staffing.assignment_versions av
        WHERE av.tenant_uuid = p_tenant_uuid
          AND av.position_uuid = p_position_uuid
          AND av.status = 'active'
          AND av.validity && v_validity
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_HAS_ACTIVE_ASSIGNMENT_AS_OF',
          DETAIL = format('position_uuid=%s as_of=%s', p_position_uuid, v_row.effective_date);
      END IF;
    END IF;

    INSERT INTO staffing.position_versions (
      tenant_uuid,
      position_uuid,
      org_unit_id,
      reports_to_position_uuid,
      name,
      lifecycle_status,
      capacity_fte,
      profile,
      validity,
      last_event_id,
      jobcatalog_setid,
      jobcatalog_setid_as_of,
      job_profile_uuid
    )
    VALUES (
      p_tenant_uuid,
      p_position_uuid,
      v_org_unit_id,
      v_reports_to_position_uuid,
      v_name,
      v_lifecycle_status,
      v_capacity_fte,
      v_profile,
      v_validity,
      v_row.event_db_id,
      v_jobcatalog_setid,
      v_jobcatalog_setid_as_of,
      v_job_profile_uuid
    );

    IF v_lifecycle_status = 'active' THEN
      PERFORM staffing.assert_position_capacity(p_tenant_uuid, p_position_uuid, v_validity);
    END IF;

    v_prev_effective := v_row.effective_date;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM staffing.position_versions
      WHERE tenant_uuid = p_tenant_uuid AND position_uuid = p_position_uuid
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_GAP',
      DETAIL = 'position_versions must be gapless';
  END IF;

  SELECT validity INTO v_last_validity
  FROM staffing.position_versions
  WHERE tenant_uuid = p_tenant_uuid AND position_uuid = p_position_uuid
  ORDER BY lower(validity) DESC
  LIMIT 1;
  IF v_last_validity IS NOT NULL AND upper(v_last_validity) IS NOT NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_NOT_INFINITE',
      DETAIL = 'position_versions must end at infinity';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.assert_position_capacity(
  p_tenant_uuid uuid,
  p_position_uuid uuid,
  p_validity daterange
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);

  IF p_position_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'position_uuid is required';
  END IF;
  IF p_validity IS NULL OR isempty(p_validity) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'validity is required';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM staffing.assignment_versions av
    JOIN staffing.position_versions pv
      ON pv.tenant_uuid = av.tenant_uuid
     AND pv.position_uuid = av.position_uuid
     AND pv.validity && av.validity
    WHERE av.tenant_uuid = p_tenant_uuid
      AND av.position_uuid = p_position_uuid
      AND av.status = 'active'
      AND av.validity && p_validity
      AND av.allocated_fte > pv.capacity_fte
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_POSITION_CAPACITY_EXCEEDED',
      DETAIL = format('position_uuid=%s', p_position_uuid);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.replay_assignment_versions(
  p_tenant_uuid uuid,
  p_assignment_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_prev_effective date;
  v_last_validity daterange;
  v_person_uuid uuid;
  v_assignment_type text;
  v_position_uuid uuid;
  v_status text;
  v_allocated_fte numeric(9,2);
  v_profile jsonb;
  v_tmp_text text;
  v_row RECORD;
  v_validity daterange;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);

  IF p_assignment_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'assignment_uuid is required';
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_uuid, p_assignment_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM staffing.assignment_versions
  WHERE tenant_uuid = p_tenant_uuid AND assignment_uuid = p_assignment_uuid;

  v_person_uuid := NULL;
  v_assignment_type := NULL;
  v_position_uuid := NULL;
  v_status := 'active';
  v_allocated_fte := 1.0;
  v_profile := '{}'::jsonb;
  v_prev_effective := NULL;

  FOR v_row IN
    WITH base AS (
      SELECT
        e.id AS event_db_id,
        e.event_type,
        e.effective_date,
        e.person_uuid,
        e.assignment_type,
        COALESCE(c.replacement_payload, e.payload) AS payload,
        (r.id IS NOT NULL) AS is_rescinded
      FROM staffing.assignment_events e
      LEFT JOIN staffing.assignment_event_corrections c
        ON c.tenant_uuid = e.tenant_uuid
       AND c.assignment_uuid = e.assignment_uuid
       AND c.target_effective_date = e.effective_date
      LEFT JOIN staffing.assignment_event_rescinds r
        ON r.tenant_uuid = e.tenant_uuid
       AND r.assignment_uuid = e.assignment_uuid
       AND r.target_effective_date = e.effective_date
      WHERE e.tenant_uuid = p_tenant_uuid
        AND e.assignment_uuid = p_assignment_uuid
    ),
    filtered AS (
      SELECT *
      FROM base
      WHERE NOT is_rescinded
    ),
    ordered AS (
      SELECT
        event_db_id,
        event_type,
        effective_date,
        person_uuid,
        assignment_type,
        payload,
        lead(effective_date) OVER (ORDER BY effective_date ASC, event_db_id ASC) AS next_effective
      FROM filtered
    )
    SELECT *
    FROM ordered
    ORDER BY effective_date ASC, event_db_id ASC
  LOOP
    IF v_row.event_type = 'CREATE' THEN
      IF v_prev_effective IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_person_uuid := v_row.person_uuid;
      v_assignment_type := v_row.assignment_type;

      v_position_uuid := NULLIF(v_row.payload->>'position_uuid', '')::uuid;
      IF v_position_uuid IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_ARGUMENT',
          DETAIL = 'position_uuid is required';
      END IF;
      v_status := 'active';

      IF v_row.payload ? 'allocated_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'allocated_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = 'allocated_fte is required';
        END IF;
        BEGIN
          v_allocated_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
              DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END;
        IF v_allocated_fte <= 0 OR v_allocated_fte > 1 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END IF;
      END IF;

      IF v_row.payload ? 'profile' THEN
        IF jsonb_typeof(v_row.payload->'profile') <> 'object' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_PROFILE_INVALID',
            DETAIL = 'profile must be an object';
        END IF;
        v_profile := v_row.payload->'profile';
      END IF;
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev_effective IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;

      IF v_row.payload ? 'position_uuid' THEN
        v_position_uuid := NULLIF(v_row.payload->>'position_uuid', '')::uuid;
        IF v_position_uuid IS NULL THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'position_uuid is required';
	      END IF;
      END IF;

      IF v_row.payload ? 'status' THEN
        v_status := NULLIF(btrim(v_row.payload->>'status'), '');
        IF v_status IS NULL OR v_status NOT IN ('active','inactive') THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('invalid status: %s', v_row.payload->>'status');
	        END IF;
      END IF;

      IF v_row.payload ? 'allocated_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'allocated_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = 'allocated_fte is required';
        END IF;
        BEGIN
          v_allocated_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
              DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END;
        IF v_allocated_fte <= 0 OR v_allocated_fte > 1 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END IF;
      END IF;

      IF v_row.payload ? 'profile' THEN
        IF jsonb_typeof(v_row.payload->'profile') <> 'object' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_PROFILE_INVALID',
            DETAIL = 'profile must be an object';
        END IF;
        v_profile := v_row.payload->'profile';
      END IF;
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_row.event_type);
    END IF;

    IF v_row.next_effective IS NULL THEN
      v_validity := daterange(v_row.effective_date, NULL, '[)');
    ELSE
      v_validity := daterange(v_row.effective_date, v_row.next_effective, '[)');
    END IF;

    IF v_status = 'active' THEN
      IF NOT EXISTS (
        SELECT 1
        FROM staffing.position_versions pv
        WHERE pv.tenant_uuid = p_tenant_uuid
          AND pv.position_uuid = v_position_uuid
          AND pv.lifecycle_status = 'active'
          AND pv.validity @> v_row.effective_date
        LIMIT 1
      ) THEN
        IF EXISTS (
          SELECT 1
          FROM staffing.position_versions pv
          WHERE pv.tenant_uuid = p_tenant_uuid
            AND pv.position_uuid = v_position_uuid
            AND pv.validity @> v_row.effective_date
          LIMIT 1
        ) THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_POSITION_DISABLED_AS_OF',
            DETAIL = format('position_uuid=%s as_of=%s', v_position_uuid, v_row.effective_date);
        END IF;

        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_NOT_FOUND_AS_OF',
          DETAIL = format('position_uuid=%s as_of=%s', v_position_uuid, v_row.effective_date);
      END IF;
    END IF;

    INSERT INTO staffing.assignment_versions (
      tenant_uuid,
      assignment_uuid,
      person_uuid,
      position_uuid,
      assignment_type,
      status,
      allocated_fte,
      profile,
      validity,
      last_event_id
    )
    VALUES (
      p_tenant_uuid,
      p_assignment_uuid,
      v_person_uuid,
      v_position_uuid,
      v_assignment_type,
      v_status,
      v_allocated_fte,
      v_profile,
      v_validity,
      v_row.event_db_id
    );

    IF v_status = 'active' THEN
      PERFORM staffing.assert_position_capacity(p_tenant_uuid, v_position_uuid, v_validity);
    END IF;

    v_prev_effective := v_row.effective_date;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM staffing.assignment_versions
      WHERE tenant_uuid = p_tenant_uuid AND assignment_uuid = p_assignment_uuid
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_GAP',
      DETAIL = 'assignment_versions must be gapless';
  END IF;

  SELECT validity INTO v_last_validity
  FROM staffing.assignment_versions
  WHERE tenant_uuid = p_tenant_uuid AND assignment_uuid = p_assignment_uuid
  ORDER BY lower(validity) DESC
  LIMIT 1;

  IF v_last_validity IS NOT NULL AND NOT upper_inf(v_last_validity) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_NOT_INFINITE',
      DETAIL = 'last assignment version validity must be unbounded (infinity)';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_assignment_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_assignment_uuid uuid,
  p_person_uuid uuid,
  p_assignment_type text,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.assignment_events%ROWTYPE;
  v_payload jsonb;
  v_existing_assignment_uuid uuid;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_uuid is required';
  END IF;
  IF p_assignment_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_uuid is required';
  END IF;
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_assignment_type IS NULL OR btrim(p_assignment_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_type is required';
  END IF;
  IF p_assignment_type <> 'primary' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported assignment_type: %s', p_assignment_type);
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_uuid, p_assignment_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  INSERT INTO staffing.assignments (tenant_uuid, id, person_uuid, assignment_type)
  VALUES (p_tenant_uuid, p_assignment_uuid, p_person_uuid, p_assignment_type)
  ON CONFLICT (tenant_uuid, person_uuid, assignment_type) DO NOTHING;

  SELECT assignment_uuid INTO v_existing_assignment_uuid
  FROM staffing.assignments
  WHERE tenant_uuid = p_tenant_uuid AND person_uuid = p_person_uuid AND assignment_type = p_assignment_type;

  IF v_existing_assignment_uuid IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'assignment identity missing';
  END IF;
  IF v_existing_assignment_uuid <> p_assignment_uuid THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_ID_MISMATCH',
      DETAIL = format('assignment_uuid=%s existing_id=%s', p_assignment_uuid, v_existing_assignment_uuid);
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);

  INSERT INTO staffing.assignment_events (
    event_uuid,
    tenant_uuid,
    assignment_uuid,
    person_uuid,
    assignment_type,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_assignment_uuid,
    p_person_uuid,
    p_assignment_type,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (event_uuid) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.assignment_events
    WHERE event_uuid = p_event_uuid;

    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.assignment_uuid <> p_assignment_uuid
      OR v_existing.person_uuid <> p_person_uuid
      OR v_existing.assignment_type <> p_assignment_type
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM staffing.replay_assignment_versions(p_tenant_uuid, p_assignment_uuid);

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_assignment_event_correction(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_assignment_uuid uuid,
  p_target_effective_date date,
  p_replacement_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_target staffing.assignment_events%ROWTYPE;
  v_existing_by_event staffing.assignment_event_corrections%ROWTYPE;
  v_existing_by_request staffing.assignment_event_corrections%ROWTYPE;
  v_existing_by_target staffing.assignment_event_corrections%ROWTYPE;
  v_payload jsonb;
  v_correction_db_id bigint;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_uuid is required';
  END IF;
  IF p_assignment_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_uuid is required';
  END IF;
  IF p_target_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'target_effective_date is required';
  END IF;
  IF p_replacement_payload IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'replacement_payload is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  v_payload := p_replacement_payload;
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'replacement_payload must be an object';
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_uuid, p_assignment_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_target
  FROM staffing.assignment_events
  WHERE tenant_uuid = p_tenant_uuid
    AND assignment_uuid = p_assignment_uuid
    AND effective_date = p_target_effective_date
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_EVENT_NOT_FOUND',
      DETAIL = format('assignment_uuid=%s target_effective_date=%s', p_assignment_uuid, p_target_effective_date);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM staffing.assignment_event_rescinds r
    WHERE r.tenant_uuid = p_tenant_uuid
      AND r.assignment_uuid = p_assignment_uuid
      AND r.target_effective_date = p_target_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_EVENT_ALREADY_RESCINDED',
      DETAIL = format('assignment_uuid=%s target_effective_date=%s', p_assignment_uuid, p_target_effective_date);
  END IF;

  INSERT INTO staffing.assignment_event_corrections (
    event_uuid,
    tenant_uuid,
    assignment_uuid,
    target_effective_date,
    replacement_payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_assignment_uuid,
    p_target_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT DO NOTHING
  RETURNING id INTO v_correction_db_id;

  IF v_correction_db_id IS NULL THEN
    SELECT * INTO v_existing_by_event
    FROM staffing.assignment_event_corrections
    WHERE event_uuid = p_event_uuid;

    IF FOUND THEN
      IF v_existing_by_event.tenant_uuid <> p_tenant_uuid
        OR v_existing_by_event.assignment_uuid <> p_assignment_uuid
        OR v_existing_by_event.target_effective_date <> p_target_effective_date
        OR v_existing_by_event.replacement_payload <> v_payload
        OR v_existing_by_event.request_code <> p_request_code
        OR v_existing_by_event.initiator_uuid <> p_initiator_uuid
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
          DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing_by_event.id);
      END IF;
      v_correction_db_id := v_existing_by_event.id;
    ELSE
      SELECT * INTO v_existing_by_request
      FROM staffing.assignment_event_corrections
      WHERE tenant_uuid = p_tenant_uuid
        AND request_code = p_request_code
      LIMIT 1;

      IF FOUND THEN
        IF v_existing_by_request.tenant_uuid <> p_tenant_uuid
          OR v_existing_by_request.assignment_uuid <> p_assignment_uuid
          OR v_existing_by_request.target_effective_date <> p_target_effective_date
          OR v_existing_by_request.replacement_payload <> v_payload
          OR v_existing_by_request.request_code <> p_request_code
          OR v_existing_by_request.initiator_uuid <> p_initiator_uuid
        THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
            DETAIL = format('request_code=%s existing_id=%s', p_request_code, v_existing_by_request.id);
        END IF;
        v_correction_db_id := v_existing_by_request.id;
      ELSE
        SELECT * INTO v_existing_by_target
        FROM staffing.assignment_event_corrections
        WHERE tenant_uuid = p_tenant_uuid
          AND assignment_uuid = p_assignment_uuid
          AND target_effective_date = p_target_effective_date
        LIMIT 1;

        IF FOUND THEN
          IF v_existing_by_target.replacement_payload = v_payload THEN
            v_correction_db_id := v_existing_by_target.id;
          ELSE
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_EVENT_ALREADY_CORRECTED',
              DETAIL = format('assignment_uuid=%s target_effective_date=%s existing_id=%s', p_assignment_uuid, p_target_effective_date, v_existing_by_target.id);
          END IF;
        ELSE
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'correction insert failed';
        END IF;
      END IF;
    END IF;
  END IF;

  PERFORM staffing.replay_assignment_versions(p_tenant_uuid, p_assignment_uuid);

  RETURN v_correction_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_assignment_event_rescind(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_assignment_uuid uuid,
  p_target_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_target staffing.assignment_events%ROWTYPE;
  v_existing_by_event staffing.assignment_event_rescinds%ROWTYPE;
  v_existing_by_request staffing.assignment_event_rescinds%ROWTYPE;
  v_existing_by_target staffing.assignment_event_rescinds%ROWTYPE;
  v_payload jsonb;
  v_rescind_db_id bigint;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_uuid is required';
  END IF;
  IF p_assignment_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_uuid is required';
  END IF;
  IF p_target_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'target_effective_date is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_uuid, p_assignment_uuid);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_target
  FROM staffing.assignment_events
  WHERE tenant_uuid = p_tenant_uuid
    AND assignment_uuid = p_assignment_uuid
    AND effective_date = p_target_effective_date
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_EVENT_NOT_FOUND',
      DETAIL = format('assignment_uuid=%s target_effective_date=%s', p_assignment_uuid, p_target_effective_date);
  END IF;

  IF v_target.event_type = 'CREATE' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_CREATE_CANNOT_RESCIND',
      DETAIL = format('assignment_uuid=%s target_effective_date=%s', p_assignment_uuid, p_target_effective_date);
  END IF;

  INSERT INTO staffing.assignment_event_rescinds (
    event_uuid,
    tenant_uuid,
    assignment_uuid,
    target_effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_assignment_uuid,
    p_target_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT DO NOTHING
  RETURNING id INTO v_rescind_db_id;

  IF v_rescind_db_id IS NULL THEN
    SELECT * INTO v_existing_by_event
    FROM staffing.assignment_event_rescinds
    WHERE event_uuid = p_event_uuid;

    IF FOUND THEN
      IF v_existing_by_event.tenant_uuid <> p_tenant_uuid
        OR v_existing_by_event.assignment_uuid <> p_assignment_uuid
        OR v_existing_by_event.target_effective_date <> p_target_effective_date
        OR v_existing_by_event.payload <> v_payload
        OR v_existing_by_event.request_code <> p_request_code
        OR v_existing_by_event.initiator_uuid <> p_initiator_uuid
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
          DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing_by_event.id);
      END IF;
      v_rescind_db_id := v_existing_by_event.id;
    ELSE
      SELECT * INTO v_existing_by_request
      FROM staffing.assignment_event_rescinds
      WHERE tenant_uuid = p_tenant_uuid
        AND request_code = p_request_code
      LIMIT 1;

      IF FOUND THEN
        IF v_existing_by_request.tenant_uuid <> p_tenant_uuid
          OR v_existing_by_request.assignment_uuid <> p_assignment_uuid
          OR v_existing_by_request.target_effective_date <> p_target_effective_date
          OR v_existing_by_request.payload <> v_payload
          OR v_existing_by_request.request_code <> p_request_code
          OR v_existing_by_request.initiator_uuid <> p_initiator_uuid
        THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
            DETAIL = format('request_code=%s existing_id=%s', p_request_code, v_existing_by_request.id);
        END IF;
        v_rescind_db_id := v_existing_by_request.id;
      ELSE
        SELECT * INTO v_existing_by_target
        FROM staffing.assignment_event_rescinds
        WHERE tenant_uuid = p_tenant_uuid
          AND assignment_uuid = p_assignment_uuid
          AND target_effective_date = p_target_effective_date
        LIMIT 1;

        IF FOUND THEN
          v_rescind_db_id := v_existing_by_target.id;
        ELSE
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'rescind insert failed';
        END IF;
      END IF;
    END IF;
  END IF;

  PERFORM staffing.replay_assignment_versions(p_tenant_uuid, p_assignment_uuid);

  RETURN v_rescind_db_id;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00003_staffing_engine.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00015_staffing_read.sql
CREATE OR REPLACE FUNCTION staffing.get_position_snapshot(
  p_tenant_uuid uuid,
  p_query_date date
)
RETURNS TABLE (
  position_uuid uuid,
  org_unit_id int,
  reports_to_position_uuid uuid,
  jobcatalog_setid text,
  jobcatalog_setid_as_of date,
  job_profile_uuid uuid,
  job_profile_code text,
  name text,
  lifecycle_status text,
  capacity_fte numeric(9,2),
  effective_date date
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

	  RETURN QUERY
	  SELECT
    pv.position_uuid,
    pv.org_unit_id,
    pv.reports_to_position_uuid,
    pv.jobcatalog_setid,
    pv.jobcatalog_setid_as_of,
    pv.job_profile_uuid,
    jp.job_profile_code::text AS job_profile_code,
	    pv.name,
	    pv.lifecycle_status,
	    pv.capacity_fte,
	    lower(pv.validity) AS effective_date
  FROM staffing.position_versions pv
  LEFT JOIN LATERAL orgunit.resolve_scope_package(
    p_tenant_uuid,
    pv.jobcatalog_setid,
    'jobcatalog',
    pv.jobcatalog_setid_as_of
  ) sp(package_uuid, package_owner_tenant_uuid)
    ON pv.jobcatalog_setid IS NOT NULL
  LEFT JOIN jobcatalog.job_profiles jp
    ON jp.tenant_uuid = pv.tenant_uuid
   AND jp.package_uuid = sp.package_uuid
   AND jp.job_profile_uuid = pv.job_profile_uuid
  WHERE pv.tenant_uuid = p_tenant_uuid
    AND pv.validity @> p_query_date;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.get_assignment_snapshot(
  p_tenant_uuid uuid,
  p_person_uuid uuid,
  p_query_date date
)
RETURNS TABLE (
  assignment_uuid uuid,
  person_uuid uuid,
  position_uuid uuid,
  status text,
  effective_date date
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_uuid);
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'person_uuid is required';
  END IF;
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  RETURN QUERY
  SELECT
    av.assignment_uuid,
    av.person_uuid,
    av.position_uuid,
    av.status,
    lower(av.validity) AS effective_date
  FROM staffing.assignment_versions av
  WHERE av.tenant_uuid = p_tenant_uuid
    AND av.person_uuid = p_person_uuid
    AND av.validity @> p_query_date;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00015_staffing_read.sql

-- begin: modules/person/infrastructure/persistence/schema/00001_person_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS person;


-- end: modules/person/infrastructure/persistence/schema/00001_person_schema.sql

-- begin: modules/person/infrastructure/persistence/schema/00002_person_persons.sql
CREATE TABLE IF NOT EXISTS person.persons (
  tenant_uuid uuid NOT NULL,
  person_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  pernr text NOT NULL,
  display_name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, person_uuid),
  CONSTRAINT persons_pernr_trim_check CHECK (btrim(pernr) = pernr),
  CONSTRAINT persons_pernr_digits_max8_check CHECK (pernr ~ '^[0-9]{1,8}$'),
  CONSTRAINT persons_pernr_canonical_check CHECK (pernr = '0' OR pernr !~ '^0'),
  CONSTRAINT persons_display_name_trim_check CHECK (btrim(display_name) = display_name),
  CONSTRAINT persons_display_name_nonempty_check CHECK (display_name <> ''),
  CONSTRAINT persons_status_check CHECK (status IN ('active','inactive')),
  CONSTRAINT persons_tenant_pernr_unique UNIQUE (tenant_uuid, pernr)
);

CREATE INDEX IF NOT EXISTS persons_tenant_display_name_idx
  ON person.persons (tenant_uuid, display_name);

ALTER TABLE person.persons ENABLE ROW LEVEL SECURITY;
ALTER TABLE person.persons FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON person.persons;
CREATE POLICY tenant_isolation ON person.persons
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- end: modules/person/infrastructure/persistence/schema/00002_person_persons.sql

-- begin: modules/person/infrastructure/persistence/schema/00003_person_engine.sql
CREATE OR REPLACE FUNCTION person.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_INVALID_ARGUMENT',
      DETAIL = 'tenant_uuid is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_id THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION person.normalize_pernr(p_pernr text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v text;
BEGIN
  IF p_pernr IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_PERNR_INVALID',
      DETAIL = 'pernr is required';
  END IF;

  v := btrim(p_pernr);
  IF v = '' OR v !~ '^[0-9]{1,8}$' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_PERNR_INVALID',
      DETAIL = format('pernr=%s', v);
  END IF;

  v := regexp_replace(v, '^0+', '');
  IF v = '' THEN
    v := '0';
  END IF;
  RETURN v;
END;
$$;


-- end: modules/person/infrastructure/persistence/schema/00003_person_engine.sql

