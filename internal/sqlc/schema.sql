-- Code generated by scripts/sqlc/export-schema.sh; DO NOT EDIT.
-- Source: modules/*/infrastructure/persistence/schema/*.sql

-- begin: modules/iam/infrastructure/persistence/schema/00001_iam_baseline.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS iam;

CREATE OR REPLACE FUNCTION public.current_tenant_id()
RETURNS uuid
LANGUAGE sql
STABLE
AS $$
  SELECT current_setting('app.current_tenant')::uuid;
$$;

CREATE OR REPLACE FUNCTION public.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  IF p_tenant_id <> public.current_tenant_id() THEN
    RAISE EXCEPTION 'RLS_TENANT_MISMATCH'
      USING
        ERRCODE = 'P0001',
        DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, public.current_tenant_id());
  END IF;
END;
$$;


-- end: modules/iam/infrastructure/persistence/schema/00001_iam_baseline.sql

-- begin: modules/iam/infrastructure/persistence/schema/00002_iam_tenancy.sql
CREATE TABLE IF NOT EXISTS iam.tenants (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT tenants_name_nonempty_check CHECK (btrim(name) <> '')
);

CREATE TABLE IF NOT EXISTS iam.tenant_domains (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  hostname text NOT NULL,
  is_primary boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT tenant_domains_hostname_nonempty_check CHECK (hostname <> ''),
  CONSTRAINT tenant_domains_hostname_lower_check CHECK (hostname = lower(hostname)),
  CONSTRAINT tenant_domains_hostname_trim_check CHECK (hostname = btrim(hostname)),
  CONSTRAINT tenant_domains_hostname_no_port_check CHECK (position(':' in hostname) = 0)
);

CREATE UNIQUE INDEX IF NOT EXISTS tenant_domains_hostname_unique ON iam.tenant_domains (hostname);
CREATE INDEX IF NOT EXISTS tenant_domains_tenant_idx ON iam.tenant_domains (tenant_id);
CREATE UNIQUE INDEX IF NOT EXISTS tenant_domains_primary_unique ON iam.tenant_domains (tenant_id) WHERE is_primary = true;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT USAGE ON SCHEMA iam TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.tenants TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.tenant_domains TO superadmin_runtime';
  END IF;
END
$$;

-- end: modules/iam/infrastructure/persistence/schema/00002_iam_tenancy.sql

-- begin: modules/iam/infrastructure/persistence/schema/00003_iam_superadmin_audit.sql
CREATE TABLE IF NOT EXISTS iam.superadmin_audit_logs (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  actor text NOT NULL,
  action text NOT NULL,
  target_tenant_id uuid NULL REFERENCES iam.tenants(id) ON DELETE SET NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_audit_logs_actor_nonempty_check CHECK (btrim(actor) <> ''),
  CONSTRAINT superadmin_audit_logs_action_nonempty_check CHECK (btrim(action) <> ''),
  CONSTRAINT superadmin_audit_logs_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE UNIQUE INDEX IF NOT EXISTS superadmin_audit_logs_event_id_unique ON iam.superadmin_audit_logs (event_id);
CREATE INDEX IF NOT EXISTS superadmin_audit_logs_target_tenant_idx ON iam.superadmin_audit_logs (target_tenant_id, id);

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT INSERT, SELECT ON iam.superadmin_audit_logs TO superadmin_runtime';
    EXECUTE 'GRANT USAGE, SELECT ON SEQUENCE iam.superadmin_audit_logs_id_seq TO superadmin_runtime';
  END IF;
END
$$;

-- end: modules/iam/infrastructure/persistence/schema/00003_iam_superadmin_audit.sql

-- begin: modules/iam/infrastructure/persistence/schema/00004_iam_principals_and_sessions.sql
CREATE TABLE IF NOT EXISTS iam.principals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  email text NOT NULL,
  role_slug text NOT NULL,
  display_name text NULL,
  status text NOT NULL,
  kratos_identity_id uuid NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT principals_email_nonempty_check CHECK (btrim(email) <> ''),
  CONSTRAINT principals_email_lower_check CHECK (email = lower(email)),
  CONSTRAINT principals_email_trim_check CHECK (email = btrim(email)),
  CONSTRAINT principals_role_slug_nonempty_check CHECK (btrim(role_slug) <> ''),
  CONSTRAINT principals_role_slug_lower_check CHECK (role_slug = lower(role_slug)),
  CONSTRAINT principals_status_check CHECK (status IN ('active', 'disabled'))
);

CREATE UNIQUE INDEX IF NOT EXISTS principals_tenant_email_unique ON iam.principals (tenant_id, email);
CREATE INDEX IF NOT EXISTS principals_tenant_idx ON iam.principals (tenant_id);

CREATE TABLE IF NOT EXISTS iam.sessions (
  token_sha256 bytea PRIMARY KEY,
  tenant_id uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  principal_id uuid NOT NULL REFERENCES iam.principals(id) ON DELETE CASCADE,
  expires_at timestamptz NOT NULL,
  revoked_at timestamptz NULL,
  ip text NULL,
  user_agent text NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT sessions_token_sha256_len_check CHECK (octet_length(token_sha256) = 32)
);

CREATE INDEX IF NOT EXISTS sessions_tenant_idx ON iam.sessions (tenant_id);
CREATE INDEX IF NOT EXISTS sessions_principal_idx ON iam.sessions (principal_id);


-- end: modules/iam/infrastructure/persistence/schema/00004_iam_principals_and_sessions.sql

-- begin: modules/iam/infrastructure/persistence/schema/00005_iam_superadmin_principals_and_sessions.sql
CREATE TABLE IF NOT EXISTS iam.superadmin_principals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text NOT NULL UNIQUE,
  display_name text NULL,
  status text NOT NULL,
  kratos_identity_id uuid NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_principals_email_nonempty_check CHECK (btrim(email) <> ''),
  CONSTRAINT superadmin_principals_email_lower_check CHECK (email = lower(email)),
  CONSTRAINT superadmin_principals_email_trim_check CHECK (email = btrim(email)),
  CONSTRAINT superadmin_principals_status_check CHECK (status IN ('active', 'disabled'))
);

CREATE TABLE IF NOT EXISTS iam.superadmin_sessions (
  token_sha256 bytea PRIMARY KEY,
  principal_id uuid NOT NULL REFERENCES iam.superadmin_principals(id) ON DELETE CASCADE,
  expires_at timestamptz NOT NULL,
  revoked_at timestamptz NULL,
  ip text NULL,
  user_agent text NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_sessions_token_sha256_len_check CHECK (octet_length(token_sha256) = 32)
);

CREATE INDEX IF NOT EXISTS superadmin_sessions_principal_idx ON iam.superadmin_sessions (principal_id);

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.superadmin_principals TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.superadmin_sessions TO superadmin_runtime';
  END IF;
END
$$;


-- end: modules/iam/infrastructure/persistence/schema/00005_iam_superadmin_principals_and_sessions.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00001_orgunit_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS orgunit;


-- end: modules/orgunit/infrastructure/persistence/schema/00001_orgunit_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00002_orgunit_org_schema.sql
CREATE EXTENSION IF NOT EXISTS ltree;
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- uuid -> ltree label (32 hex)
CREATE OR REPLACE FUNCTION orgunit.org_ltree_label(p_id uuid)
RETURNS text
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT replace(lower(p_id::text), '-', '');
$$;

-- 32 hex -> uuid
CREATE OR REPLACE FUNCTION orgunit.org_uuid_from_hex32(p_hex text)
RETURNS uuid
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT (
    substr(p_hex, 1, 8) || '-' ||
    substr(p_hex, 9, 4) || '-' ||
    substr(p_hex, 13, 4) || '-' ||
    substr(p_hex, 17, 4) || '-' ||
    substr(p_hex, 21, 12)
  )::uuid;
$$;

-- ltree path -> uuid[] (for long name / ancestors join)
CREATE OR REPLACE FUNCTION orgunit.org_path_ids(p_path ltree)
RETURNS uuid[]
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT array_agg(orgunit.org_uuid_from_hex32(t.part) ORDER BY t.ord)
  FROM unnest(string_to_array(p_path::text, '.')) WITH ORDINALITY AS t(part, ord);
$$;

CREATE TABLE IF NOT EXISTS orgunit.org_trees (
  tenant_id uuid NOT NULL,
  hierarchy_type text NOT NULL DEFAULT 'OrgUnit',
  root_org_id uuid NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, hierarchy_type),
  CONSTRAINT org_trees_hierarchy_type_check CHECK (hierarchy_type IN ('OrgUnit'))
);

CREATE TABLE IF NOT EXISTS orgunit.org_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  hierarchy_type text NOT NULL DEFAULT 'OrgUnit',
  org_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT org_events_hierarchy_type_check CHECK (hierarchy_type IN ('OrgUnit')),
  CONSTRAINT org_events_event_type_check CHECK (event_type IN ('CREATE','MOVE','RENAME','DISABLE')),
  CONSTRAINT org_events_one_per_day_unique UNIQUE (tenant_id, hierarchy_type, org_id, effective_date)
);

CREATE UNIQUE INDEX IF NOT EXISTS org_events_event_id_unique ON orgunit.org_events (event_id);
CREATE INDEX IF NOT EXISTS org_events_tenant_org_effective_idx ON orgunit.org_events (tenant_id, org_id, effective_date, id);
CREATE INDEX IF NOT EXISTS org_events_tenant_type_effective_idx ON orgunit.org_events (tenant_id, hierarchy_type, effective_date, id);

CREATE TABLE IF NOT EXISTS orgunit.org_unit_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  hierarchy_type text NOT NULL DEFAULT 'OrgUnit',
  org_id uuid NOT NULL,
  parent_id uuid NULL,
  node_path ltree NOT NULL,
  validity daterange NOT NULL,
  path_ids uuid[] GENERATED ALWAYS AS (orgunit.org_path_ids(node_path)) STORED,
  name varchar(255) NOT NULL,
  status text NOT NULL DEFAULT 'active',
  manager_id uuid NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.org_events(id),
  CONSTRAINT org_unit_versions_hierarchy_type_check CHECK (hierarchy_type IN ('OrgUnit')),
  CONSTRAINT org_unit_versions_status_check CHECK (status IN ('active','disabled')),
  CONSTRAINT org_unit_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT org_unit_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT org_unit_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      hierarchy_type gist_text_ops WITH =,
      org_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS org_unit_versions_search_gist
  ON orgunit.org_unit_versions
  USING gist (tenant_id gist_uuid_ops, hierarchy_type gist_text_ops, node_path, validity);

CREATE INDEX IF NOT EXISTS org_unit_versions_active_day_gist
  ON orgunit.org_unit_versions
  USING gist (tenant_id gist_uuid_ops, hierarchy_type gist_text_ops, validity)
  WHERE status = 'active';

CREATE INDEX IF NOT EXISTS org_unit_versions_lookup_btree
  ON orgunit.org_unit_versions (tenant_id, hierarchy_type, org_id, lower(validity));

CREATE INDEX IF NOT EXISTS org_unit_versions_path_ids_gin
  ON orgunit.org_unit_versions
  USING gin (path_ids);

ALTER TABLE orgunit.org_trees ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_trees FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_trees;
CREATE POLICY tenant_isolation ON orgunit.org_trees
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.org_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_events;
CREATE POLICY tenant_isolation ON orgunit.org_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.org_unit_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_unit_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_unit_versions;
CREATE POLICY tenant_isolation ON orgunit.org_unit_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/orgunit/infrastructure/persistence/schema/00002_orgunit_org_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00003_orgunit_engine.sql
CREATE OR REPLACE FUNCTION orgunit.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'tenant_id is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_id THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.split_org_unit_version_at(
  p_tenant_id uuid,
  p_hierarchy_type text,
  p_org_id uuid,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_row orgunit.org_unit_versions%ROWTYPE;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  SELECT * INTO v_row
  FROM orgunit.org_unit_versions
  WHERE tenant_id = p_tenant_id
    AND hierarchy_type = p_hierarchy_type
    AND org_id = p_org_id
    AND validity @> p_effective_date
    AND lower(validity) < p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  UPDATE orgunit.org_unit_versions
  SET validity = daterange(lower(validity), p_effective_date, '[)')
  WHERE id = v_row.id;

  INSERT INTO orgunit.org_unit_versions (
    tenant_id,
    hierarchy_type,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    status,
    manager_id,
    last_event_id
  )
  VALUES (
    v_row.tenant_id,
    v_row.hierarchy_type,
    v_row.org_id,
    v_row.parent_id,
    v_row.node_path,
    daterange(p_effective_date, upper(v_row.validity), '[)'),
    v_row.name,
    v_row.status,
    v_row.manager_id,
    p_event_db_id
  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_create_logic(
  p_tenant_id uuid,
  p_hierarchy_type text,
  p_org_id uuid,
  p_parent_id uuid,
  p_effective_date date,
  p_name text,
  p_manager_id uuid,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_parent_path ltree;
  v_node_path ltree;
  v_root_org_id uuid;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_name IS NULL OR btrim(p_name) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'name is required';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_id = p_tenant_id AND hierarchy_type = p_hierarchy_type AND org_id = p_org_id
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_ALREADY_EXISTS', DETAIL = format('org_id=%s', p_org_id);
  END IF;

  IF p_parent_id IS NULL THEN
    SELECT t.root_org_id INTO v_root_org_id
    FROM orgunit.org_trees t
    WHERE t.tenant_id = p_tenant_id AND t.hierarchy_type = p_hierarchy_type
    FOR UPDATE;

    IF v_root_org_id IS NOT NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_ROOT_ALREADY_EXISTS',
        DETAIL = format('root_org_id=%s', v_root_org_id);
    END IF;

    INSERT INTO orgunit.org_trees (tenant_id, hierarchy_type, root_org_id)
    VALUES (p_tenant_id, p_hierarchy_type, p_org_id);

    v_node_path := text2ltree(orgunit.org_ltree_label(p_org_id));
  ELSE
    SELECT t.root_org_id INTO v_root_org_id
    FROM orgunit.org_trees t
    WHERE t.tenant_id = p_tenant_id AND t.hierarchy_type = p_hierarchy_type;

    IF v_root_org_id IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_TREE_NOT_INITIALIZED',
        DETAIL = format('tenant_id=%s', p_tenant_id);
    END IF;

    SELECT v.node_path INTO v_parent_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_id = p_tenant_id
      AND v.hierarchy_type = p_hierarchy_type
      AND v.org_id = p_parent_id
      AND v.status = 'active'
      AND v.validity @> p_effective_date
    LIMIT 1;

    IF v_parent_path IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_PARENT_NOT_FOUND_AS_OF',
        DETAIL = format('parent_id=%s as_of=%s', p_parent_id, p_effective_date);
    END IF;

    v_node_path := v_parent_path || text2ltree(orgunit.org_ltree_label(p_org_id));
  END IF;

  INSERT INTO orgunit.org_unit_versions (
    tenant_id,
    hierarchy_type,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    status,
    manager_id,
    last_event_id
  )
  VALUES (
    p_tenant_id,
	    p_hierarchy_type,
	    p_org_id,
	    p_parent_id,
	    v_node_path,
	    daterange(p_effective_date, NULL, '[)'),
	    p_name,
	    'active',
	    p_manager_id,
	    p_event_db_id
	  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_move_logic(
  p_tenant_id uuid,
  p_hierarchy_type text,
  p_org_id uuid,
  p_new_parent_id uuid,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_root_org_id uuid;
  v_old_path ltree;
  v_new_parent_path ltree;
  v_new_prefix ltree;
  v_old_level int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_new_parent_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'new_parent_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_id = p_tenant_id AND t.hierarchy_type = p_hierarchy_type;

  IF v_root_org_id IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_TREE_NOT_INITIALIZED',
      DETAIL = format('tenant_id=%s', p_tenant_id);
  END IF;
  IF v_root_org_id = p_org_id THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ROOT_CANNOT_BE_MOVED',
      DETAIL = format('root_org_id=%s', v_root_org_id);
  END IF;

  SELECT v.node_path INTO v_old_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_id = p_tenant_id
    AND v.hierarchy_type = p_hierarchy_type
    AND v.org_id = p_org_id
    AND v.status = 'active'
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1
  FOR UPDATE;

  IF v_old_path IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  SELECT v.node_path INTO v_new_parent_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_id = p_tenant_id
    AND v.hierarchy_type = p_hierarchy_type
    AND v.org_id = p_new_parent_id
    AND v.status = 'active'
    AND v.validity @> p_effective_date
  LIMIT 1;

  IF v_new_parent_path IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_PARENT_NOT_FOUND_AS_OF',
      DETAIL = format('parent_id=%s as_of=%s', p_new_parent_id, p_effective_date);
  END IF;

  IF v_new_parent_path <@ v_old_path THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_CYCLE_MOVE',
      DETAIL = format('cycle move: org_id=%s new_parent_id=%s', p_org_id, p_new_parent_id);
  END IF;

  v_new_prefix := v_new_parent_path || text2ltree(orgunit.org_ltree_label(p_org_id));
  v_old_level := nlevel(v_old_path);

  WITH split AS (
    SELECT *
    FROM orgunit.org_unit_versions
    WHERE tenant_id = p_tenant_id
      AND hierarchy_type = p_hierarchy_type
      AND node_path <@ v_old_path
      AND validity @> p_effective_date
      AND lower(validity) < p_effective_date
  ),
  upd AS (
    UPDATE orgunit.org_unit_versions v
    SET validity = daterange(lower(v.validity), p_effective_date, '[)')
    FROM split s
    WHERE v.id = s.id
    RETURNING s.*
  )
  INSERT INTO orgunit.org_unit_versions (
    tenant_id,
    hierarchy_type,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    status,
    manager_id,
    last_event_id
  )
  SELECT
    u.tenant_id,
    u.hierarchy_type,
    u.org_id,
    CASE WHEN u.org_id = p_org_id THEN p_new_parent_id ELSE u.parent_id END,
    CASE
      WHEN u.org_id = p_org_id THEN v_new_prefix
      ELSE v_new_prefix || subpath(u.node_path, v_old_level)
    END,
    daterange(p_effective_date, upper(u.validity), '[)'),
    u.name,
    u.status,
    u.manager_id,
    p_event_db_id
  FROM upd u;

  UPDATE orgunit.org_unit_versions v
  SET
    node_path = CASE
        WHEN v.org_id = p_org_id THEN v_new_prefix
        ELSE v_new_prefix || subpath(v.node_path, v_old_level)
      END,
    parent_id = CASE WHEN v.org_id = p_org_id THEN p_new_parent_id ELSE v.parent_id END,
    last_event_id = p_event_db_id
  WHERE v.tenant_id = p_tenant_id
    AND v.hierarchy_type = p_hierarchy_type
    AND v.node_path <@ v_old_path
    AND lower(v.validity) >= p_effective_date;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_rename_logic(
  p_tenant_id uuid,
  p_hierarchy_type text,
  p_org_id uuid,
  p_effective_date date,
  p_new_name text,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_stop_date date;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_new_name IS NULL OR btrim(p_new_name) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'new_name is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_id = p_tenant_id
      AND hierarchy_type = p_hierarchy_type
      AND org_id = p_org_id
      AND validity @> p_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_id, p_hierarchy_type, p_org_id, p_effective_date, p_event_db_id);

  SELECT MIN(e.effective_date) INTO v_stop_date
  FROM orgunit.org_events e
  WHERE e.tenant_id = p_tenant_id
    AND e.hierarchy_type = p_hierarchy_type
    AND e.org_id = p_org_id
    AND e.event_type = 'RENAME'
    AND e.effective_date > p_effective_date;

  UPDATE orgunit.org_unit_versions
  SET name = p_new_name, last_event_id = p_event_db_id
  WHERE tenant_id = p_tenant_id
    AND hierarchy_type = p_hierarchy_type
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date
    AND (v_stop_date IS NULL OR lower(validity) < v_stop_date);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_disable_logic(
  p_tenant_id uuid,
  p_hierarchy_type text,
  p_org_id uuid,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_id = p_tenant_id
      AND hierarchy_type = p_hierarchy_type
      AND org_id = p_org_id
      AND validity @> p_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_id, p_hierarchy_type, p_org_id, p_effective_date, p_event_db_id);

  UPDATE orgunit.org_unit_versions
  SET status = 'disabled', last_event_id = p_event_db_id
  WHERE tenant_id = p_tenant_id
    AND hierarchy_type = p_hierarchy_type
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.replay_org_unit_versions(
  p_tenant_id uuid,
  p_hierarchy_type text
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event orgunit.org_events%ROWTYPE;
  v_payload jsonb;
  v_parent_id uuid;
  v_new_parent_id uuid;
  v_name text;
  v_new_name text;
  v_manager_id uuid;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;

  v_lock_key := format('org:write-lock:%s:%s', p_tenant_id, p_hierarchy_type);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM orgunit.org_unit_versions
  WHERE tenant_id = p_tenant_id AND hierarchy_type = p_hierarchy_type;

  DELETE FROM orgunit.org_trees
  WHERE tenant_id = p_tenant_id AND hierarchy_type = p_hierarchy_type;

  FOR v_event IN
    SELECT *
    FROM orgunit.org_events
    WHERE tenant_id = p_tenant_id AND hierarchy_type = p_hierarchy_type
    ORDER BY effective_date, id
  LOOP
    v_payload := COALESCE(v_event.payload, '{}'::jsonb);

    IF v_event.event_type = 'CREATE' THEN
      v_parent_id := NULLIF(v_payload->>'parent_id', '')::uuid;
      v_name := NULLIF(btrim(v_payload->>'name'), '');
      v_manager_id := NULLIF(v_payload->>'manager_id', '')::uuid;
      PERFORM orgunit.apply_create_logic(p_tenant_id, p_hierarchy_type, v_event.org_id, v_parent_id, v_event.effective_date, v_name, v_manager_id, v_event.id);
    ELSIF v_event.event_type = 'MOVE' THEN
      v_new_parent_id := NULLIF(v_payload->>'new_parent_id', '')::uuid;
      PERFORM orgunit.apply_move_logic(p_tenant_id, p_hierarchy_type, v_event.org_id, v_new_parent_id, v_event.effective_date, v_event.id);
    ELSIF v_event.event_type = 'RENAME' THEN
      v_new_name := NULLIF(btrim(v_payload->>'new_name'), '');
      PERFORM orgunit.apply_rename_logic(p_tenant_id, p_hierarchy_type, v_event.org_id, v_event.effective_date, v_new_name, v_event.id);
    ELSIF v_event.event_type = 'DISABLE' THEN
      PERFORM orgunit.apply_disable_logic(p_tenant_id, p_hierarchy_type, v_event.org_id, v_event.effective_date, v_event.id);
    ELSE
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_event.event_type);
    END IF;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        org_id,
        validity,
        lag(validity) OVER (PARTITION BY org_id ORDER BY lower(validity)) AS prev_validity
      FROM orgunit.org_unit_versions
      WHERE tenant_id = p_tenant_id AND hierarchy_type = p_hierarchy_type
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_VALIDITY_GAP',
      DETAIL = 'org_unit_versions must be gapless';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT DISTINCT ON (org_id) org_id, validity
      FROM orgunit.org_unit_versions
      WHERE tenant_id = p_tenant_id AND hierarchy_type = p_hierarchy_type
      ORDER BY org_id, lower(validity) DESC
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_VALIDITY_NOT_INFINITE',
      DETAIL = 'last version validity must be unbounded (infinity)';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_org_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_hierarchy_type text,
  p_org_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing orgunit.org_events%ROWTYPE;
  v_payload jsonb;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_event_type NOT IN ('CREATE','MOVE','RENAME','DISABLE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_lock_key := format('org:write-lock:%s:%s', p_tenant_id, p_hierarchy_type);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);

  INSERT INTO orgunit.org_events (
    event_id,
    tenant_id,
    hierarchy_type,
    org_id,
    event_type,
    effective_date,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_hierarchy_type,
    p_org_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM orgunit.org_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.hierarchy_type <> p_hierarchy_type
      OR v_existing.org_id <> p_org_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM orgunit.replay_org_unit_versions(p_tenant_id, p_hierarchy_type);

  RETURN v_event_db_id;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00003_orgunit_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00004_orgunit_read.sql
CREATE OR REPLACE FUNCTION orgunit.get_org_snapshot(p_tenant_id uuid, p_query_date date)
RETURNS TABLE (
  org_id uuid,
  parent_id uuid,
  name varchar(255),
  full_name_path text,
  depth int,
  manager_id uuid,
  node_path ltree
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);

  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  RETURN QUERY
  WITH snapshot AS (
    SELECT
      v.org_id,
      v.parent_id,
      v.node_path,
      v.name,
      v.manager_id,
      v.path_ids
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_id = p_tenant_id
      AND v.hierarchy_type = 'OrgUnit'
      AND v.status = 'active'
      AND v.validity @> p_query_date
  )
  SELECT
    s.org_id,
    s.parent_id,
    s.name,
    (
      SELECT string_agg(a.name, ' / ' ORDER BY t.idx)
      FROM unnest(s.path_ids) WITH ORDINALITY AS t(uid, idx)
      JOIN orgunit.org_unit_versions a
        ON a.tenant_id = p_tenant_id
       AND a.hierarchy_type = 'OrgUnit'
       AND a.org_id = t.uid
       AND a.validity @> p_query_date
    ) AS full_name_path,
    nlevel(s.node_path) - 1 AS depth,
    s.manager_id,
    s.node_path
  FROM snapshot s
  ORDER BY s.node_path;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00004_orgunit_read.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00005_orgunit_setid_schema.sql
CREATE TABLE IF NOT EXISTS orgunit.setid_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  event_type text NOT NULL,
  setid text NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_events_event_type_check CHECK (event_type IN ('BOOTSTRAP','CREATE','RENAME','DISABLE')),
  CONSTRAINT setid_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT setid_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE UNIQUE INDEX IF NOT EXISTS setid_events_event_id_unique ON orgunit.setid_events (event_id);
CREATE INDEX IF NOT EXISTS setid_events_tenant_time_idx ON orgunit.setid_events (tenant_id, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.setids (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, setid),
  CONSTRAINT setids_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT setids_status_check CHECK (status IN ('active','disabled')),
  CONSTRAINT setids_share_must_be_active CHECK (setid <> 'SHARE' OR status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.business_unit_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  event_type text NOT NULL,
  business_unit_id text NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT business_unit_events_event_type_check CHECK (event_type IN ('BOOTSTRAP','CREATE','RENAME','DISABLE')),
  CONSTRAINT business_unit_events_id_format_check CHECK (business_unit_id ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT business_unit_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE UNIQUE INDEX IF NOT EXISTS business_unit_events_event_id_unique ON orgunit.business_unit_events (event_id);
CREATE INDEX IF NOT EXISTS business_unit_events_tenant_time_idx ON orgunit.business_unit_events (tenant_id, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.business_units (
  tenant_id uuid NOT NULL,
  business_unit_id text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  last_event_id bigint NOT NULL REFERENCES orgunit.business_unit_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, business_unit_id),
  CONSTRAINT business_units_id_format_check CHECK (business_unit_id ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT business_units_status_check CHECK (status IN ('active','disabled'))
);

CREATE TABLE IF NOT EXISTS orgunit.set_control_mapping_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  event_type text NOT NULL,
  record_group text NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT set_control_mapping_events_event_type_check CHECK (event_type IN ('BOOTSTRAP','PUT')),
  CONSTRAINT set_control_mapping_events_record_group_check CHECK (record_group IN ('jobcatalog')),
  CONSTRAINT set_control_mapping_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE UNIQUE INDEX IF NOT EXISTS set_control_mapping_events_event_id_unique ON orgunit.set_control_mapping_events (event_id);
CREATE INDEX IF NOT EXISTS set_control_mapping_events_tenant_time_idx ON orgunit.set_control_mapping_events (tenant_id, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.set_control_mappings (
  tenant_id uuid NOT NULL,
  business_unit_id text NOT NULL,
  record_group text NOT NULL,
  setid text NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.set_control_mapping_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, business_unit_id, record_group),
  CONSTRAINT set_control_mappings_record_group_check CHECK (record_group IN ('jobcatalog')),
  CONSTRAINT set_control_mappings_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT set_control_mappings_bu_format_check CHECK (business_unit_id ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT set_control_mappings_setid_fk FOREIGN KEY (tenant_id, setid) REFERENCES orgunit.setids (tenant_id, setid),
  CONSTRAINT set_control_mappings_bu_fk FOREIGN KEY (tenant_id, business_unit_id) REFERENCES orgunit.business_units (tenant_id, business_unit_id)
);

ALTER TABLE orgunit.setid_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_events;
CREATE POLICY tenant_isolation ON orgunit.setid_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setids ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setids FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setids;
CREATE POLICY tenant_isolation ON orgunit.setids
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.business_unit_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.business_unit_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.business_unit_events;
CREATE POLICY tenant_isolation ON orgunit.business_unit_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.business_units ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.business_units FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.business_units;
CREATE POLICY tenant_isolation ON orgunit.business_units
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.set_control_mapping_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.set_control_mapping_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.set_control_mapping_events;
CREATE POLICY tenant_isolation ON orgunit.set_control_mapping_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.set_control_mappings ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.set_control_mappings FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.set_control_mappings;
CREATE POLICY tenant_isolation ON orgunit.set_control_mappings
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/orgunit/infrastructure/persistence/schema/00005_orgunit_setid_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00006_orgunit_setid_engine.sql
CREATE OR REPLACE FUNCTION orgunit.normalize_setid(p_setid text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v text;
BEGIN
  IF p_setid IS NULL OR btrim(p_setid) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_FORMAT',
      DETAIL = 'setid is required';
  END IF;

  v := upper(btrim(p_setid));
  IF v !~ '^[A-Z0-9]{1,5}$' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_FORMAT',
      DETAIL = format('setid=%s', v);
  END IF;

  RETURN v;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.normalize_business_unit_id(p_business_unit_id text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v text;
BEGIN
  IF p_business_unit_id IS NULL OR btrim(p_business_unit_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'BUSINESS_UNIT_INVALID_ID',
      DETAIL = 'business_unit_id is required';
  END IF;

  v := upper(btrim(p_business_unit_id));
  IF v !~ '^[A-Z0-9]{1,5}$' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'BUSINESS_UNIT_INVALID_ID',
      DETAIL = format('business_unit_id=%s', v);
  END IF;

  RETURN v;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.assert_record_group(p_record_group text)
RETURNS void
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  IF p_record_group IS NULL OR btrim(p_record_group) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RECORD_GROUP_UNKNOWN',
      DETAIL = 'record_group is required';
  END IF;
  IF p_record_group <> 'jobcatalog' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RECORD_GROUP_UNKNOWN',
      DETAIL = format('record_group=%s', p_record_group);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.lock_setid_governance(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  k bigint;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);
  k := hashtextextended('orgunit.setid.governance:' || p_tenant_id::text, 0);
  PERFORM pg_advisory_xact_lock(k);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.ensure_setid_bootstrap(
  p_tenant_id uuid,
  p_initiator_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_evt_id uuid;
  v_evt_db_id bigint;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);
  PERFORM orgunit.lock_setid_governance(p_tenant_id);

  IF NOT EXISTS (
    SELECT 1 FROM orgunit.setids WHERE tenant_id = p_tenant_id AND setid = 'SHARE'
  ) THEN
    v_evt_id := gen_random_uuid();
    INSERT INTO orgunit.setid_events (event_id, tenant_id, event_type, setid, payload, request_id, initiator_id)
    VALUES (v_evt_id, p_tenant_id, 'BOOTSTRAP', 'SHARE', jsonb_build_object('name', 'Shared'), 'bootstrap:share', p_initiator_id)
    ON CONFLICT (tenant_id, request_id) DO NOTHING;

    SELECT id INTO v_evt_db_id
    FROM orgunit.setid_events
    WHERE tenant_id = p_tenant_id AND request_id = 'bootstrap:share'
    ORDER BY id DESC
    LIMIT 1;

    INSERT INTO orgunit.setids (tenant_id, setid, name, status, last_event_id)
    VALUES (p_tenant_id, 'SHARE', 'Shared', 'active', v_evt_db_id)
    ON CONFLICT (tenant_id, setid) DO NOTHING;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM orgunit.business_units WHERE tenant_id = p_tenant_id AND business_unit_id = 'BU000'
  ) THEN
    v_evt_id := gen_random_uuid();
    INSERT INTO orgunit.business_unit_events (event_id, tenant_id, event_type, business_unit_id, payload, request_id, initiator_id)
    VALUES (v_evt_id, p_tenant_id, 'BOOTSTRAP', 'BU000', jsonb_build_object('name', 'Default BU'), 'bootstrap:bu000', p_initiator_id)
    ON CONFLICT (tenant_id, request_id) DO NOTHING;

    SELECT id INTO v_evt_db_id
    FROM orgunit.business_unit_events
    WHERE tenant_id = p_tenant_id AND request_id = 'bootstrap:bu000'
    ORDER BY id DESC
    LIMIT 1;

    INSERT INTO orgunit.business_units (tenant_id, business_unit_id, name, status, last_event_id)
    VALUES (p_tenant_id, 'BU000', 'Default BU', 'active', v_evt_db_id)
    ON CONFLICT (tenant_id, business_unit_id) DO NOTHING;
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.set_control_mappings
    WHERE tenant_id = p_tenant_id AND business_unit_id = 'BU000' AND record_group = 'jobcatalog'
  ) THEN
    v_evt_id := gen_random_uuid();
    INSERT INTO orgunit.set_control_mapping_events (event_id, tenant_id, event_type, record_group, payload, request_id, initiator_id)
    VALUES (
      v_evt_id,
      p_tenant_id,
      'BOOTSTRAP',
      'jobcatalog',
      jsonb_build_object('mappings', jsonb_build_array(jsonb_build_object('business_unit_id', 'BU000', 'setid', 'SHARE'))),
      'bootstrap:mappings:jobcatalog',
      p_initiator_id
    )
    ON CONFLICT (tenant_id, request_id) DO NOTHING;

    SELECT id INTO v_evt_db_id
    FROM orgunit.set_control_mapping_events
    WHERE tenant_id = p_tenant_id AND request_id = 'bootstrap:mappings:jobcatalog'
    ORDER BY id DESC
    LIMIT 1;

    INSERT INTO orgunit.set_control_mappings (tenant_id, business_unit_id, record_group, setid, last_event_id)
    VALUES (p_tenant_id, 'BU000', 'jobcatalog', 'SHARE', v_evt_db_id)
    ON CONFLICT (tenant_id, business_unit_id, record_group) DO NOTHING;
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_setid_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_event_type text,
  p_setid text,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_name text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);
  PERFORM orgunit.lock_setid_governance(p_tenant_id);

  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;

  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'event_type is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' AND p_event_type <> 'BOOTSTRAP' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED',
      DETAIL = 'SHARE is reserved';
  END IF;

  INSERT INTO orgunit.setid_events (event_id, tenant_id, event_type, setid, payload, request_id, initiator_id)
  VALUES (p_event_id, p_tenant_id, p_event_type, v_setid, COALESCE(p_payload, '{}'::jsonb), p_request_id, p_initiator_id)
  ON CONFLICT (tenant_id, request_id) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_events
  WHERE tenant_id = p_tenant_id AND request_id = p_request_id
  ORDER BY id DESC
  LIMIT 1;

  IF p_event_type IN ('BOOTSTRAP','CREATE') THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    IF p_event_type = 'CREATE' AND EXISTS (
      SELECT 1 FROM orgunit.setids WHERE tenant_id = p_tenant_id AND setid = v_setid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_ALREADY_EXISTS',
        DETAIL = format('setid=%s', v_setid);
    END IF;

    INSERT INTO orgunit.setids (tenant_id, setid, name, status, last_event_id)
    VALUES (p_tenant_id, v_setid, v_name, 'active', v_evt_db_id)
    ON CONFLICT (tenant_id, setid) DO UPDATE
    SET name = EXCLUDED.name,
        status = 'active',
        last_event_id = EXCLUDED.last_event_id,
        updated_at = now();
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;
    UPDATE orgunit.setids
    SET name = v_name,
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_id = p_tenant_id AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
  ELSIF p_event_type = 'DISABLE' THEN
    IF v_setid = 'SHARE' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_RESERVED',
        DETAIL = 'SHARE is reserved';
    END IF;
    IF EXISTS (
      SELECT 1 FROM orgunit.set_control_mappings
      WHERE tenant_id = p_tenant_id AND setid = v_setid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_IN_USE',
        DETAIL = format('setid=%s', v_setid);
    END IF;
    UPDATE orgunit.setids
    SET status = 'disabled',
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_id = p_tenant_id AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_business_unit_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_event_type text,
  p_business_unit_id text,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_bu text;
  v_evt_db_id bigint;
  v_name text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);
  PERFORM orgunit.lock_setid_governance(p_tenant_id);
  PERFORM orgunit.ensure_setid_bootstrap(p_tenant_id, p_initiator_id);

  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'BUSINESS_UNIT_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'BUSINESS_UNIT_INVALID_ARGUMENT',
      DETAIL = 'event_type is required';
  END IF;

  v_bu := orgunit.normalize_business_unit_id(p_business_unit_id);

  INSERT INTO orgunit.business_unit_events (event_id, tenant_id, event_type, business_unit_id, payload, request_id, initiator_id)
  VALUES (p_event_id, p_tenant_id, p_event_type, v_bu, COALESCE(p_payload, '{}'::jsonb), p_request_id, p_initiator_id)
  ON CONFLICT (tenant_id, request_id) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.business_unit_events
  WHERE tenant_id = p_tenant_id AND request_id = p_request_id
  ORDER BY id DESC
  LIMIT 1;

  IF p_event_type IN ('BOOTSTRAP','CREATE') THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'BUSINESS_UNIT_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    IF p_event_type = 'CREATE' AND EXISTS (
      SELECT 1 FROM orgunit.business_units WHERE tenant_id = p_tenant_id AND business_unit_id = v_bu
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'BUSINESS_UNIT_ALREADY_EXISTS',
        DETAIL = format('business_unit_id=%s', v_bu);
    END IF;

    INSERT INTO orgunit.business_units (tenant_id, business_unit_id, name, status, last_event_id)
    VALUES (p_tenant_id, v_bu, v_name, 'active', v_evt_db_id)
    ON CONFLICT (tenant_id, business_unit_id) DO UPDATE
    SET name = EXCLUDED.name,
        status = 'active',
        last_event_id = EXCLUDED.last_event_id,
        updated_at = now();

    IF NOT EXISTS (
      SELECT 1 FROM orgunit.set_control_mappings
      WHERE tenant_id = p_tenant_id AND business_unit_id = v_bu AND record_group = 'jobcatalog'
    ) THEN
      PERFORM orgunit.put_set_control_mappings(
        gen_random_uuid(),
        p_tenant_id,
        'jobcatalog',
        jsonb_build_array(jsonb_build_object('business_unit_id', v_bu, 'setid', 'SHARE')),
        'bootstrap:mappings:jobcatalog:' || v_bu,
        p_initiator_id
      );
    END IF;
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'BUSINESS_UNIT_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;
    UPDATE orgunit.business_units
    SET name = v_name,
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_id = p_tenant_id AND business_unit_id = v_bu;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'BUSINESS_UNIT_NOT_FOUND',
        DETAIL = format('business_unit_id=%s', v_bu);
    END IF;
  ELSIF p_event_type = 'DISABLE' THEN
    UPDATE orgunit.business_units
    SET status = 'disabled',
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_id = p_tenant_id AND business_unit_id = v_bu;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'BUSINESS_UNIT_NOT_FOUND',
        DETAIL = format('business_unit_id=%s', v_bu);
    END IF;
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'BUSINESS_UNIT_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.put_set_control_mappings(
  p_event_id uuid,
  p_tenant_id uuid,
  p_record_group text,
  p_mappings jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_evt_db_id bigint;
  v_row jsonb;
  v_bu text;
  v_setid text;
  v_disabled text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);
  PERFORM orgunit.lock_setid_governance(p_tenant_id);
  PERFORM orgunit.assert_record_group(p_record_group);
  PERFORM orgunit.ensure_setid_bootstrap(p_tenant_id, p_initiator_id);

  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF jsonb_typeof(p_mappings) <> 'array' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'mappings must be an array';
  END IF;

  INSERT INTO orgunit.set_control_mapping_events (event_id, tenant_id, event_type, record_group, payload, request_id, initiator_id)
  VALUES (p_event_id, p_tenant_id, 'PUT', p_record_group, jsonb_build_object('mappings', p_mappings), p_request_id, p_initiator_id)
  ON CONFLICT (tenant_id, request_id) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.set_control_mapping_events
  WHERE tenant_id = p_tenant_id AND request_id = p_request_id
  ORDER BY id DESC
  LIMIT 1;

  FOR v_row IN SELECT * FROM jsonb_array_elements(p_mappings)
  LOOP
    v_bu := orgunit.normalize_business_unit_id(v_row->>'business_unit_id');
    v_setid := orgunit.normalize_setid(v_row->>'setid');

    SELECT status INTO v_disabled
    FROM orgunit.business_units
    WHERE tenant_id = p_tenant_id AND business_unit_id = v_bu;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'BUSINESS_UNIT_NOT_FOUND',
        DETAIL = format('business_unit_id=%s', v_bu);
    END IF;
    IF v_disabled = 'disabled' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'BUSINESS_UNIT_DISABLED',
        DETAIL = format('business_unit_id=%s', v_bu);
    END IF;

    SELECT status INTO v_disabled
    FROM orgunit.setids
    WHERE tenant_id = p_tenant_id AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
    IF v_disabled = 'disabled' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_DISABLED',
        DETAIL = format('setid=%s', v_setid);
    END IF;

    INSERT INTO orgunit.set_control_mappings (tenant_id, business_unit_id, record_group, setid, last_event_id, updated_at)
    VALUES (p_tenant_id, v_bu, p_record_group, v_setid, v_evt_db_id, now())
    ON CONFLICT (tenant_id, business_unit_id, record_group) DO UPDATE
    SET setid = EXCLUDED.setid,
        last_event_id = EXCLUDED.last_event_id,
        updated_at = now();
  END LOOP;

  IF EXISTS (
    SELECT 1
    FROM orgunit.business_units bu
    WHERE bu.tenant_id = p_tenant_id
      AND bu.status = 'active'
      AND NOT EXISTS (
        SELECT 1
        FROM orgunit.set_control_mappings m
        WHERE m.tenant_id = bu.tenant_id
          AND m.business_unit_id = bu.business_unit_id
          AND m.record_group = p_record_group
      )
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_MAPPING_MISSING',
      DETAIL = format('record_group=%s', p_record_group);
  END IF;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.resolve_setid(
  p_tenant_id uuid,
  p_business_unit_id text,
  p_record_group text
)
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
  v_bu text;
  v_rg text;
  v_setid text;
  v_status text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);
  v_bu := orgunit.normalize_business_unit_id(p_business_unit_id);
  v_rg := lower(btrim(p_record_group));
  PERFORM orgunit.assert_record_group(v_rg);

  SELECT status INTO v_status
  FROM orgunit.business_units
  WHERE tenant_id = p_tenant_id AND business_unit_id = v_bu;
  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'BUSINESS_UNIT_NOT_FOUND',
      DETAIL = format('business_unit_id=%s', v_bu);
  END IF;
  IF v_status = 'disabled' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'BUSINESS_UNIT_DISABLED',
      DETAIL = format('business_unit_id=%s', v_bu);
  END IF;

  SELECT setid INTO v_setid
  FROM orgunit.set_control_mappings
  WHERE tenant_id = p_tenant_id
    AND business_unit_id = v_bu
    AND record_group = v_rg;
  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_MAPPING_MISSING',
      DETAIL = format('business_unit_id=%s record_group=%s', v_bu, v_rg);
  END IF;

  SELECT status INTO v_status
  FROM orgunit.setids
  WHERE tenant_id = p_tenant_id AND setid = v_setid;
  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_NOT_FOUND',
      DETAIL = format('setid=%s', v_setid);
  END IF;
  IF v_status = 'disabled' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_DISABLED',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  RETURN v_setid;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.assert_setid_active(
  p_tenant_id uuid,
  p_setid text
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_status text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_id);
  v_setid := orgunit.normalize_setid(p_setid);

  SELECT status INTO v_status
  FROM orgunit.setids
  WHERE tenant_id = p_tenant_id AND setid = v_setid;
  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_NOT_FOUND',
      DETAIL = format('setid=%s', v_setid);
  END IF;
  IF v_status = 'disabled' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_DISABLED',
      DETAIL = format('setid=%s', v_setid);
  END IF;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00006_orgunit_setid_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00001_jobcatalog_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE SCHEMA IF NOT EXISTS jobcatalog;


-- end: modules/jobcatalog/infrastructure/persistence/schema/00001_jobcatalog_schema.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00002_jobcatalog_job_family_groups.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_family_groups (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_groups_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_family_groups_tenant_setid_code_key UNIQUE (tenant_id, setid, code),
  CONSTRAINT job_family_groups_tenant_setid_id_unique UNIQUE (tenant_id, setid, id)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_group_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_family_group_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_group_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_family_group_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_family_group_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT job_family_group_events_one_per_day_unique UNIQUE (tenant_id, setid, job_family_group_id, effective_date),
  CONSTRAINT job_family_group_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT job_family_group_events_group_fk
    FOREIGN KEY (tenant_id, setid, job_family_group_id) REFERENCES jobcatalog.job_family_groups(tenant_id, setid, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_family_group_events_tenant_effective_idx
  ON jobcatalog.job_family_group_events (tenant_id, setid, job_family_group_id, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_group_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_family_group_id uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_family_group_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_group_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_family_group_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_family_group_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_family_group_versions_group_fk
    FOREIGN KEY (tenant_id, setid, job_family_group_id) REFERENCES jobcatalog.job_family_groups(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_family_group_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_family_group_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_family_group_versions_active_day_gist
  ON jobcatalog.job_family_group_versions
  USING gist (tenant_id gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_family_group_versions_lookup_btree
  ON jobcatalog.job_family_group_versions (tenant_id, setid, job_family_group_id, lower(validity));

ALTER TABLE jobcatalog.job_family_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_groups FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_groups;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_groups
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_group_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_group_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_group_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_group_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_group_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_group_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_group_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_group_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00002_jobcatalog_job_family_groups.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00003_jobcatalog_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'tenant_id is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_id THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.normalize_setid(p_setid text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v text;
BEGIN
  IF p_setid IS NULL OR btrim(p_setid) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'setid is required';
  END IF;
  v := upper(btrim(p_setid));
  IF v !~ '^[A-Z0-9]{1,5}$' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('setid=%s', v);
  END IF;
  RETURN v;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_group_versions(
  p_tenant_id uuid,
  p_setid text,
  p_job_family_group_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid text;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  v_setid := jobcatalog.normalize_setid(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_family_group_versions
  WHERE tenant_id = p_tenant_id AND setid = v_setid AND job_family_group_id = p_job_family_group_id;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_family_group_events
    WHERE tenant_id = p_tenant_id
      AND setid = v_setid
      AND job_family_group_id = p_job_family_group_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb)
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_family_group_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.setid = v_setid
      AND e.job_family_group_id = p_job_family_group_id
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_family_group_versions (
      tenant_id,
      setid,
      job_family_group_id,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_id,
      v_setid,
      p_job_family_group_id,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_family_group_versions
      WHERE tenant_id = p_tenant_id
        AND setid = v_setid
        AND job_family_group_id = p_job_family_group_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_family_group_id=%s', p_job_family_group_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_family_group_versions
      WHERE tenant_id = p_tenant_id
        AND setid = v_setid
        AND job_family_group_id = p_job_family_group_id
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_family_group_id=%s', p_job_family_group_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_family_group_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_setid text,
  p_job_family_group_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid text;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_family_group_events%ROWTYPE;
  v_existing_group jobcatalog.job_family_groups%ROWTYPE;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_job_family_group_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_family_group_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := jobcatalog.normalize_setid(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('code', 'name', 'description', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_family_groups (tenant_id, setid, id, code)
    VALUES (p_tenant_id, v_setid, p_job_family_group_id, v_code)
    ON CONFLICT (id) DO NOTHING;

    SELECT * INTO v_existing_group
    FROM jobcatalog.job_family_groups
    WHERE id = p_job_family_group_id;

    IF v_existing_group.tenant_id <> p_tenant_id
      OR v_existing_group.setid <> v_setid
      OR v_existing_group.code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_family_group_id=%s', p_job_family_group_id);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_family_groups
      WHERE tenant_id = p_tenant_id AND setid = v_setid AND id = p_job_family_group_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_family_group_id=%s', p_job_family_group_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_family_group_events (
    event_id, tenant_id, setid, job_family_group_id, event_type, effective_date, payload, request_id, initiator_id
  )
  VALUES (
    p_event_id, p_tenant_id, v_setid, p_job_family_group_id, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_family_group_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.setid <> v_setid
      OR v_existing.job_family_group_id <> p_job_family_group_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_family_group_versions(p_tenant_id, v_setid, p_job_family_group_id);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00003_jobcatalog_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00004_jobcatalog_job_families.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_families (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_families_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_families_tenant_setid_code_key UNIQUE (tenant_id, setid, code),
  CONSTRAINT job_families_tenant_setid_id_unique UNIQUE (tenant_id, setid, id)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_family_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_family_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_family_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT job_family_events_one_per_day_unique UNIQUE (tenant_id, setid, job_family_id, effective_date),
  CONSTRAINT job_family_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT job_family_events_family_fk
    FOREIGN KEY (tenant_id, setid, job_family_id) REFERENCES jobcatalog.job_families(tenant_id, setid, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_family_events_tenant_effective_idx
  ON jobcatalog.job_family_events (tenant_id, setid, job_family_id, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_family_id uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  job_family_group_id uuid NOT NULL,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_family_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_family_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_family_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_family_versions_family_fk
    FOREIGN KEY (tenant_id, setid, job_family_id) REFERENCES jobcatalog.job_families(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_family_versions_group_fk
    FOREIGN KEY (tenant_id, setid, job_family_group_id) REFERENCES jobcatalog.job_family_groups(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_family_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_family_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_family_versions_active_day_gist
  ON jobcatalog.job_family_versions
  USING gist (tenant_id gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_family_versions_lookup_btree
  ON jobcatalog.job_family_versions (tenant_id, setid, job_family_id, lower(validity));

ALTER TABLE jobcatalog.job_families ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_families FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_families;
CREATE POLICY tenant_isolation ON jobcatalog.job_families
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);


-- end: modules/jobcatalog/infrastructure/persistence/schema/00004_jobcatalog_job_families.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00005_jobcatalog_job_family_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_versions(
  p_tenant_id uuid,
  p_setid text,
  p_job_family_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid text;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
  v_group_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  v_setid := jobcatalog.normalize_setid(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_family_versions
  WHERE tenant_id = p_tenant_id AND setid = v_setid AND job_family_id = p_job_family_id;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_family_events
    WHERE tenant_id = p_tenant_id
      AND setid = v_setid
      AND job_family_id = p_job_family_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_group_id := NULLIF(btrim(COALESCE(v_row.payload->>'job_family_group_id', '')), '')::uuid;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb),
        'job_family_group_id', v_group_id::text
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
      IF v_row.payload ? 'job_family_group_id' THEN
        v_state := jsonb_set(v_state, '{job_family_group_id}', to_jsonb(v_row.payload->>'job_family_group_id'), true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_family_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.setid = v_setid
      AND e.job_family_id = p_job_family_id
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_family_versions (
      tenant_id,
      setid,
      job_family_id,
      validity,
      name,
      description,
      is_active,
      external_refs,
      job_family_group_id,
      last_event_id
    ) VALUES (
      p_tenant_id,
      v_setid,
      p_job_family_id,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      NULLIF(btrim(COALESCE(v_state->>'job_family_group_id', '')), '')::uuid,
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_family_versions
      WHERE tenant_id = p_tenant_id
        AND setid = v_setid
        AND job_family_id = p_job_family_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_family_id=%s', p_job_family_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_family_versions
      WHERE tenant_id = p_tenant_id
        AND setid = v_setid
        AND job_family_id = p_job_family_id
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_family_id=%s', p_job_family_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_family_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_setid text,
  p_job_family_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid text;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_family_events%ROWTYPE;
  v_existing_family jobcatalog.job_families%ROWTYPE;
  v_group_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_job_family_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_family_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := jobcatalog.normalize_setid(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('code', 'name', 'description', 'external_refs', 'job_family_group_id')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs', 'job_family_group_id')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF v_payload ? 'job_family_group_id' AND NULLIF(btrim(COALESCE(v_payload->>'job_family_group_id', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_group_id must be non-empty';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs' OR v_payload ? 'job_family_group_id') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'code/name is required';
    END IF;

    BEGIN
      v_group_id := NULLIF(btrim(COALESCE(v_payload->>'job_family_group_id', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_group_id must be uuid';
    END;

    IF v_group_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_group_id is required';
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_family_groups
      WHERE tenant_id = p_tenant_id AND setid = v_setid AND id = v_group_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_group_id=%s', v_group_id);
    END IF;

    INSERT INTO jobcatalog.job_families (tenant_id, setid, id, code)
    VALUES (p_tenant_id, v_setid, p_job_family_id, v_code)
    ON CONFLICT (id) DO NOTHING;

    SELECT * INTO v_existing_family
    FROM jobcatalog.job_families
    WHERE id = p_job_family_id;

    IF v_existing_family.tenant_id <> p_tenant_id
      OR v_existing_family.setid <> v_setid
      OR v_existing_family.code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_family_id=%s', p_job_family_id);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_families
      WHERE tenant_id = p_tenant_id AND setid = v_setid AND id = p_job_family_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_family_id=%s', p_job_family_id);
    END IF;
  END IF;

  IF (p_event_type = 'CREATE' OR p_event_type = 'UPDATE') AND v_payload ? 'job_family_group_id' THEN
    BEGIN
      v_group_id := NULLIF(btrim(COALESCE(v_payload->>'job_family_group_id', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_group_id must be uuid';
    END;

    IF v_group_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_group_id must be non-empty';
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_family_groups
      WHERE tenant_id = p_tenant_id AND setid = v_setid AND id = v_group_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_group_id=%s', v_group_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_family_events (
    event_id, tenant_id, setid, job_family_id, event_type, effective_date, payload, request_id, initiator_id
  )
  VALUES (
    p_event_id, p_tenant_id, v_setid, p_job_family_id, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_family_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.setid <> v_setid
      OR v_existing.job_family_id <> p_job_family_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_family_versions(p_tenant_id, v_setid, p_job_family_id);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00005_jobcatalog_job_family_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00006_jobcatalog_job_levels.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_levels (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_levels_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_levels_tenant_setid_code_key UNIQUE (tenant_id, setid, code),
  CONSTRAINT job_levels_tenant_setid_id_unique UNIQUE (tenant_id, setid, id)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_level_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_level_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_level_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_level_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_level_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT job_level_events_one_per_day_unique UNIQUE (tenant_id, setid, job_level_id, effective_date),
  CONSTRAINT job_level_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT job_level_events_level_fk
    FOREIGN KEY (tenant_id, setid, job_level_id) REFERENCES jobcatalog.job_levels(tenant_id, setid, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_level_events_tenant_effective_idx
  ON jobcatalog.job_level_events (tenant_id, setid, job_level_id, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_level_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_level_id uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_level_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_level_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_level_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_level_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_level_versions_level_fk
    FOREIGN KEY (tenant_id, setid, job_level_id) REFERENCES jobcatalog.job_levels(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_level_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_level_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_level_versions_active_day_gist
  ON jobcatalog.job_level_versions
  USING gist (tenant_id gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_level_versions_lookup_btree
  ON jobcatalog.job_level_versions (tenant_id, setid, job_level_id, lower(validity));

ALTER TABLE jobcatalog.job_levels ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_levels FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_levels;
CREATE POLICY tenant_isolation ON jobcatalog.job_levels
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_level_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_level_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_level_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_level_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_level_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_level_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_level_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_level_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);


-- end: modules/jobcatalog/infrastructure/persistence/schema/00006_jobcatalog_job_levels.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00007_jobcatalog_job_level_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_level_versions(
  p_tenant_id uuid,
  p_setid text,
  p_job_level_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid text;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  v_setid := jobcatalog.normalize_setid(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_level_versions
  WHERE tenant_id = p_tenant_id AND setid = v_setid AND job_level_id = p_job_level_id;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_level_events
    WHERE tenant_id = p_tenant_id
      AND setid = v_setid
      AND job_level_id = p_job_level_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb)
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_level_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.setid = v_setid
      AND e.job_level_id = p_job_level_id
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_level_versions (
      tenant_id,
      setid,
      job_level_id,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_id,
      v_setid,
      p_job_level_id,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_level_versions
      WHERE tenant_id = p_tenant_id
        AND setid = v_setid
        AND job_level_id = p_job_level_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_level_id=%s', p_job_level_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_level_versions
      WHERE tenant_id = p_tenant_id
        AND setid = v_setid
        AND job_level_id = p_job_level_id
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_level_id=%s', p_job_level_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_level_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_setid text,
  p_job_level_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid text;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_level_events%ROWTYPE;
  v_existing_level jobcatalog.job_levels%ROWTYPE;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_job_level_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_level_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := jobcatalog.normalize_setid(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('code', 'name', 'description', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_levels (tenant_id, setid, id, code)
    VALUES (p_tenant_id, v_setid, p_job_level_id, v_code)
    ON CONFLICT (id) DO NOTHING;

    SELECT * INTO v_existing_level
    FROM jobcatalog.job_levels
    WHERE id = p_job_level_id;

    IF v_existing_level.tenant_id <> p_tenant_id
      OR v_existing_level.setid <> v_setid
      OR v_existing_level.code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_level_id=%s', p_job_level_id);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_levels
      WHERE tenant_id = p_tenant_id AND setid = v_setid AND id = p_job_level_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_level_id=%s', p_job_level_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_level_events (
    event_id, tenant_id, setid, job_level_id, event_type, effective_date, payload, request_id, initiator_id
  )
  VALUES (
    p_event_id, p_tenant_id, v_setid, p_job_level_id, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_level_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.setid <> v_setid
      OR v_existing.job_level_id <> p_job_level_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_level_versions(p_tenant_id, v_setid, p_job_level_id);

  RETURN v_evt_db_id;
END;
$$;


-- end: modules/jobcatalog/infrastructure/persistence/schema/00007_jobcatalog_job_level_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00008_jobcatalog_job_profiles.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_profiles (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profiles_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_profiles_tenant_setid_code_key UNIQUE (tenant_id, setid, code),
  CONSTRAINT job_profiles_tenant_setid_id_unique UNIQUE (tenant_id, setid, id)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_profile_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_profile_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_profile_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT job_profile_events_one_per_day_unique UNIQUE (tenant_id, setid, job_profile_id, effective_date),
  CONSTRAINT job_profile_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT job_profile_events_profile_fk
    FOREIGN KEY (tenant_id, setid, job_profile_id) REFERENCES jobcatalog.job_profiles(tenant_id, setid, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_profile_events_tenant_effective_idx
  ON jobcatalog.job_profile_events (tenant_id, setid, job_profile_id, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_profile_id uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_profile_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_profile_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_profile_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_profile_versions_profile_fk
    FOREIGN KEY (tenant_id, setid, job_profile_id) REFERENCES jobcatalog.job_profiles(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_profile_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_profile_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_profile_versions_active_day_gist
  ON jobcatalog.job_profile_versions
  USING gist (tenant_id gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_profile_versions_lookup_btree
  ON jobcatalog.job_profile_versions (tenant_id, setid, job_profile_id, lower(validity));

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_version_job_families (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_profile_version_id bigint NOT NULL,
  job_family_id uuid NOT NULL,
  is_primary boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_version_job_families_setid_format_check CHECK (setid ~ '^[A-Z0-9]{1,5}$'),
  CONSTRAINT job_profile_version_job_families_version_fk
    FOREIGN KEY (job_profile_version_id) REFERENCES jobcatalog.job_profile_versions(id) ON DELETE CASCADE,
  CONSTRAINT job_profile_version_job_families_family_fk
    FOREIGN KEY (tenant_id, setid, job_family_id) REFERENCES jobcatalog.job_families(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_profile_version_job_families_unique UNIQUE (tenant_id, setid, job_profile_version_id, job_family_id)
);

CREATE UNIQUE INDEX IF NOT EXISTS job_profile_version_job_families_one_primary_unique
  ON jobcatalog.job_profile_version_job_families (tenant_id, setid, job_profile_version_id)
  WHERE is_primary = true;

CREATE INDEX IF NOT EXISTS job_profile_version_job_families_family_lookup_btree
  ON jobcatalog.job_profile_version_job_families (tenant_id, setid, job_family_id);

ALTER TABLE jobcatalog.job_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profiles FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profiles;
CREATE POLICY tenant_isolation ON jobcatalog.job_profiles
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_version_job_families ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_version_job_families FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_version_job_families;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_version_job_families
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);


-- end: modules/jobcatalog/infrastructure/persistence/schema/00008_jobcatalog_job_profiles.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00009_jobcatalog_job_profile_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_profile_versions(
  p_tenant_id uuid,
  p_setid text,
  p_job_profile_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid text;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
  v_version_id bigint;
  v_family_ids uuid[];
  v_primary_family_id uuid;
  v_family_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  v_setid := jobcatalog.normalize_setid(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_profile_versions
  WHERE tenant_id = p_tenant_id AND setid = v_setid AND job_profile_id = p_job_profile_id;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_profile_events
    WHERE tenant_id = p_tenant_id
      AND setid = v_setid
      AND job_profile_id = p_job_profile_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb),
        'job_family_ids', COALESCE(v_row.payload->'job_family_ids', '[]'::jsonb),
        'primary_job_family_id', v_row.payload->>'primary_job_family_id'
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
      IF v_row.payload ? 'job_family_ids' THEN
        v_state := jsonb_set(v_state, '{job_family_ids}', v_row.payload->'job_family_ids', true);
      END IF;
      IF v_row.payload ? 'primary_job_family_id' THEN
        v_state := jsonb_set(v_state, '{primary_job_family_id}', to_jsonb(v_row.payload->>'primary_job_family_id'), true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    IF jsonb_typeof(v_state->'job_family_ids') <> 'array' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_ids must be an array';
    END IF;
    IF jsonb_array_length(COALESCE(v_state->'job_family_ids', '[]'::jsonb)) = 0 THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_ids must be non-empty';
    END IF;

    BEGIN
      SELECT array_agg(NULLIF(btrim(value), '')::uuid) INTO v_family_ids
      FROM jsonb_array_elements_text(v_state->'job_family_ids') AS t(value);
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_ids contains invalid uuid';
    END;
    IF v_family_ids IS NULL OR array_length(v_family_ids, 1) IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_ids must be non-empty';
    END IF;
    IF (SELECT count(*) <> count(DISTINCT id) FROM unnest(v_family_ids) AS t(id)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_ids contains duplicates';
    END IF;

    BEGIN
      v_primary_family_id := NULLIF(btrim(COALESCE(v_state->>'primary_job_family_id', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'primary_job_family_id is invalid';
    END;
    IF v_primary_family_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'primary_job_family_id is required';
    END IF;
    IF NOT (v_primary_family_id = ANY(v_family_ids)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'primary_job_family_id must be included in job_family_ids';
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_profile_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.setid = v_setid
      AND e.job_profile_id = p_job_profile_id
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_profile_versions (
      tenant_id,
      setid,
      job_profile_id,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_id,
      v_setid,
      p_job_profile_id,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    )
    RETURNING id INTO v_version_id;

    FOREACH v_family_id IN ARRAY v_family_ids LOOP
      INSERT INTO jobcatalog.job_profile_version_job_families (
        tenant_id,
        setid,
        job_profile_version_id,
        job_family_id,
        is_primary
      ) VALUES (
        p_tenant_id,
        v_setid,
        v_version_id,
        v_family_id,
        v_family_id = v_primary_family_id
      );
    END LOOP;

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_profile_versions
      WHERE tenant_id = p_tenant_id
        AND setid = v_setid
        AND job_profile_id = p_job_profile_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_profile_id=%s', p_job_profile_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_profile_versions
      WHERE tenant_id = p_tenant_id
        AND setid = v_setid
        AND job_profile_id = p_job_profile_id
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_profile_id=%s', p_job_profile_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_profile_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_setid text,
  p_job_profile_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid text;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_profile_events%ROWTYPE;
  v_existing_profile jobcatalog.job_profiles%ROWTYPE;
  v_family_ids uuid[];
  v_primary_family_id uuid;
  v_missing_family_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_job_profile_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_profile_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := jobcatalog.normalize_setid(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('code', 'name', 'description', 'external_refs', 'job_family_ids', 'primary_job_family_id')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF jsonb_typeof(v_payload->'job_family_ids') <> 'array' OR jsonb_array_length(v_payload->'job_family_ids') = 0 THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_ids must be a non-empty array';
    END IF;
    IF NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_id', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_id is required';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs', 'job_family_ids', 'primary_job_family_id')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF v_payload ? 'job_family_ids' THEN
      IF jsonb_typeof(v_payload->'job_family_ids') <> 'array' OR jsonb_array_length(v_payload->'job_family_ids') = 0 THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.job_family_ids must be a non-empty array';
      END IF;
      IF NOT (v_payload ? 'primary_job_family_id') THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.primary_job_family_id is required when job_family_ids is present';
      END IF;
    END IF;
    IF v_payload ? 'primary_job_family_id' AND NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_id', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_id must be non-empty';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs' OR v_payload ? 'job_family_ids' OR v_payload ? 'primary_job_family_id') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF v_payload ? 'job_family_ids' THEN
    BEGIN
      SELECT array_agg(NULLIF(btrim(value), '')::uuid) INTO v_family_ids
      FROM jsonb_array_elements_text(v_payload->'job_family_ids') AS t(value);
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.job_family_ids contains invalid uuid';
    END;
    IF v_family_ids IS NULL OR array_length(v_family_ids, 1) IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_ids must be non-empty';
    END IF;
    IF (SELECT count(*) <> count(DISTINCT id) FROM unnest(v_family_ids) AS t(id)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_ids contains duplicates';
    END IF;
  END IF;

  IF v_payload ? 'primary_job_family_id' THEN
    BEGIN
      v_primary_family_id := NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_id', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.primary_job_family_id is invalid';
    END;
    IF v_primary_family_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_id must be non-empty';
    END IF;
  END IF;

  IF v_family_ids IS NOT NULL AND v_primary_family_id IS NOT NULL THEN
    IF NOT (v_primary_family_id = ANY(v_family_ids)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_id must be included in payload.job_family_ids';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_profiles (tenant_id, setid, id, code)
    VALUES (p_tenant_id, v_setid, p_job_profile_id, v_code)
    ON CONFLICT (id) DO NOTHING;

    SELECT * INTO v_existing_profile
    FROM jobcatalog.job_profiles
    WHERE id = p_job_profile_id;

    IF v_existing_profile.tenant_id <> p_tenant_id
      OR v_existing_profile.setid <> v_setid
      OR v_existing_profile.code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_profile_id=%s', p_job_profile_id);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_profiles
      WHERE tenant_id = p_tenant_id AND setid = v_setid AND id = p_job_profile_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_profile_id=%s', p_job_profile_id);
    END IF;
  END IF;

  IF v_family_ids IS NOT NULL THEN
    SELECT missing.job_family_id INTO v_missing_family_id
    FROM (
      SELECT t.id AS job_family_id
      FROM unnest(v_family_ids) AS t(id)
      LEFT JOIN jobcatalog.job_families f
        ON f.tenant_id = p_tenant_id
       AND f.setid = v_setid
       AND f.id = t.id
      WHERE f.id IS NULL
      LIMIT 1
    ) missing;
    IF v_missing_family_id IS NOT NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_id=%s', v_missing_family_id);
    END IF;
  END IF;

  IF v_primary_family_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_families
      WHERE tenant_id = p_tenant_id AND setid = v_setid AND id = v_primary_family_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_id=%s', v_primary_family_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_profile_events (
    event_id, tenant_id, setid, job_profile_id, event_type, effective_date, payload, request_id, initiator_id
  )
  VALUES (
    p_event_id, p_tenant_id, v_setid, p_job_profile_id, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_profile_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.setid <> v_setid
      OR v_existing.job_profile_id <> p_job_profile_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_profile_versions(p_tenant_id, v_setid, p_job_profile_id);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00009_jobcatalog_job_profile_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00010_jobcatalog_read.sql
CREATE OR REPLACE FUNCTION jobcatalog.get_job_catalog_snapshot(
  p_tenant_id uuid,
  p_setid text,
  p_query_date date
)
RETURNS TABLE (
  groups jsonb,
  families jsonb,
  levels jsonb,
  profiles jsonb
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  v_setid := jobcatalog.normalize_setid(p_setid);

  RETURN QUERY
  SELECT
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_family_group_id', g.id,
          'code', g.code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY g.code
      )
      FROM jobcatalog.job_family_groups g
      JOIN jobcatalog.job_family_group_versions v
        ON v.tenant_id = p_tenant_id
       AND v.setid = v_setid
       AND v.job_family_group_id = g.id
       AND v.validity @> p_query_date
      WHERE g.tenant_id = p_tenant_id
        AND g.setid = v_setid
    ), '[]'::jsonb) AS groups,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_family_id', f.id,
          'code', f.code,
          'job_family_group_id', v.job_family_group_id,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY f.code
      )
      FROM jobcatalog.job_families f
      JOIN jobcatalog.job_family_versions v
        ON v.tenant_id = p_tenant_id
       AND v.setid = v_setid
       AND v.job_family_id = f.id
       AND v.validity @> p_query_date
      WHERE f.tenant_id = p_tenant_id
        AND f.setid = v_setid
    ), '[]'::jsonb) AS families,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_level_id', l.id,
          'code', l.code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY l.code
      )
      FROM jobcatalog.job_levels l
      JOIN jobcatalog.job_level_versions v
        ON v.tenant_id = p_tenant_id
       AND v.setid = v_setid
       AND v.job_level_id = l.id
       AND v.validity @> p_query_date
      WHERE l.tenant_id = p_tenant_id
        AND l.setid = v_setid
    ), '[]'::jsonb) AS levels,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_profile_id', p.id,
          'code', p.code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id,
          'job_family_ids', COALESCE(fam.job_family_ids, '[]'::jsonb),
          'primary_job_family_id', fam.primary_job_family_id
        )
        ORDER BY p.code
      )
      FROM jobcatalog.job_profiles p
      JOIN jobcatalog.job_profile_versions v
        ON v.tenant_id = p_tenant_id
       AND v.setid = v_setid
       AND v.job_profile_id = p.id
       AND v.validity @> p_query_date
      LEFT JOIN LATERAL (
        SELECT
          jsonb_agg(f.job_family_id ORDER BY f.job_family_id) AS job_family_ids,
          (
            SELECT f2.job_family_id
            FROM jobcatalog.job_profile_version_job_families f2
            WHERE f2.tenant_id = p_tenant_id
              AND f2.setid = v_setid
              AND f2.job_profile_version_id = v.id
              AND f2.is_primary = true
            LIMIT 1
          ) AS primary_job_family_id
        FROM jobcatalog.job_profile_version_job_families f
        WHERE f.tenant_id = p_tenant_id
          AND f.setid = v_setid
          AND f.job_profile_version_id = v.id
      ) fam ON true
      WHERE p.tenant_id = p_tenant_id
        AND p.setid = v_setid
    ), '[]'::jsonb) AS profiles;
END;
$$;


-- end: modules/jobcatalog/infrastructure/persistence/schema/00010_jobcatalog_read.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00001_staffing_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE SCHEMA IF NOT EXISTS staffing;


-- end: modules/staffing/infrastructure/persistence/schema/00001_staffing_schema.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00002_staffing_tables.sql
CREATE TABLE IF NOT EXISTS staffing.positions (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id)
);

CREATE TABLE IF NOT EXISTS staffing.position_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  position_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT position_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE')),
  CONSTRAINT position_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT position_events_payload_allowed_keys_check CHECK (
    (
      payload
      - 'org_unit_id'
      - 'name'
      - 'reports_to_position_id'
      - 'business_unit_id'
      - 'job_profile_id'
      - 'lifecycle_status'
      - 'capacity_fte'
    ) = '{}'::jsonb
  ),
  CONSTRAINT position_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT position_events_one_per_day_unique UNIQUE (tenant_id, position_id, effective_date),
  CONSTRAINT position_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT position_events_position_fk FOREIGN KEY (tenant_id, position_id) REFERENCES staffing.positions(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS position_events_tenant_position_effective_idx
  ON staffing.position_events (tenant_id, position_id, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.position_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  position_id uuid NOT NULL,
  org_unit_id uuid NOT NULL,
  reports_to_position_id uuid NULL,
  name text NULL,
  lifecycle_status text NOT NULL DEFAULT 'active',
  capacity_fte numeric(9,2) NOT NULL DEFAULT 1.0,
  profile jsonb NOT NULL DEFAULT '{}'::jsonb,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.position_events(id),
  CONSTRAINT position_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT position_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT position_versions_capacity_fte_check CHECK (capacity_fte > 0),
  CONSTRAINT position_versions_profile_is_object_check CHECK (jsonb_typeof(profile) = 'object'),
  CONSTRAINT position_versions_lifecycle_status_check CHECK (lifecycle_status IN ('active','disabled')),
  CONSTRAINT position_versions_position_fk FOREIGN KEY (tenant_id, position_id) REFERENCES staffing.positions(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT position_versions_reports_to_fk FOREIGN KEY (tenant_id, reports_to_position_id) REFERENCES staffing.positions(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT position_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      position_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS position_versions_lookup_btree
  ON staffing.position_versions (tenant_id, position_id, lower(validity));

ALTER TABLE staffing.position_versions
  ADD COLUMN IF NOT EXISTS business_unit_id text NULL,
  ADD COLUMN IF NOT EXISTS jobcatalog_setid text NULL,
  ADD COLUMN IF NOT EXISTS job_profile_id uuid NULL;

ALTER TABLE staffing.position_versions
  DROP CONSTRAINT IF EXISTS position_versions_business_unit_id_format_check,
  DROP CONSTRAINT IF EXISTS position_versions_jobcatalog_setid_format_check,
  DROP CONSTRAINT IF EXISTS position_versions_jobcatalog_setid_requires_bu_check,
  DROP CONSTRAINT IF EXISTS position_versions_job_profile_requires_setid_check,
  DROP CONSTRAINT IF EXISTS position_versions_job_profile_fk;

ALTER TABLE staffing.position_versions
  ADD CONSTRAINT position_versions_business_unit_id_format_check CHECK (business_unit_id IS NULL OR business_unit_id ~ '^[A-Z0-9]{1,5}$'),
  ADD CONSTRAINT position_versions_jobcatalog_setid_format_check CHECK (jobcatalog_setid IS NULL OR jobcatalog_setid ~ '^[A-Z0-9]{1,5}$'),
  ADD CONSTRAINT position_versions_jobcatalog_setid_requires_bu_check CHECK (jobcatalog_setid IS NULL OR business_unit_id IS NOT NULL),
  ADD CONSTRAINT position_versions_job_profile_requires_setid_check CHECK (job_profile_id IS NULL OR jobcatalog_setid IS NOT NULL);

CREATE TABLE IF NOT EXISTS staffing.assignments (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  person_uuid uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id),
  CONSTRAINT assignments_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignments_tenant_person_type_unique UNIQUE (tenant_id, person_uuid, assignment_type)
);

CREATE TABLE IF NOT EXISTS staffing.assignment_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  assignment_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT assignment_events_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignment_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE')),
  CONSTRAINT assignment_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT assignment_events_payload_allowed_keys_check CHECK (
    (
      payload
      - 'position_id'
      - 'status'
      - 'base_salary'
      - 'allocated_fte'
      - 'currency'
      - 'profile'
    ) = '{}'::jsonb
  ),
  CONSTRAINT assignment_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT assignment_events_one_per_day_unique UNIQUE (tenant_id, assignment_id, effective_date),
  CONSTRAINT assignment_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT assignment_events_assignment_fk FOREIGN KEY (tenant_id, assignment_id) REFERENCES staffing.assignments(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS assignment_events_tenant_assignment_effective_idx
  ON staffing.assignment_events (tenant_id, assignment_id, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.assignment_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  assignment_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  position_id uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  status text NOT NULL DEFAULT 'active',
  allocated_fte numeric(9,2) NOT NULL DEFAULT 1.0,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.assignment_events(id),
  CONSTRAINT assignment_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT assignment_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT assignment_versions_allocated_fte_check CHECK (allocated_fte > 0),
  CONSTRAINT assignment_versions_status_check CHECK (status IN ('active','inactive')),
  CONSTRAINT assignment_versions_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignment_versions_assignment_fk FOREIGN KEY (tenant_id, assignment_id) REFERENCES staffing.assignments(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT assignment_versions_position_fk FOREIGN KEY (tenant_id, position_id) REFERENCES staffing.positions(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT assignment_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      assignment_id gist_uuid_ops WITH =,
      validity WITH &&
    ),
  CONSTRAINT assignment_versions_position_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      position_id gist_uuid_ops WITH =,
      validity WITH &&
    )
    WHERE (status = 'active')
);

CREATE INDEX IF NOT EXISTS assignment_versions_person_lookup_btree
  ON staffing.assignment_versions (tenant_id, person_uuid, lower(validity));

ALTER TABLE staffing.assignment_versions
  ADD COLUMN IF NOT EXISTS base_salary numeric(15,2) NULL,
  ADD COLUMN IF NOT EXISTS currency char(3) NOT NULL DEFAULT 'CNY',
  ADD COLUMN IF NOT EXISTS profile jsonb NOT NULL DEFAULT '{}'::jsonb;

ALTER TABLE staffing.assignment_versions
  DROP CONSTRAINT IF EXISTS assignment_versions_currency_check,
  DROP CONSTRAINT IF EXISTS assignment_versions_base_salary_check,
  DROP CONSTRAINT IF EXISTS assignment_versions_profile_is_object_check;

ALTER TABLE staffing.assignment_versions
  ADD CONSTRAINT assignment_versions_currency_check CHECK (currency = btrim(currency) AND currency = upper(currency)),
  ADD CONSTRAINT assignment_versions_base_salary_check CHECK (base_salary IS NULL OR base_salary >= 0),
  ADD CONSTRAINT assignment_versions_profile_is_object_check CHECK (jsonb_typeof(profile) = 'object');

CREATE TABLE IF NOT EXISTS staffing.time_punch_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  punch_time timestamptz NOT NULL,
  punch_type text NOT NULL,
  source_provider text NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  source_raw_payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  device_info jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT time_punch_events_punch_type_check CHECK (punch_type IN ('IN','OUT','RAW')),
  CONSTRAINT time_punch_events_source_provider_check CHECK (source_provider IN ('MANUAL','IMPORT','DINGTALK','WECOM')),
  CONSTRAINT time_punch_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT time_punch_events_source_raw_is_object_check CHECK (jsonb_typeof(source_raw_payload) = 'object'),
  CONSTRAINT time_punch_events_device_info_is_object_check CHECK (jsonb_typeof(device_info) = 'object'),
  CONSTRAINT time_punch_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT time_punch_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE INDEX IF NOT EXISTS time_punch_events_lookup_idx
  ON staffing.time_punch_events (tenant_id, person_uuid, punch_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS staffing.time_punch_void_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  target_punch_event_db_id bigint NOT NULL,
  target_punch_event_id uuid NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT time_punch_void_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT time_punch_void_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT time_punch_void_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT time_punch_void_events_target_unique UNIQUE (tenant_id, target_punch_event_db_id)
);

CREATE INDEX IF NOT EXISTS time_punch_void_events_person_created_idx
  ON staffing.time_punch_void_events (tenant_id, person_uuid, created_at DESC, id DESC);

CREATE INDEX IF NOT EXISTS time_punch_void_events_target_idx
  ON staffing.time_punch_void_events (tenant_id, target_punch_event_db_id);

CREATE TABLE IF NOT EXISTS staffing.attendance_recalc_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  from_date date NOT NULL,
  to_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT attendance_recalc_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT attendance_recalc_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT attendance_recalc_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT attendance_recalc_events_date_range_check CHECK (to_date >= from_date),
  CONSTRAINT attendance_recalc_events_range_size_check CHECK ((to_date - from_date) <= 30)
);

CREATE INDEX IF NOT EXISTS attendance_recalc_events_person_range_idx
  ON staffing.attendance_recalc_events (tenant_id, person_uuid, from_date, to_date, id);

CREATE INDEX IF NOT EXISTS attendance_recalc_events_created_idx
  ON staffing.attendance_recalc_events (tenant_id, created_at DESC, id DESC);

CREATE TABLE IF NOT EXISTS staffing.daily_attendance_results (
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  work_date date NOT NULL,

  ruleset_version text NOT NULL,
  day_type text NULL,
  status text NOT NULL,
  flags text[] NOT NULL DEFAULT '{}'::text[],

  first_in_time timestamptz NULL,
  last_out_time timestamptz NULL,
  scheduled_minutes int NOT NULL DEFAULT 0,
  worked_minutes int NOT NULL DEFAULT 0,
  overtime_minutes_150 int NOT NULL DEFAULT 0,
  overtime_minutes_200 int NOT NULL DEFAULT 0,
  overtime_minutes_300 int NOT NULL DEFAULT 0,
  late_minutes int NOT NULL DEFAULT 0,
  early_leave_minutes int NOT NULL DEFAULT 0,

  input_punch_count int NOT NULL DEFAULT 0,
  input_max_punch_event_db_id bigint NULL,
  input_max_punch_time timestamptz NULL,

  time_profile_last_event_id bigint NULL,
  holiday_day_last_event_id bigint NULL,

  computed_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),

  PRIMARY KEY (tenant_id, person_uuid, work_date),

  CONSTRAINT daily_attendance_results_status_check
    CHECK (status IN ('PRESENT','ABSENT','EXCEPTION','OFF')),
  CONSTRAINT daily_attendance_results_day_type_check
    CHECK (day_type IS NULL OR day_type IN ('WORKDAY','RESTDAY','LEGAL_HOLIDAY')),
  CONSTRAINT daily_attendance_results_minutes_nonneg_check
    CHECK (scheduled_minutes >= 0 AND worked_minutes >= 0 AND late_minutes >= 0 AND early_leave_minutes >= 0),
  CONSTRAINT daily_attendance_results_overtime_nonneg_check
    CHECK (overtime_minutes_150 >= 0 AND overtime_minutes_200 >= 0 AND overtime_minutes_300 >= 0),
  CONSTRAINT daily_attendance_results_flags_allowlist_check
    CHECK (flags <@ ARRAY['ABSENT','MISSING_IN','MISSING_OUT','LATE','EARLY_LEAVE']::text[])
);

CREATE INDEX IF NOT EXISTS daily_attendance_results_lookup_idx
  ON staffing.daily_attendance_results (tenant_id, person_uuid, work_date DESC);

CREATE TABLE IF NOT EXISTS staffing.time_bank_cycles (
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  cycle_type text NOT NULL,
  cycle_start_date date NOT NULL,
  cycle_end_date date NOT NULL,

  ruleset_version text NOT NULL,

  worked_minutes_total int NOT NULL DEFAULT 0,
  overtime_minutes_150 int NOT NULL DEFAULT 0,
  overtime_minutes_200 int NOT NULL DEFAULT 0,
  overtime_minutes_300 int NOT NULL DEFAULT 0,

  comp_earned_minutes int NOT NULL DEFAULT 0,
  comp_used_minutes int NOT NULL DEFAULT 0,

  input_max_punch_event_db_id bigint NULL,
  input_max_punch_time timestamptz NULL,

  computed_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),

  PRIMARY KEY (tenant_id, person_uuid, cycle_type, cycle_start_date),

  CONSTRAINT time_bank_cycles_cycle_type_check
    CHECK (cycle_type IN ('MONTH')),
  CONSTRAINT time_bank_cycles_cycle_bounds_check
    CHECK (cycle_end_date >= cycle_start_date),
  CONSTRAINT time_bank_cycles_minutes_nonneg_check
    CHECK (
      worked_minutes_total >= 0
      AND overtime_minutes_150 >= 0
      AND overtime_minutes_200 >= 0
      AND overtime_minutes_300 >= 0
      AND comp_earned_minutes >= 0
      AND comp_used_minutes >= 0
    )
);

CREATE INDEX IF NOT EXISTS time_bank_cycles_lookup_idx
  ON staffing.time_bank_cycles (tenant_id, person_uuid, cycle_start_date DESC);

CREATE TABLE IF NOT EXISTS staffing.time_profile_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT time_profile_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE')),
  CONSTRAINT time_profile_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT time_profile_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT time_profile_events_one_per_day_unique UNIQUE (tenant_id, effective_date),
  CONSTRAINT time_profile_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE INDEX IF NOT EXISTS time_profile_events_lookup_idx
  ON staffing.time_profile_events (tenant_id, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.time_profile_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  name text NULL,
  lifecycle_status text NOT NULL DEFAULT 'active',

  shift_start_local time NOT NULL,
  shift_end_local time NOT NULL,
  late_tolerance_minutes int NOT NULL DEFAULT 0,
  early_leave_tolerance_minutes int NOT NULL DEFAULT 0,

  overtime_min_minutes int NOT NULL DEFAULT 0,
  overtime_rounding_mode text NOT NULL DEFAULT 'NONE',
  overtime_rounding_unit_minutes int NOT NULL DEFAULT 0,

  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.time_profile_events(id),

  CONSTRAINT time_profile_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT time_profile_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT time_profile_versions_lifecycle_status_check CHECK (lifecycle_status IN ('active','disabled')),
  CONSTRAINT time_profile_versions_shift_time_order_check CHECK (shift_end_local > shift_start_local),
  CONSTRAINT time_profile_versions_tolerance_minutes_check CHECK (late_tolerance_minutes >= 0 AND early_leave_tolerance_minutes >= 0),
  CONSTRAINT time_profile_versions_overtime_min_check CHECK (overtime_min_minutes >= 0),
  CONSTRAINT time_profile_versions_overtime_rounding_mode_check CHECK (overtime_rounding_mode IN ('NONE','FLOOR','CEIL','NEAREST')),
  CONSTRAINT time_profile_versions_overtime_rounding_unit_check CHECK (overtime_rounding_unit_minutes >= 0),
  CONSTRAINT time_profile_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS time_profile_versions_lookup_idx
  ON staffing.time_profile_versions (tenant_id, lower(validity));

CREATE TABLE IF NOT EXISTS staffing.holiday_day_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  day_date date NOT NULL,
  event_type text NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT holiday_day_events_event_type_check CHECK (event_type IN ('SET','CLEAR')),
  CONSTRAINT holiday_day_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT holiday_day_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT holiday_day_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE INDEX IF NOT EXISTS holiday_day_events_lookup_idx
  ON staffing.holiday_day_events (tenant_id, day_date, id);

CREATE TABLE IF NOT EXISTS staffing.holiday_days (
  tenant_id uuid NOT NULL,
  day_date date NOT NULL,
  day_type text NOT NULL,
  holiday_code text NULL,
  note text NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.holiday_day_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, day_date),
  CONSTRAINT holiday_days_day_type_check CHECK (day_type IN ('WORKDAY','RESTDAY','LEGAL_HOLIDAY'))
);

CREATE INDEX IF NOT EXISTS holiday_days_lookup_idx
  ON staffing.holiday_days (tenant_id, day_date DESC);

ALTER TABLE staffing.positions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.positions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.positions;
CREATE POLICY tenant_isolation ON staffing.positions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.position_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.position_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.position_events;
CREATE POLICY tenant_isolation ON staffing.position_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.position_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.position_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.position_versions;
CREATE POLICY tenant_isolation ON staffing.position_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignments FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignments;
CREATE POLICY tenant_isolation ON staffing.assignments
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_events;
CREATE POLICY tenant_isolation ON staffing.assignment_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_versions;
CREATE POLICY tenant_isolation ON staffing.assignment_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.time_punch_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.time_punch_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.time_punch_events;
CREATE POLICY tenant_isolation ON staffing.time_punch_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.time_punch_void_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.time_punch_void_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.time_punch_void_events;
CREATE POLICY tenant_isolation ON staffing.time_punch_void_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.attendance_recalc_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.attendance_recalc_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.attendance_recalc_events;
CREATE POLICY tenant_isolation ON staffing.attendance_recalc_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.daily_attendance_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.daily_attendance_results FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.daily_attendance_results;
CREATE POLICY tenant_isolation ON staffing.daily_attendance_results
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.time_bank_cycles ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.time_bank_cycles FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.time_bank_cycles;
CREATE POLICY tenant_isolation ON staffing.time_bank_cycles
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.time_profile_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.time_profile_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.time_profile_events;
CREATE POLICY tenant_isolation ON staffing.time_profile_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.time_profile_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.time_profile_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.time_profile_versions;
CREATE POLICY tenant_isolation ON staffing.time_profile_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.holiday_day_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.holiday_day_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.holiday_day_events;
CREATE POLICY tenant_isolation ON staffing.holiday_day_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.holiday_days ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.holiday_days FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.holiday_days;
CREATE POLICY tenant_isolation ON staffing.holiday_days
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/staffing/infrastructure/persistence/schema/00002_staffing_tables.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00003_staffing_engine.sql
CREATE OR REPLACE FUNCTION staffing.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'tenant_id is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_id THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_time_punch_void_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_target_punch_event_id uuid,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_target staffing.time_punch_events%ROWTYPE;
  v_existing_by_event staffing.time_punch_void_events%ROWTYPE;
  v_existing_by_target staffing.time_punch_void_events%ROWTYPE;
  v_payload jsonb;
  v_void_db_id bigint;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_target_punch_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'target_punch_event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;

  SELECT * INTO v_target
  FROM staffing.time_punch_events
  WHERE tenant_id = p_tenant_id
    AND event_id = p_target_punch_event_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_TIME_PUNCH_EVENT_NOT_FOUND',
      DETAIL = format('tenant_id=%s target_event_id=%s', p_tenant_id, p_target_punch_event_id);
  END IF;

  INSERT INTO staffing.time_punch_void_events (
    event_id,
    tenant_id,
    person_uuid,
    target_punch_event_db_id,
    target_punch_event_id,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    v_target.person_uuid,
    v_target.id,
    v_target.event_id,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT DO NOTHING
  RETURNING id INTO v_void_db_id;

  IF v_void_db_id IS NULL THEN
    SELECT * INTO v_existing_by_event
    FROM staffing.time_punch_void_events
    WHERE event_id = p_event_id;

    IF FOUND THEN
      IF v_existing_by_event.tenant_id <> p_tenant_id
        OR v_existing_by_event.person_uuid <> v_target.person_uuid
        OR v_existing_by_event.target_punch_event_db_id <> v_target.id
        OR v_existing_by_event.target_punch_event_id <> v_target.event_id
        OR v_existing_by_event.payload <> v_payload
        OR v_existing_by_event.request_id <> p_request_id
        OR v_existing_by_event.initiator_id <> p_initiator_id
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
          DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing_by_event.id);
      END IF;
      RETURN v_existing_by_event.id;
    END IF;

    SELECT * INTO v_existing_by_target
    FROM staffing.time_punch_void_events
    WHERE tenant_id = p_tenant_id
      AND target_punch_event_db_id = v_target.id
    LIMIT 1;

    IF FOUND THEN
      RETURN v_existing_by_target.id;
    END IF;

    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'void insert failed';
  END IF;

  PERFORM staffing.recompute_daily_attendance_results_for_punch(p_tenant_id, v_target.person_uuid, v_target.punch_time);

  RETURN v_void_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_attendance_recalc_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_person_uuid uuid,
  p_from_date date,
  p_to_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_existing staffing.attendance_recalc_events%ROWTYPE;
  v_payload jsonb;
  v_recalc_db_id bigint;
  v_d date;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_from_date IS NULL OR p_to_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'from_date/to_date is required';
  END IF;
  IF p_to_date < p_from_date THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'to_date must be >= from_date';
  END IF;
  IF (p_to_date - p_from_date) > 30 THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'date range too large (max 31 days)';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;

  INSERT INTO staffing.attendance_recalc_events (
    event_id,
    tenant_id,
    person_uuid,
    from_date,
    to_date,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_person_uuid,
    p_from_date,
    p_to_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_recalc_db_id;

  IF v_recalc_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.attendance_recalc_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.person_uuid <> p_person_uuid
      OR v_existing.from_date <> p_from_date
      OR v_existing.to_date <> p_to_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  v_d := p_from_date;
  WHILE v_d <= p_to_date LOOP
    PERFORM staffing.recompute_daily_attendance_result(p_tenant_id, p_person_uuid, v_d);
    v_d := v_d + 1;
  END LOOP;

  RETURN v_recalc_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.assert_position_capacity(
  p_tenant_id uuid,
  p_position_id uuid,
  p_validity daterange
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_as_of date;
  v_capacity_fte numeric(9,2);
  v_allocated_sum numeric(9,2);
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_position_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'position_id is required';
  END IF;
  IF p_validity IS NULL OR isempty(p_validity) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'validity is required';
  END IF;

  FOR v_as_of IN
    SELECT d::date AS as_of
    FROM (
      SELECT lower(p_validity) AS d
      UNION
      SELECT lower(av.validity) AS d
      FROM staffing.assignment_versions av
      WHERE av.tenant_id = p_tenant_id
        AND av.position_id = p_position_id
        AND av.status = 'active'
        AND av.validity && p_validity
      UNION
      SELECT lower(pv.validity) AS d
      FROM staffing.position_versions pv
      WHERE pv.tenant_id = p_tenant_id
        AND pv.position_id = p_position_id
        AND pv.validity && p_validity
    ) dates
    WHERE d IS NOT NULL
      AND d >= lower(p_validity)
      AND (upper_inf(p_validity) OR d < upper(p_validity))
    ORDER BY d
  LOOP
    SELECT pv.capacity_fte INTO v_capacity_fte
    FROM staffing.position_versions pv
    WHERE pv.tenant_id = p_tenant_id
      AND pv.position_id = p_position_id
      AND pv.validity @> v_as_of
    LIMIT 1;

    IF v_capacity_fte IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_POSITION_NOT_FOUND_AS_OF',
        DETAIL = format('position_id=%s as_of=%s', p_position_id, v_as_of);
    END IF;

    SELECT COALESCE(sum(av.allocated_fte), 0)::numeric(9,2) INTO v_allocated_sum
    FROM staffing.assignment_versions av
    WHERE av.tenant_id = p_tenant_id
      AND av.position_id = p_position_id
      AND av.status = 'active'
      AND av.validity @> v_as_of;

    IF v_allocated_sum > v_capacity_fte THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_POSITION_CAPACITY_EXCEEDED',
        DETAIL = format('position_id=%s as_of=%s allocated_sum=%s capacity_fte=%s', p_position_id, v_as_of, v_allocated_sum, v_capacity_fte);
    END IF;
  END LOOP;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.replay_position_versions(
  p_tenant_id uuid,
  p_position_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_prev_effective date;
  v_last_validity daterange;
  v_org_unit_id uuid;
  v_reports_to_position_id uuid;
  v_business_unit_id text;
  v_jobcatalog_setid text;
  v_job_profile_id uuid;
  v_capacity_fte numeric(9,2);
  v_name text;
  v_lifecycle_status text;
  v_reports_to_status text;
  v_tmp_text text;
  v_row RECORD;
  v_validity daterange;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_position_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'position_id is required';
  END IF;

  v_lock_key := format('staffing:position:%s:%s', p_tenant_id, p_position_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM staffing.position_versions
  WHERE tenant_id = p_tenant_id AND position_id = p_position_id;

  v_org_unit_id := NULL;
  v_reports_to_position_id := NULL;
  v_business_unit_id := NULL;
  v_jobcatalog_setid := NULL;
  v_job_profile_id := NULL;
  v_capacity_fte := 1.0;
  v_name := NULL;
  v_lifecycle_status := 'active';
  v_prev_effective := NULL;

  FOR v_row IN
    SELECT
      e.id AS event_db_id,
      e.event_type,
      e.effective_date,
      e.payload,
      lead(e.effective_date) OVER (ORDER BY e.effective_date ASC, e.id ASC) AS next_effective
    FROM staffing.position_events e
    WHERE e.tenant_id = p_tenant_id AND e.position_id = p_position_id
    ORDER BY e.effective_date ASC, e.id ASC
  LOOP
    IF v_row.event_type = 'CREATE' THEN
      IF v_prev_effective IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_org_unit_id := NULLIF(v_row.payload->>'org_unit_id', '')::uuid;
      IF v_org_unit_id IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_ARGUMENT',
          DETAIL = 'org_unit_id is required';
      END IF;

      v_name := NULLIF(btrim(v_row.payload->>'name'), '');
      v_reports_to_position_id := NULL;
      v_business_unit_id := NULLIF(btrim(v_row.payload->>'business_unit_id'), '');
      v_job_profile_id := NULL;
      IF v_row.payload ? 'job_profile_id' THEN
        v_job_profile_id := NULLIF(v_row.payload->>'job_profile_id', '')::uuid;
      END IF;
      v_capacity_fte := 1.0;
      IF v_row.payload ? 'capacity_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'capacity_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'capacity_fte is required';
        END IF;
        BEGIN
          v_capacity_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              ERRCODE = 'P0001',
              MESSAGE = 'STAFFING_INVALID_ARGUMENT',
              DETAIL = format('invalid capacity_fte: %s', v_row.payload->>'capacity_fte');
        END;
        IF v_capacity_fte <= 0 THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('invalid capacity_fte: %s', v_row.payload->>'capacity_fte');
        END IF;
      END IF;
      v_lifecycle_status := 'active';
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev_effective IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;

      IF v_row.payload ? 'org_unit_id' THEN
        v_org_unit_id := NULLIF(v_row.payload->>'org_unit_id', '')::uuid;
        IF v_org_unit_id IS NULL THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'org_unit_id is required';
        END IF;
      END IF;
      IF v_row.payload ? 'name' THEN
        v_name := NULLIF(btrim(v_row.payload->>'name'), '');
      END IF;
      IF v_row.payload ? 'reports_to_position_id' THEN
        v_reports_to_position_id := NULLIF(v_row.payload->>'reports_to_position_id', '')::uuid;
      END IF;
      IF v_row.payload ? 'business_unit_id' THEN
        v_business_unit_id := NULLIF(btrim(v_row.payload->>'business_unit_id'), '');
      END IF;
      IF v_row.payload ? 'job_profile_id' THEN
        v_job_profile_id := NULLIF(v_row.payload->>'job_profile_id', '')::uuid;
      END IF;
      IF v_row.payload ? 'capacity_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'capacity_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'capacity_fte is required';
        END IF;
        BEGIN
          v_capacity_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              ERRCODE = 'P0001',
              MESSAGE = 'STAFFING_INVALID_ARGUMENT',
              DETAIL = format('invalid capacity_fte: %s', v_row.payload->>'capacity_fte');
        END;
        IF v_capacity_fte <= 0 THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('invalid capacity_fte: %s', v_row.payload->>'capacity_fte');
        END IF;
      END IF;
      IF v_row.payload ? 'lifecycle_status' THEN
        v_lifecycle_status := NULLIF(btrim(v_row.payload->>'lifecycle_status'), '');
        IF v_lifecycle_status IS NULL OR v_lifecycle_status NOT IN ('active','disabled') THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('invalid lifecycle_status: %s', v_row.payload->>'lifecycle_status');
        END IF;
      END IF;
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_row.event_type);
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.org_unit_versions v
      WHERE v.tenant_id = p_tenant_id
        AND v.hierarchy_type = 'OrgUnit'
        AND v.org_id = v_org_unit_id
        AND v.status = 'active'
        AND v.validity @> v_row.effective_date
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_ORG_UNIT_NOT_FOUND_AS_OF',
        DETAIL = format('org_unit_id=%s as_of=%s', v_org_unit_id, v_row.effective_date);
    END IF;

    v_jobcatalog_setid := NULL;
    IF v_business_unit_id IS NOT NULL THEN
      v_jobcatalog_setid := orgunit.resolve_setid(p_tenant_id, v_business_unit_id, 'jobcatalog');
    END IF;
    IF v_job_profile_id IS NOT NULL THEN
      IF v_jobcatalog_setid IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_ARGUMENT',
          DETAIL = 'business_unit_id is required when binding job_profile_id';
      END IF;
      IF NOT EXISTS (
        SELECT 1
        FROM jobcatalog.job_profiles jp
        WHERE jp.tenant_id = p_tenant_id
          AND jp.setid = v_jobcatalog_setid
          AND jp.id = v_job_profile_id
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
          DETAIL = format('job_profile_id=%s setid=%s', v_job_profile_id, v_jobcatalog_setid);
      END IF;
    END IF;

    IF v_row.next_effective IS NULL THEN
      v_validity := daterange(v_row.effective_date, NULL, '[)');
    ELSE
      v_validity := daterange(v_row.effective_date, v_row.next_effective, '[)');
    END IF;

    IF v_reports_to_position_id IS NOT NULL THEN
      IF v_reports_to_position_id = p_position_id THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_REPORTS_TO_SELF',
          DETAIL = format('position_id=%s as_of=%s', p_position_id, v_row.effective_date);
      END IF;

      SELECT pv.lifecycle_status INTO v_reports_to_status
      FROM staffing.position_versions pv
      WHERE pv.tenant_id = p_tenant_id
        AND pv.position_id = v_reports_to_position_id
        AND pv.validity @> v_row.effective_date
      LIMIT 1;
      IF NOT FOUND THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_NOT_FOUND_AS_OF',
          DETAIL = format('position_id=%s as_of=%s', v_reports_to_position_id, v_row.effective_date);
      END IF;
      IF v_reports_to_status <> 'active' THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_DISABLED_AS_OF',
          DETAIL = format('position_id=%s as_of=%s', v_reports_to_position_id, v_row.effective_date);
      END IF;

      IF EXISTS (
        WITH RECURSIVE chain AS (
          SELECT
            pv.position_id,
            pv.reports_to_position_id,
            ARRAY[pv.position_id]::uuid[] AS path
          FROM staffing.position_versions pv
          WHERE pv.tenant_id = p_tenant_id
            AND pv.position_id = v_reports_to_position_id
            AND pv.validity @> v_row.effective_date
          UNION ALL
          SELECT
            pv.position_id,
            pv.reports_to_position_id,
            c.path || pv.position_id
          FROM chain c
          JOIN staffing.position_versions pv
            ON pv.tenant_id = p_tenant_id
           AND pv.position_id = c.reports_to_position_id
           AND pv.validity @> v_row.effective_date
          WHERE c.reports_to_position_id IS NOT NULL
            AND NOT (pv.position_id = ANY(c.path))
        )
        SELECT 1
        FROM chain
        WHERE reports_to_position_id = p_position_id
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_REPORTS_TO_CYCLE',
          DETAIL = format('position_id=%s reports_to_position_id=%s as_of=%s', p_position_id, v_reports_to_position_id, v_row.effective_date);
      END IF;
    END IF;

    IF v_lifecycle_status = 'disabled' AND EXISTS (
      SELECT 1
      FROM staffing.assignment_versions av
      WHERE av.tenant_id = p_tenant_id
        AND av.position_id = p_position_id
        AND av.status = 'active'
        AND av.validity && v_validity
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_POSITION_HAS_ACTIVE_ASSIGNMENT_AS_OF',
        DETAIL = format('position_id=%s as_of=%s', p_position_id, lower(v_validity));
    END IF;

    INSERT INTO staffing.position_versions (
      tenant_id,
      position_id,
      org_unit_id,
      reports_to_position_id,
      business_unit_id,
      jobcatalog_setid,
      job_profile_id,
      name,
      lifecycle_status,
      capacity_fte,
      profile,
      validity,
      last_event_id
    )
    VALUES (
      p_tenant_id,
      p_position_id,
      v_org_unit_id,
      v_reports_to_position_id,
      v_business_unit_id,
      v_jobcatalog_setid,
      v_job_profile_id,
      v_name,
      v_lifecycle_status,
      v_capacity_fte,
      '{}'::jsonb,
      v_validity,
      v_row.event_db_id
    );

    PERFORM staffing.assert_position_capacity(p_tenant_id, p_position_id, v_validity);

    v_prev_effective := v_row.effective_date;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM staffing.position_versions
      WHERE tenant_id = p_tenant_id AND position_id = p_position_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_GAP',
      DETAIL = 'position_versions must be gapless';
  END IF;

  SELECT validity INTO v_last_validity
  FROM staffing.position_versions
  WHERE tenant_id = p_tenant_id AND position_id = p_position_id
  ORDER BY lower(validity) DESC
  LIMIT 1;

  IF v_last_validity IS NOT NULL AND NOT upper_inf(v_last_validity) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_NOT_INFINITE',
      DETAIL = 'last position version validity must be unbounded (infinity)';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_position_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_position_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_reports_to_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.position_events%ROWTYPE;
  v_payload jsonb;
  v_prev_effective_max date;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_position_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'position_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);

  IF v_payload ? 'reports_to_position_id' THEN
    v_reports_to_lock_key := format('staffing:position-reports-to:%s', p_tenant_id);
    PERFORM pg_advisory_xact_lock(hashtextextended(v_reports_to_lock_key, 0));
  END IF;

  v_lock_key := format('staffing:position:%s:%s', p_tenant_id, p_position_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  INSERT INTO staffing.positions (tenant_id, id)
  VALUES (p_tenant_id, p_position_id)
  ON CONFLICT DO NOTHING;

  INSERT INTO staffing.position_events (
    event_id,
    tenant_id,
    position_id,
    event_type,
    effective_date,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_position_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.position_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.position_id <> p_position_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  IF p_event_type = 'UPDATE' AND v_payload ? 'reports_to_position_id' THEN
    SELECT max(effective_date) INTO v_prev_effective_max
    FROM staffing.position_events
    WHERE tenant_id = p_tenant_id
      AND position_id = p_position_id
      AND id <> v_event_db_id;

    IF v_prev_effective_max IS NOT NULL AND p_effective_date <= v_prev_effective_max THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('reports_to_position_id updates must be forward-only: effective_date=%s last_effective_date=%s', p_effective_date, v_prev_effective_max);
    END IF;
  END IF;

  PERFORM staffing.replay_position_versions(p_tenant_id, p_position_id);

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.replay_assignment_versions(
  p_tenant_id uuid,
  p_assignment_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_prev_effective date;
  v_last_validity daterange;
  v_person_uuid uuid;
  v_assignment_type text;
  v_position_id uuid;
  v_status text;
  v_allocated_fte numeric(9,2);
  v_base_salary numeric(15,2);
  v_currency text;
  v_profile jsonb;
  v_tmp_text text;
  v_row RECORD;
  v_validity daterange;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_assignment_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'assignment_id is required';
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_id, p_assignment_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM staffing.assignment_versions
  WHERE tenant_id = p_tenant_id AND assignment_id = p_assignment_id;

  v_person_uuid := NULL;
  v_assignment_type := NULL;
  v_position_id := NULL;
  v_status := 'active';
  v_allocated_fte := 1.0;
  v_base_salary := NULL;
  v_currency := 'CNY';
  v_profile := '{}'::jsonb;
  v_prev_effective := NULL;

  FOR v_row IN
    SELECT
      e.id AS event_db_id,
      e.event_type,
      e.effective_date,
      e.person_uuid,
      e.assignment_type,
      e.payload,
      lead(e.effective_date) OVER (ORDER BY e.effective_date ASC, e.id ASC) AS next_effective
    FROM staffing.assignment_events e
    WHERE e.tenant_id = p_tenant_id AND e.assignment_id = p_assignment_id
    ORDER BY e.effective_date ASC, e.id ASC
  LOOP
    IF v_row.event_type = 'CREATE' THEN
      IF v_prev_effective IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_person_uuid := v_row.person_uuid;
      v_assignment_type := v_row.assignment_type;

      v_position_id := NULLIF(v_row.payload->>'position_id', '')::uuid;
      IF v_position_id IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_ARGUMENT',
          DETAIL = 'position_id is required';
      END IF;
      v_status := 'active';

      IF v_row.payload ? 'base_salary' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'base_salary'), '');
        IF v_tmp_text IS NULL THEN
          v_base_salary := NULL;
        ELSE
          BEGIN
            v_base_salary := v_tmp_text::numeric;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING
                MESSAGE = 'STAFFING_ASSIGNMENT_BASE_SALARY_INVALID',
                DETAIL = format('base_salary=%s', v_row.payload->>'base_salary');
          END;
          IF v_base_salary < 0 THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_BASE_SALARY_INVALID',
              DETAIL = format('base_salary=%s', v_row.payload->>'base_salary');
          END IF;
        END IF;
      END IF;

      IF v_row.payload ? 'allocated_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'allocated_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = 'allocated_fte is required';
        END IF;
        BEGIN
          v_allocated_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
              DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END;
        IF v_allocated_fte <= 0 OR v_allocated_fte > 1 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END IF;
      END IF;

      IF v_row.payload ? 'currency' THEN
        v_tmp_text := upper(btrim(v_row.payload->>'currency'));
        IF v_tmp_text IS NULL OR v_tmp_text = '' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_CURRENCY_UNSUPPORTED',
            DETAIL = 'currency is required';
        END IF;
        IF v_tmp_text <> 'CNY' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_CURRENCY_UNSUPPORTED',
            DETAIL = format('currency=%s', v_row.payload->>'currency');
        END IF;
        v_currency := v_tmp_text;
      END IF;

      IF v_row.payload ? 'profile' THEN
        IF jsonb_typeof(v_row.payload->'profile') <> 'object' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_PROFILE_INVALID',
            DETAIL = 'profile must be an object';
        END IF;
        v_profile := v_row.payload->'profile';
      END IF;
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev_effective IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;

      IF v_row.payload ? 'position_id' THEN
        v_position_id := NULLIF(v_row.payload->>'position_id', '')::uuid;
        IF v_position_id IS NULL THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'position_id is required';
	      END IF;
      END IF;

      IF v_row.payload ? 'status' THEN
        v_status := NULLIF(btrim(v_row.payload->>'status'), '');
        IF v_status IS NULL OR v_status NOT IN ('active','inactive') THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('invalid status: %s', v_row.payload->>'status');
	        END IF;
      END IF;

      IF v_row.payload ? 'base_salary' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'base_salary'), '');
        IF v_tmp_text IS NULL THEN
          v_base_salary := NULL;
        ELSE
          BEGIN
            v_base_salary := v_tmp_text::numeric;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING
                MESSAGE = 'STAFFING_ASSIGNMENT_BASE_SALARY_INVALID',
                DETAIL = format('base_salary=%s', v_row.payload->>'base_salary');
          END;
          IF v_base_salary < 0 THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_BASE_SALARY_INVALID',
              DETAIL = format('base_salary=%s', v_row.payload->>'base_salary');
          END IF;
        END IF;
      END IF;

      IF v_row.payload ? 'allocated_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'allocated_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = 'allocated_fte is required';
        END IF;
        BEGIN
          v_allocated_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
              DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END;
        IF v_allocated_fte <= 0 OR v_allocated_fte > 1 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END IF;
      END IF;

      IF v_row.payload ? 'currency' THEN
        v_tmp_text := upper(btrim(v_row.payload->>'currency'));
        IF v_tmp_text IS NULL OR v_tmp_text = '' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_CURRENCY_UNSUPPORTED',
            DETAIL = 'currency is required';
        END IF;
        IF v_tmp_text <> 'CNY' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_CURRENCY_UNSUPPORTED',
            DETAIL = format('currency=%s', v_row.payload->>'currency');
        END IF;
        v_currency := v_tmp_text;
      END IF;

      IF v_row.payload ? 'profile' THEN
        IF jsonb_typeof(v_row.payload->'profile') <> 'object' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_PROFILE_INVALID',
            DETAIL = 'profile must be an object';
        END IF;
        v_profile := v_row.payload->'profile';
      END IF;
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_row.event_type);
    END IF;

    IF v_row.next_effective IS NULL THEN
      v_validity := daterange(v_row.effective_date, NULL, '[)');
    ELSE
      v_validity := daterange(v_row.effective_date, v_row.next_effective, '[)');
    END IF;

    IF v_status = 'active' THEN
      IF NOT EXISTS (
        SELECT 1
        FROM staffing.position_versions pv
        WHERE pv.tenant_id = p_tenant_id
          AND pv.position_id = v_position_id
          AND pv.lifecycle_status = 'active'
          AND pv.validity @> v_row.effective_date
        LIMIT 1
      ) THEN
        IF EXISTS (
          SELECT 1
          FROM staffing.position_versions pv
          WHERE pv.tenant_id = p_tenant_id
            AND pv.position_id = v_position_id
            AND pv.validity @> v_row.effective_date
          LIMIT 1
        ) THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_POSITION_DISABLED_AS_OF',
            DETAIL = format('position_id=%s as_of=%s', v_position_id, v_row.effective_date);
        END IF;

        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_NOT_FOUND_AS_OF',
          DETAIL = format('position_id=%s as_of=%s', v_position_id, v_row.effective_date);
      END IF;
    END IF;

    INSERT INTO staffing.assignment_versions (
      tenant_id,
      assignment_id,
      person_uuid,
      position_id,
      assignment_type,
      status,
      allocated_fte,
      base_salary,
      currency,
      profile,
      validity,
      last_event_id
    )
    VALUES (
      p_tenant_id,
      p_assignment_id,
      v_person_uuid,
      v_position_id,
      v_assignment_type,
      v_status,
      v_allocated_fte,
      v_base_salary,
      v_currency,
      v_profile,
      v_validity,
      v_row.event_db_id
    );

    IF v_status = 'active' THEN
      PERFORM staffing.assert_position_capacity(p_tenant_id, v_position_id, v_validity);
    END IF;

    v_prev_effective := v_row.effective_date;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM staffing.assignment_versions
      WHERE tenant_id = p_tenant_id AND assignment_id = p_assignment_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_GAP',
      DETAIL = 'assignment_versions must be gapless';
  END IF;

  SELECT validity INTO v_last_validity
  FROM staffing.assignment_versions
  WHERE tenant_id = p_tenant_id AND assignment_id = p_assignment_id
  ORDER BY lower(validity) DESC
  LIMIT 1;

  IF v_last_validity IS NOT NULL AND NOT upper_inf(v_last_validity) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_NOT_INFINITE',
      DETAIL = 'last assignment version validity must be unbounded (infinity)';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_assignment_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_assignment_id uuid,
  p_person_uuid uuid,
  p_assignment_type text,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.assignment_events%ROWTYPE;
  v_payload jsonb;
  v_existing_assignment_id uuid;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_assignment_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_id is required';
  END IF;
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_assignment_type IS NULL OR btrim(p_assignment_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_type is required';
  END IF;
  IF p_assignment_type <> 'primary' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported assignment_type: %s', p_assignment_type);
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_id, p_assignment_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  INSERT INTO staffing.assignments (tenant_id, id, person_uuid, assignment_type)
  VALUES (p_tenant_id, p_assignment_id, p_person_uuid, p_assignment_type)
  ON CONFLICT (tenant_id, person_uuid, assignment_type) DO NOTHING;

  SELECT id INTO v_existing_assignment_id
  FROM staffing.assignments
  WHERE tenant_id = p_tenant_id AND person_uuid = p_person_uuid AND assignment_type = p_assignment_type;

  IF v_existing_assignment_id IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'assignment identity missing';
  END IF;
  IF v_existing_assignment_id <> p_assignment_id THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_ID_MISMATCH',
      DETAIL = format('assignment_id=%s existing_id=%s', p_assignment_id, v_existing_assignment_id);
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);

  INSERT INTO staffing.assignment_events (
    event_id,
    tenant_id,
    assignment_id,
    person_uuid,
    assignment_type,
    event_type,
    effective_date,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_assignment_id,
    p_person_uuid,
    p_assignment_type,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.assignment_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.assignment_id <> p_assignment_id
      OR v_existing.person_uuid <> p_person_uuid
      OR v_existing.assignment_type <> p_assignment_type
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM staffing.replay_assignment_versions(p_tenant_id, p_assignment_id);

  -- NOTE: use dynamic SQL to avoid schema file ordering issues (P0-5 adds staffing.maybe_create_payroll_recalc_request_from_assignment_event later).
  EXECUTE 'SELECT staffing.maybe_create_payroll_recalc_request_from_assignment_event($1::uuid,$2::uuid,$3::uuid,$4::uuid,$5::text,$6::date,$7::jsonb,$8::text,$9::uuid);'
  USING p_event_id, p_tenant_id, p_assignment_id, p_person_uuid, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id;

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.replay_time_profile_versions(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_name text := NULL;
  v_lifecycle_status text := 'active';

  v_shift_start_local time := NULL;
  v_shift_end_local time := NULL;
  v_late_tolerance_minutes int := 0;
  v_early_leave_tolerance_minutes int := 0;

  v_overtime_min_minutes int := 0;
  v_overtime_rounding_mode text := 'NONE';
  v_overtime_rounding_unit_minutes int := 0;

  v_prev_effective date := NULL;
  v_validity daterange;
  v_last_validity daterange;

  v_tmp_text text;
  v_tmp_int int;
  v_has_any boolean := false;
  v_lock_key text;

  v_row record;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  v_lock_key := format('staffing:time-profile:%s', p_tenant_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM staffing.time_profile_versions
  WHERE tenant_id = p_tenant_id;

  FOR v_row IN
    SELECT
      e.id AS event_db_id,
      e.event_type,
      e.effective_date,
      e.payload,
      lead(e.effective_date) OVER (ORDER BY e.effective_date ASC, e.id ASC) AS next_effective
    FROM staffing.time_profile_events e
    WHERE e.tenant_id = p_tenant_id
    ORDER BY e.effective_date ASC, e.id ASC
  LOOP
    v_has_any := true;

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev_effective IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_name := NULL;
      v_lifecycle_status := 'active';
      v_late_tolerance_minutes := 0;
      v_early_leave_tolerance_minutes := 0;
      v_overtime_min_minutes := 0;
      v_overtime_rounding_mode := 'NONE';
      v_overtime_rounding_unit_minutes := 0;

      v_tmp_text := NULLIF(btrim(v_row.payload->>'shift_start_local'), '');
      IF v_tmp_text IS NULL THEN
        RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'shift_start_local is required';
      END IF;
      BEGIN
        v_shift_start_local := v_tmp_text::time;
      EXCEPTION
        WHEN others THEN
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid shift_start_local: %s', v_row.payload->>'shift_start_local');
      END;

      v_tmp_text := NULLIF(btrim(v_row.payload->>'shift_end_local'), '');
      IF v_tmp_text IS NULL THEN
        RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'shift_end_local is required';
      END IF;
      BEGIN
        v_shift_end_local := v_tmp_text::time;
      EXCEPTION
        WHEN others THEN
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid shift_end_local: %s', v_row.payload->>'shift_end_local');
      END;

      IF v_shift_end_local <= v_shift_start_local THEN
        RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'shift_end_local must be greater than shift_start_local';
      END IF;

      IF v_row.payload ? 'name' THEN
        v_name := NULLIF(btrim(v_row.payload->>'name'), '');
      END IF;

      IF v_row.payload ? 'lifecycle_status' THEN
        v_lifecycle_status := NULLIF(btrim(v_row.payload->>'lifecycle_status'), '');
        IF v_lifecycle_status IS NULL OR v_lifecycle_status NOT IN ('active','disabled') THEN
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid lifecycle_status: %s', v_row.payload->>'lifecycle_status');
        END IF;
      END IF;

      IF v_row.payload ? 'late_tolerance_minutes' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'late_tolerance_minutes'), '');
        IF v_tmp_text IS NULL THEN
          v_late_tolerance_minutes := 0;
        ELSE
          BEGIN
            v_late_tolerance_minutes := v_tmp_text::int;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid late_tolerance_minutes: %s', v_row.payload->>'late_tolerance_minutes');
          END;
          IF v_late_tolerance_minutes < 0 THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'late_tolerance_minutes must be non-negative';
          END IF;
        END IF;
      END IF;

      IF v_row.payload ? 'early_leave_tolerance_minutes' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'early_leave_tolerance_minutes'), '');
        IF v_tmp_text IS NULL THEN
          v_early_leave_tolerance_minutes := 0;
        ELSE
          BEGIN
            v_early_leave_tolerance_minutes := v_tmp_text::int;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid early_leave_tolerance_minutes: %s', v_row.payload->>'early_leave_tolerance_minutes');
          END;
          IF v_early_leave_tolerance_minutes < 0 THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'early_leave_tolerance_minutes must be non-negative';
          END IF;
        END IF;
      END IF;

      IF v_row.payload ? 'overtime_min_minutes' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'overtime_min_minutes'), '');
        IF v_tmp_text IS NULL THEN
          v_overtime_min_minutes := 0;
        ELSE
          BEGIN
            v_overtime_min_minutes := v_tmp_text::int;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid overtime_min_minutes: %s', v_row.payload->>'overtime_min_minutes');
          END;
          IF v_overtime_min_minutes < 0 THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'overtime_min_minutes must be non-negative';
          END IF;
        END IF;
      END IF;

      IF v_row.payload ? 'overtime_rounding_mode' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'overtime_rounding_mode'), '');
        IF v_tmp_text IS NULL THEN
          v_overtime_rounding_mode := 'NONE';
        ELSE
          v_overtime_rounding_mode := upper(v_tmp_text);
        END IF;
        IF v_overtime_rounding_mode NOT IN ('NONE','FLOOR','CEIL','NEAREST') THEN
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid overtime_rounding_mode: %s', v_row.payload->>'overtime_rounding_mode');
        END IF;
      END IF;

      IF v_row.payload ? 'overtime_rounding_unit_minutes' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'overtime_rounding_unit_minutes'), '');
        IF v_tmp_text IS NULL THEN
          v_overtime_rounding_unit_minutes := 0;
        ELSE
          BEGIN
            v_overtime_rounding_unit_minutes := v_tmp_text::int;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid overtime_rounding_unit_minutes: %s', v_row.payload->>'overtime_rounding_unit_minutes');
          END;
          IF v_overtime_rounding_unit_minutes < 0 THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'overtime_rounding_unit_minutes must be non-negative';
          END IF;
        END IF;
      END IF;
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev_effective IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;

      IF v_row.payload ? 'shift_start_local' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'shift_start_local'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'shift_start_local is required';
        END IF;
        BEGIN
          v_shift_start_local := v_tmp_text::time;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid shift_start_local: %s', v_row.payload->>'shift_start_local');
        END;
      END IF;

      IF v_row.payload ? 'shift_end_local' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'shift_end_local'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'shift_end_local is required';
        END IF;
        BEGIN
          v_shift_end_local := v_tmp_text::time;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid shift_end_local: %s', v_row.payload->>'shift_end_local');
        END;
      END IF;

      IF v_shift_end_local <= v_shift_start_local THEN
        RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'shift_end_local must be greater than shift_start_local';
      END IF;

      IF v_row.payload ? 'name' THEN
        v_name := NULLIF(btrim(v_row.payload->>'name'), '');
      END IF;

      IF v_row.payload ? 'lifecycle_status' THEN
        v_lifecycle_status := NULLIF(btrim(v_row.payload->>'lifecycle_status'), '');
        IF v_lifecycle_status IS NULL OR v_lifecycle_status NOT IN ('active','disabled') THEN
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid lifecycle_status: %s', v_row.payload->>'lifecycle_status');
        END IF;
      END IF;

      IF v_row.payload ? 'late_tolerance_minutes' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'late_tolerance_minutes'), '');
        IF v_tmp_text IS NULL THEN
          v_late_tolerance_minutes := 0;
        ELSE
          BEGIN
            v_late_tolerance_minutes := v_tmp_text::int;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid late_tolerance_minutes: %s', v_row.payload->>'late_tolerance_minutes');
          END;
          IF v_late_tolerance_minutes < 0 THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'late_tolerance_minutes must be non-negative';
          END IF;
        END IF;
      END IF;

      IF v_row.payload ? 'early_leave_tolerance_minutes' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'early_leave_tolerance_minutes'), '');
        IF v_tmp_text IS NULL THEN
          v_early_leave_tolerance_minutes := 0;
        ELSE
          BEGIN
            v_early_leave_tolerance_minutes := v_tmp_text::int;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid early_leave_tolerance_minutes: %s', v_row.payload->>'early_leave_tolerance_minutes');
          END;
          IF v_early_leave_tolerance_minutes < 0 THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'early_leave_tolerance_minutes must be non-negative';
          END IF;
        END IF;
      END IF;

      IF v_row.payload ? 'overtime_min_minutes' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'overtime_min_minutes'), '');
        IF v_tmp_text IS NULL THEN
          v_overtime_min_minutes := 0;
        ELSE
          BEGIN
            v_overtime_min_minutes := v_tmp_text::int;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid overtime_min_minutes: %s', v_row.payload->>'overtime_min_minutes');
          END;
          IF v_overtime_min_minutes < 0 THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'overtime_min_minutes must be non-negative';
          END IF;
        END IF;
      END IF;

      IF v_row.payload ? 'overtime_rounding_mode' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'overtime_rounding_mode'), '');
        IF v_tmp_text IS NULL THEN
          v_overtime_rounding_mode := 'NONE';
        ELSE
          v_overtime_rounding_mode := upper(v_tmp_text);
        END IF;
        IF v_overtime_rounding_mode NOT IN ('NONE','FLOOR','CEIL','NEAREST') THEN
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid overtime_rounding_mode: %s', v_row.payload->>'overtime_rounding_mode');
        END IF;
      END IF;

      IF v_row.payload ? 'overtime_rounding_unit_minutes' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'overtime_rounding_unit_minutes'), '');
        IF v_tmp_text IS NULL THEN
          v_overtime_rounding_unit_minutes := 0;
        ELSE
          BEGIN
            v_overtime_rounding_unit_minutes := v_tmp_text::int;
          EXCEPTION
            WHEN others THEN
              RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid overtime_rounding_unit_minutes: %s', v_row.payload->>'overtime_rounding_unit_minutes');
          END;
          IF v_overtime_rounding_unit_minutes < 0 THEN
            RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'overtime_rounding_unit_minutes must be non-negative';
          END IF;
        END IF;
      END IF;
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_row.event_type);
    END IF;

    IF v_row.next_effective IS NULL THEN
      v_validity := daterange(v_row.effective_date, NULL, '[)');
    ELSE
      v_validity := daterange(v_row.effective_date, v_row.next_effective, '[)');
    END IF;

    INSERT INTO staffing.time_profile_versions (
      tenant_id,
      name,
      lifecycle_status,
      shift_start_local,
      shift_end_local,
      late_tolerance_minutes,
      early_leave_tolerance_minutes,
      overtime_min_minutes,
      overtime_rounding_mode,
      overtime_rounding_unit_minutes,
      validity,
      last_event_id
    )
    VALUES (
      p_tenant_id,
      v_name,
      v_lifecycle_status,
      v_shift_start_local,
      v_shift_end_local,
      v_late_tolerance_minutes,
      v_early_leave_tolerance_minutes,
      v_overtime_min_minutes,
      v_overtime_rounding_mode,
      v_overtime_rounding_unit_minutes,
      v_validity,
      v_row.event_db_id
    );

    v_prev_effective := v_row.effective_date;
  END LOOP;

  IF NOT v_has_any THEN
    RETURN;
  END IF;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM staffing.time_profile_versions
      WHERE tenant_id = p_tenant_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_GAP',
      DETAIL = 'time_profile_versions must be gapless';
  END IF;

  SELECT validity INTO v_last_validity
  FROM staffing.time_profile_versions
  WHERE tenant_id = p_tenant_id
  ORDER BY lower(validity) DESC
  LIMIT 1;

  IF v_last_validity IS NOT NULL AND NOT upper_inf(v_last_validity) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_NOT_INFINITE',
      DETAIL = 'last time_profile version validity must be unbounded (infinity)';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_time_profile_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.time_profile_events%ROWTYPE;
  v_payload jsonb;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_lock_key := format('staffing:time-profile:%s', p_tenant_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;
  IF p_event_type = 'CREATE' THEN
    IF NULLIF(btrim(v_payload->>'shift_start_local'), '') IS NULL THEN
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'shift_start_local is required';
    END IF;
    IF NULLIF(btrim(v_payload->>'shift_end_local'), '') IS NULL THEN
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'shift_end_local is required';
    END IF;
  END IF;

  INSERT INTO staffing.time_profile_events (
    event_id,
    tenant_id,
    event_type,
    effective_date,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.time_profile_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM staffing.replay_time_profile_versions(p_tenant_id);

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_holiday_day_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_day_date date,
  p_event_type text,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.holiday_day_events%ROWTYPE;
  v_payload jsonb;
  v_day_type text;
  v_holiday_code text;
  v_note text;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_day_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'day_date is required';
  END IF;
  IF p_event_type NOT IN ('SET','CLEAR') THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_lock_key := format('staffing:holiday-day:%s:%s', p_tenant_id, p_day_date);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'SET' THEN
    v_day_type := NULLIF(btrim(v_payload->>'day_type'), '');
    IF v_day_type IS NULL OR v_day_type NOT IN ('WORKDAY','RESTDAY','LEGAL_HOLIDAY') THEN
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('invalid day_type: %s', v_payload->>'day_type');
    END IF;
    v_holiday_code := NULLIF(btrim(v_payload->>'holiday_code'), '');
    v_note := NULLIF(btrim(v_payload->>'note'), '');
  END IF;

  INSERT INTO staffing.holiday_day_events (
    event_id,
    tenant_id,
    day_date,
    event_type,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_day_date,
    p_event_type,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.holiday_day_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.day_date <> p_day_date
      OR v_existing.event_type <> p_event_type
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  IF p_event_type = 'SET' THEN
    INSERT INTO staffing.holiday_days (
      tenant_id,
      day_date,
      day_type,
      holiday_code,
      note,
      last_event_id,
      created_at,
      updated_at
    )
    VALUES (
      p_tenant_id,
      p_day_date,
      v_day_type,
      v_holiday_code,
      v_note,
      v_event_db_id,
      now(),
      now()
    )
    ON CONFLICT (tenant_id, day_date)
    DO UPDATE SET
      day_type = EXCLUDED.day_type,
      holiday_code = EXCLUDED.holiday_code,
      note = EXCLUDED.note,
      last_event_id = EXCLUDED.last_event_id,
      updated_at = EXCLUDED.updated_at;
  ELSE
    DELETE FROM staffing.holiday_days
    WHERE tenant_id = p_tenant_id AND day_date = p_day_date;
  END IF;

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.recompute_time_bank_cycle(
  p_tenant_id uuid,
  p_person_uuid uuid,
  p_work_date date
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_cycle_type text := 'MONTH';
  v_cycle_start date;
  v_cycle_end date;

  v_ruleset_version text := 'TIME_BANK_V1';

  v_worked_total int := 0;
  v_ot_150 int := 0;
  v_ot_200 int := 0;
  v_ot_300 int := 0;
  v_comp_earned int := 0;
  v_comp_used int := 0;

  v_input_max_id bigint := NULL;
  v_input_max_punch_time timestamptz := NULL;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_work_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'work_date is required';
  END IF;

  v_cycle_start := date_trunc('month', p_work_date)::date;
  v_cycle_end := ((date_trunc('month', p_work_date) + interval '1 month')::date - 1);

  PERFORM pg_advisory_xact_lock(
    hashtext(p_tenant_id::text),
    hashtext(p_person_uuid::text || ':' || v_cycle_type || ':' || v_cycle_start::text)
  );

  SELECT
    COALESCE(sum(worked_minutes), 0)::int,
    COALESCE(sum(overtime_minutes_150), 0)::int,
    COALESCE(sum(overtime_minutes_200), 0)::int,
    COALESCE(sum(overtime_minutes_300), 0)::int,
    COALESCE(sum(CASE WHEN day_type = 'RESTDAY' THEN overtime_minutes_200 ELSE 0 END), 0)::int,
    COALESCE(max(input_max_punch_event_db_id), NULL),
    COALESCE(max(input_max_punch_time), NULL)
  INTO
    v_worked_total,
    v_ot_150,
    v_ot_200,
    v_ot_300,
    v_comp_earned,
    v_input_max_id,
    v_input_max_punch_time
  FROM staffing.daily_attendance_results
  WHERE tenant_id = p_tenant_id
    AND person_uuid = p_person_uuid
    AND work_date >= v_cycle_start
    AND work_date <= v_cycle_end;

  INSERT INTO staffing.time_bank_cycles (
    tenant_id,
    person_uuid,
    cycle_type,
    cycle_start_date,
    cycle_end_date,
    ruleset_version,
    worked_minutes_total,
    overtime_minutes_150,
    overtime_minutes_200,
    overtime_minutes_300,
    comp_earned_minutes,
    comp_used_minutes,
    input_max_punch_event_db_id,
    input_max_punch_time,
    computed_at,
    created_at,
    updated_at
  )
  VALUES (
    p_tenant_id,
    p_person_uuid,
    v_cycle_type,
    v_cycle_start,
    v_cycle_end,
    v_ruleset_version,
    v_worked_total,
    v_ot_150,
    v_ot_200,
    v_ot_300,
    v_comp_earned,
    v_comp_used,
    v_input_max_id,
    v_input_max_punch_time,
    now(),
    now(),
    now()
  )
  ON CONFLICT (tenant_id, person_uuid, cycle_type, cycle_start_date)
  DO UPDATE SET
    cycle_end_date = EXCLUDED.cycle_end_date,
    ruleset_version = EXCLUDED.ruleset_version,
    worked_minutes_total = EXCLUDED.worked_minutes_total,
    overtime_minutes_150 = EXCLUDED.overtime_minutes_150,
    overtime_minutes_200 = EXCLUDED.overtime_minutes_200,
    overtime_minutes_300 = EXCLUDED.overtime_minutes_300,
    comp_earned_minutes = EXCLUDED.comp_earned_minutes,
    comp_used_minutes = EXCLUDED.comp_used_minutes,
    input_max_punch_event_db_id = EXCLUDED.input_max_punch_event_db_id,
    input_max_punch_time = EXCLUDED.input_max_punch_time,
    computed_at = EXCLUDED.computed_at,
    updated_at = EXCLUDED.updated_at;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.get_time_profile_for_work_date(
  p_tenant_id uuid,
  p_work_date date
)
RETURNS TABLE (
  shift_start_local time,
  shift_end_local time,
  late_tolerance_minutes int,
  early_leave_tolerance_minutes int,
  overtime_min_minutes int,
  overtime_rounding_mode text,
  overtime_rounding_unit_minutes int,
  time_profile_last_event_id bigint,
  shift_start timestamptz,
  shift_end timestamptz,
  window_start timestamptz,
  window_end timestamptz
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_tz text := 'Asia/Shanghai';
  v_window_before interval := interval '6 hours';
  v_window_after interval := interval '12 hours';
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_work_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'work_date is required';
  END IF;

  SELECT
    tp.shift_start_local,
    tp.shift_end_local,
    tp.late_tolerance_minutes,
    tp.early_leave_tolerance_minutes,
    tp.overtime_min_minutes,
    tp.overtime_rounding_mode,
    tp.overtime_rounding_unit_minutes,
    tp.last_event_id
  INTO
    shift_start_local,
    shift_end_local,
    late_tolerance_minutes,
    early_leave_tolerance_minutes,
    overtime_min_minutes,
    overtime_rounding_mode,
    overtime_rounding_unit_minutes,
    time_profile_last_event_id
  FROM staffing.time_profile_versions tp
  WHERE tp.tenant_id = p_tenant_id
    AND tp.lifecycle_status = 'active'
    AND tp.validity @> p_work_date
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_TIME_PROFILE_NOT_CONFIGURED_AS_OF',
      DETAIL = format('tenant_id=%s as_of=%s', p_tenant_id, p_work_date);
  END IF;

  shift_start := (p_work_date + shift_start_local) AT TIME ZONE v_tz;
  shift_end := (p_work_date + shift_end_local) AT TIME ZONE v_tz;
  window_start := shift_start - v_window_before;
  window_end := shift_end + v_window_after;

  RETURN NEXT;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.recompute_daily_attendance_result(
  p_tenant_id uuid,
  p_person_uuid uuid,
  p_work_date date
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ruleset_version text := 'TIME_PROFILE_V1';

  v_shift_start_local time := NULL;
  v_shift_end_local time := NULL;
  v_late_tolerance_min int := 0;
  v_early_tolerance_min int := 0;

  v_overtime_min_minutes int := 0;
  v_overtime_rounding_mode text := 'NONE';
  v_overtime_rounding_unit_minutes int := 0;

  v_shift_start timestamptz;
  v_shift_end timestamptz;
  v_window_start timestamptz;
  v_window_end timestamptz;

  v_punch_count int := 0;
  v_input_max_id bigint := NULL;
  v_input_max_punch_time timestamptz := NULL;

  v_expect text := 'IN';
  v_open_in_time timestamptz := NULL;

  v_first_in_time timestamptz := NULL;
  v_last_out_time timestamptz := NULL;

  v_day_type text := NULL;
  v_holiday_day_last_event_id bigint := NULL;

  v_scheduled_minutes int := 0;
  v_worked_minutes int := 0;
  v_overtime_minutes_150 int := 0;
  v_overtime_minutes_200 int := 0;
  v_overtime_minutes_300 int := 0;
  v_late_minutes int := 0;
  v_early_leave_minutes int := 0;

  v_time_profile_last_event_id bigint := NULL;

  v_status text := 'ABSENT';
  v_flags text[] := '{}'::text[];

  r record;
  v_delta_min int;
  v_raw_ot int := 0;
  v_rounded_ot int := 0;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_work_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'work_date is required';
  END IF;

  PERFORM pg_advisory_xact_lock(
    hashtext(p_tenant_id::text),
    hashtext(p_person_uuid::text || ':' || p_work_date::text)
  );

  SELECT
    shift_start_local,
    shift_end_local,
    late_tolerance_minutes,
    early_leave_tolerance_minutes,
    overtime_min_minutes,
    overtime_rounding_mode,
    overtime_rounding_unit_minutes,
    time_profile_last_event_id,
    shift_start,
    shift_end,
    window_start,
    window_end
  INTO
    v_shift_start_local,
    v_shift_end_local,
    v_late_tolerance_min,
    v_early_tolerance_min,
    v_overtime_min_minutes,
    v_overtime_rounding_mode,
    v_overtime_rounding_unit_minutes,
    v_time_profile_last_event_id,
    v_shift_start,
    v_shift_end,
    v_window_start,
    v_window_end
  FROM staffing.get_time_profile_for_work_date(p_tenant_id, p_work_date);

  v_scheduled_minutes := floor(extract(epoch FROM (v_shift_end_local - v_shift_start_local)) / 60.0)::int;
  IF v_scheduled_minutes < 0 THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'scheduled_minutes must be non-negative';
  END IF;

  SELECT day_type, last_event_id
  INTO v_day_type, v_holiday_day_last_event_id
  FROM staffing.holiday_days
  WHERE tenant_id = p_tenant_id
    AND day_date = p_work_date;

  IF NOT FOUND THEN
    IF extract(isodow FROM p_work_date) IN (6, 7) THEN
      v_day_type := 'RESTDAY';
    ELSE
      v_day_type := 'WORKDAY';
    END IF;
    v_holiday_day_last_event_id := NULL;
  END IF;

  FOR r IN
    SELECT e.id, e.punch_time, e.punch_type
    FROM staffing.time_punch_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.person_uuid = p_person_uuid
      AND e.punch_time >= v_window_start
      AND e.punch_time < v_window_end
      AND NOT EXISTS (
        SELECT 1
        FROM staffing.time_punch_void_events v
        WHERE v.tenant_id = e.tenant_id
          AND v.target_punch_event_db_id = e.id
      )
    ORDER BY e.punch_time ASC, e.id ASC
  LOOP
    v_punch_count := v_punch_count + 1;
    v_input_max_id := COALESCE(v_input_max_id, r.id);
    v_input_max_id := GREATEST(v_input_max_id, r.id);
    v_input_max_punch_time := COALESCE(v_input_max_punch_time, r.punch_time);
    v_input_max_punch_time := GREATEST(v_input_max_punch_time, r.punch_time);

    IF r.punch_type = 'IN' THEN
      IF v_expect = 'IN' THEN
        v_open_in_time := r.punch_time;
        v_expect := 'OUT';
        IF v_first_in_time IS NULL THEN
          v_first_in_time := r.punch_time;
        END IF;
      ELSE
        v_flags := array_append(v_flags, 'MISSING_OUT');
        v_open_in_time := r.punch_time;
        v_expect := 'OUT';
        IF v_first_in_time IS NULL THEN
          v_first_in_time := r.punch_time;
        END IF;
      END IF;
    ELSIF r.punch_type = 'OUT' THEN
      IF v_expect = 'OUT' AND v_open_in_time IS NOT NULL THEN
        v_delta_min := floor(extract(epoch FROM (r.punch_time - v_open_in_time)) / 60.0)::int;
        IF v_delta_min > 0 THEN
          v_worked_minutes := v_worked_minutes + v_delta_min;
        END IF;
        v_last_out_time := r.punch_time;
        v_open_in_time := NULL;
        v_expect := 'IN';
      ELSE
        v_flags := array_append(v_flags, 'MISSING_IN');
      END IF;
    ELSIF r.punch_type = 'RAW' THEN
      IF v_expect = 'IN' THEN
        v_open_in_time := r.punch_time;
        v_expect := 'OUT';
        IF v_first_in_time IS NULL THEN
          v_first_in_time := r.punch_time;
        END IF;
      ELSE
        IF v_expect = 'OUT' AND v_open_in_time IS NOT NULL THEN
          v_delta_min := floor(extract(epoch FROM (r.punch_time - v_open_in_time)) / 60.0)::int;
          IF v_delta_min > 0 THEN
            v_worked_minutes := v_worked_minutes + v_delta_min;
          END IF;
          v_last_out_time := r.punch_time;
          v_open_in_time := NULL;
          v_expect := 'IN';
        ELSE
          v_flags := array_append(v_flags, 'MISSING_IN');
        END IF;
      END IF;
    ELSE
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported punch_type in recompute: %s', r.punch_type);
    END IF;
  END LOOP;

  IF v_punch_count = 0 THEN
    IF v_day_type = 'WORKDAY' THEN
      v_status := 'ABSENT';
      v_flags := array_append(v_flags, 'ABSENT');
    ELSE
      v_status := 'OFF';
      v_flags := '{}'::text[];
    END IF;
  ELSE
    IF v_first_in_time IS NULL THEN
      v_flags := array_append(v_flags, 'MISSING_IN');
    END IF;
    IF v_expect = 'OUT' THEN
      v_flags := array_append(v_flags, 'MISSING_OUT');
    END IF;

    IF v_first_in_time IS NOT NULL THEN
      v_delta_min := floor(extract(epoch FROM (v_first_in_time - v_shift_start)) / 60.0)::int;
      IF v_delta_min > v_late_tolerance_min THEN
        v_late_minutes := v_delta_min - v_late_tolerance_min;
        v_flags := array_append(v_flags, 'LATE');
      END IF;
    END IF;

    IF v_last_out_time IS NOT NULL THEN
      v_delta_min := floor(extract(epoch FROM (v_shift_end - v_last_out_time)) / 60.0)::int;
      IF v_delta_min > v_early_tolerance_min THEN
        v_early_leave_minutes := v_delta_min - v_early_tolerance_min;
        v_flags := array_append(v_flags, 'EARLY_LEAVE');
      END IF;
    END IF;

    IF array_length(v_flags, 1) IS NULL THEN
      v_status := 'PRESENT';
    ELSE
      SELECT COALESCE(array_agg(DISTINCT f ORDER BY f), '{}'::text[]) INTO v_flags
      FROM unnest(v_flags) AS f;
      v_status := 'EXCEPTION';
    END IF;
  END IF;

  IF v_day_type = 'WORKDAY' THEN
    v_raw_ot := GREATEST(0, v_worked_minutes - v_scheduled_minutes);
  ELSE
    v_raw_ot := v_worked_minutes;
  END IF;

  IF v_raw_ot < v_overtime_min_minutes THEN
    v_raw_ot := 0;
  END IF;

  v_rounded_ot := v_raw_ot;
  IF v_rounded_ot > 0 AND v_overtime_rounding_unit_minutes > 0 AND v_overtime_rounding_mode <> 'NONE' THEN
    IF v_overtime_rounding_mode = 'FLOOR' THEN
      v_rounded_ot := floor(v_rounded_ot::numeric / v_overtime_rounding_unit_minutes::numeric) * v_overtime_rounding_unit_minutes;
    ELSIF v_overtime_rounding_mode = 'CEIL' THEN
      v_rounded_ot := ceiling(v_rounded_ot::numeric / v_overtime_rounding_unit_minutes::numeric) * v_overtime_rounding_unit_minutes;
    ELSIF v_overtime_rounding_mode = 'NEAREST' THEN
      v_rounded_ot := round(v_rounded_ot::numeric / v_overtime_rounding_unit_minutes::numeric) * v_overtime_rounding_unit_minutes;
    END IF;
  END IF;

  v_overtime_minutes_150 := 0;
  v_overtime_minutes_200 := 0;
  v_overtime_minutes_300 := 0;
  IF v_rounded_ot > 0 THEN
    IF v_day_type = 'WORKDAY' THEN
      v_overtime_minutes_150 := v_rounded_ot;
    ELSIF v_day_type = 'RESTDAY' THEN
      v_overtime_minutes_200 := v_rounded_ot;
    ELSIF v_day_type = 'LEGAL_HOLIDAY' THEN
      v_overtime_minutes_300 := v_rounded_ot;
    END IF;
  END IF;

  INSERT INTO staffing.daily_attendance_results (
    tenant_id,
    person_uuid,
    work_date,
    ruleset_version,
    day_type,
    status,
    flags,
    first_in_time,
    last_out_time,
    scheduled_minutes,
    worked_minutes,
    overtime_minutes_150,
    overtime_minutes_200,
    overtime_minutes_300,
    late_minutes,
    early_leave_minutes,
    input_punch_count,
    input_max_punch_event_db_id,
    input_max_punch_time,
    time_profile_last_event_id,
    holiday_day_last_event_id,
    computed_at,
    created_at,
    updated_at
  )
  VALUES (
    p_tenant_id,
    p_person_uuid,
    p_work_date,
    v_ruleset_version,
    v_day_type,
    v_status,
    v_flags,
    v_first_in_time,
    v_last_out_time,
    v_scheduled_minutes,
    v_worked_minutes,
    v_overtime_minutes_150,
    v_overtime_minutes_200,
    v_overtime_minutes_300,
    v_late_minutes,
    v_early_leave_minutes,
    v_punch_count,
    v_input_max_id,
    v_input_max_punch_time,
    v_time_profile_last_event_id,
    v_holiday_day_last_event_id,
    now(),
    now(),
    now()
  )
  ON CONFLICT (tenant_id, person_uuid, work_date)
  DO UPDATE SET
    ruleset_version = EXCLUDED.ruleset_version,
    day_type = EXCLUDED.day_type,
    status = EXCLUDED.status,
    flags = EXCLUDED.flags,
    first_in_time = EXCLUDED.first_in_time,
    last_out_time = EXCLUDED.last_out_time,
    scheduled_minutes = EXCLUDED.scheduled_minutes,
    worked_minutes = EXCLUDED.worked_minutes,
    overtime_minutes_150 = EXCLUDED.overtime_minutes_150,
    overtime_minutes_200 = EXCLUDED.overtime_minutes_200,
    overtime_minutes_300 = EXCLUDED.overtime_minutes_300,
    late_minutes = EXCLUDED.late_minutes,
    early_leave_minutes = EXCLUDED.early_leave_minutes,
    input_punch_count = EXCLUDED.input_punch_count,
    input_max_punch_event_db_id = EXCLUDED.input_max_punch_event_db_id,
    input_max_punch_time = EXCLUDED.input_max_punch_time,
    time_profile_last_event_id = EXCLUDED.time_profile_last_event_id,
    holiday_day_last_event_id = EXCLUDED.holiday_day_last_event_id,
    computed_at = EXCLUDED.computed_at,
    updated_at = EXCLUDED.updated_at;

  PERFORM staffing.recompute_time_bank_cycle(p_tenant_id, p_person_uuid, p_work_date);
END;
$$;

CREATE OR REPLACE FUNCTION staffing.recompute_daily_attendance_results_for_punch(
  p_tenant_id uuid,
  p_person_uuid uuid,
  p_punch_time timestamptz
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_tz text := 'Asia/Shanghai';
  v_local_date date;
  v_d1 date;
  v_d2 date;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_punch_time IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'punch_time is required';
  END IF;

  v_local_date := (p_punch_time AT TIME ZONE v_tz)::date;
  v_d1 := v_local_date - 1;
  v_d2 := v_local_date;

  PERFORM staffing.recompute_daily_attendance_result(p_tenant_id, p_person_uuid, v_d1);
  PERFORM staffing.recompute_daily_attendance_result(p_tenant_id, p_person_uuid, v_d2);
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_time_punch_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_person_uuid uuid,
  p_punch_time timestamptz,
  p_punch_type text,
  p_source_provider text,
  p_payload jsonb,
  p_source_raw_payload jsonb,
  p_device_info jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_event_db_id bigint;
  v_existing staffing.time_punch_events%ROWTYPE;
  v_payload jsonb;
  v_source_raw jsonb;
  v_device jsonb;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_punch_time IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'punch_time is required';
  END IF;
  IF p_punch_type NOT IN ('IN','OUT','RAW') THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported punch_type: %s', p_punch_type);
  END IF;
  IF p_source_provider NOT IN ('MANUAL','IMPORT','DINGTALK','WECOM') THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported source_provider: %s', p_source_provider);
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  v_source_raw := COALESCE(p_source_raw_payload, '{}'::jsonb);
  v_device := COALESCE(p_device_info, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;
  IF jsonb_typeof(v_source_raw) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'source_raw_payload must be an object';
  END IF;
  IF jsonb_typeof(v_device) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'device_info must be an object';
  END IF;

  INSERT INTO staffing.time_punch_events (
    event_id,
    tenant_id,
    person_uuid,
    punch_time,
    punch_type,
    source_provider,
    payload,
    source_raw_payload,
    device_info,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_person_uuid,
    p_punch_time,
    p_punch_type,
    p_source_provider,
    v_payload,
    v_source_raw,
    v_device,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.time_punch_events
    WHERE event_id = p_event_id;

    IF FOUND THEN
      IF v_existing.tenant_id <> p_tenant_id
        OR v_existing.person_uuid <> p_person_uuid
        OR v_existing.punch_time <> p_punch_time
        OR v_existing.punch_type <> p_punch_type
        OR v_existing.source_provider <> p_source_provider
        OR v_existing.payload <> v_payload
        OR v_existing.source_raw_payload <> v_source_raw
        OR v_existing.device_info <> v_device
        OR v_existing.request_id <> p_request_id
        OR v_existing.initiator_id <> p_initiator_id
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
          DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
      END IF;

      RETURN v_existing.id;
    END IF;

    SELECT * INTO v_existing
    FROM staffing.time_punch_events
    WHERE tenant_id = p_tenant_id
      AND request_id = p_request_id;

    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('request_id_conflict_not_found request_id=%s event_id=%s', p_request_id, p_event_id);
    END IF;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.person_uuid <> p_person_uuid
      OR v_existing.punch_time <> p_punch_time
      OR v_existing.punch_type <> p_punch_type
      OR v_existing.source_provider <> p_source_provider
      OR v_existing.payload <> v_payload
      OR v_existing.source_raw_payload <> v_source_raw
      OR v_existing.device_info <> v_device
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('request_id=%s existing_id=%s', p_request_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM staffing.recompute_daily_attendance_results_for_punch(p_tenant_id, p_person_uuid, p_punch_time);

  RETURN v_event_db_id;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00003_staffing_engine.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00004_staffing_payroll_tables.sql
-- Payroll (P0-1) tables + RLS

CREATE TABLE IF NOT EXISTS staffing.pay_period_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  pay_period_id uuid NOT NULL,
  event_type text NOT NULL,
  pay_group text NOT NULL,
  period daterange NOT NULL,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT pay_period_events_event_type_check CHECK (event_type IN ('CREATE')),
  CONSTRAINT pay_period_events_pay_group_nonempty_check CHECK (btrim(pay_group) <> ''),
  CONSTRAINT pay_period_events_pay_group_trim_check CHECK (pay_group = btrim(pay_group)),
  CONSTRAINT pay_period_events_pay_group_lower_check CHECK (pay_group = lower(pay_group)),
  CONSTRAINT pay_period_events_period_check CHECK (NOT isempty(period)),
  CONSTRAINT pay_period_events_period_bounds_check CHECK (lower_inc(period) AND NOT upper_inc(period)),
  CONSTRAINT pay_period_events_period_bounded_check CHECK (NOT lower_inf(period) AND NOT upper_inf(period)),
  CONSTRAINT pay_period_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT pay_period_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE INDEX IF NOT EXISTS pay_period_events_tenant_period_idx
  ON staffing.pay_period_events (tenant_id, pay_group, lower(period), id);

CREATE TABLE IF NOT EXISTS staffing.pay_periods (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  pay_group text NOT NULL,
  period daterange NOT NULL,
  status text NOT NULL DEFAULT 'open',
  closed_at timestamptz NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.pay_period_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id),
  CONSTRAINT pay_periods_pay_group_nonempty_check CHECK (btrim(pay_group) <> ''),
  CONSTRAINT pay_periods_pay_group_trim_check CHECK (pay_group = btrim(pay_group)),
  CONSTRAINT pay_periods_pay_group_lower_check CHECK (pay_group = lower(pay_group)),
  CONSTRAINT pay_periods_period_check CHECK (NOT isempty(period)),
  CONSTRAINT pay_periods_period_bounds_check CHECK (lower_inc(period) AND NOT upper_inc(period)),
  CONSTRAINT pay_periods_period_bounded_check CHECK (NOT lower_inf(period) AND NOT upper_inf(period)),
  CONSTRAINT pay_periods_status_check CHECK (status IN ('open','closed')),
  CONSTRAINT pay_periods_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      pay_group gist_text_ops WITH =,
      period WITH &&
    )
);

CREATE INDEX IF NOT EXISTS pay_periods_lookup_btree
  ON staffing.pay_periods (tenant_id, pay_group, lower(period) DESC);

CREATE TABLE IF NOT EXISTS staffing.payroll_run_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  run_id uuid NOT NULL,
  pay_period_id uuid NOT NULL,
  event_type text NOT NULL,
  run_state text NOT NULL DEFAULT 'draft',
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT payroll_run_events_event_type_check CHECK (event_type IN ('CREATE','CALC_START','CALC_FINISH','CALC_FAIL','FINALIZE')),
  CONSTRAINT payroll_run_events_run_state_check CHECK (run_state IN ('draft','calculating','calculated','failed','finalized')),
  CONSTRAINT payroll_run_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT payroll_run_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT payroll_run_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE INDEX IF NOT EXISTS payroll_run_events_tenant_run_idx
  ON staffing.payroll_run_events (tenant_id, run_id, id);

CREATE TABLE IF NOT EXISTS staffing.payroll_runs (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  pay_period_id uuid NOT NULL,
  run_state text NOT NULL DEFAULT 'draft',
  needs_recalc boolean NOT NULL DEFAULT false,
  calc_started_at timestamptz NULL,
  calc_finished_at timestamptz NULL,
  finalized_at timestamptz NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.payroll_run_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id),
  CONSTRAINT payroll_runs_run_state_check CHECK (run_state IN ('draft','calculating','calculated','failed','finalized')),
  CONSTRAINT payroll_runs_pay_period_fk FOREIGN KEY (tenant_id, pay_period_id) REFERENCES staffing.pay_periods(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS payroll_runs_by_period_btree
  ON staffing.payroll_runs (tenant_id, pay_period_id, created_at DESC, id);

--  pay period  1  finalized run
CREATE UNIQUE INDEX IF NOT EXISTS payroll_runs_one_finalized_per_period_unique
  ON staffing.payroll_runs (tenant_id, pay_period_id)
  WHERE run_state = 'finalized';

CREATE TABLE IF NOT EXISTS staffing.payslips (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  run_id uuid NOT NULL,
  pay_period_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  assignment_id uuid NOT NULL,
  currency char(3) NOT NULL DEFAULT 'CNY',
  gross_pay numeric(15,2) NOT NULL DEFAULT 0,
  net_pay numeric(15,2) NOT NULL DEFAULT 0,
  employer_total numeric(15,2) NOT NULL DEFAULT 0,
  last_run_event_id bigint NOT NULL REFERENCES staffing.payroll_run_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id),
  CONSTRAINT payslips_currency_check CHECK (currency = btrim(currency) AND currency = upper(currency)),
  CONSTRAINT payslips_run_fk FOREIGN KEY (tenant_id, run_id) REFERENCES staffing.payroll_runs(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payslips_period_fk FOREIGN KEY (tenant_id, pay_period_id) REFERENCES staffing.pay_periods(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payslips_run_person_assignment_unique UNIQUE (tenant_id, run_id, person_uuid, assignment_id)
);

CREATE INDEX IF NOT EXISTS payslips_by_run_btree
  ON staffing.payslips (tenant_id, run_id, person_uuid, assignment_id);

CREATE TABLE IF NOT EXISTS staffing.payslip_items (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  payslip_id uuid NOT NULL,
  item_code text NOT NULL,
  item_kind text NOT NULL,
  amount numeric(15,2) NOT NULL,
  meta jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_run_event_id bigint NOT NULL REFERENCES staffing.payroll_run_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT payslip_items_item_code_nonempty_check CHECK (btrim(item_code) <> ''),
  CONSTRAINT payslip_items_item_code_trim_check CHECK (item_code = btrim(item_code)),
  CONSTRAINT payslip_items_item_code_upper_check CHECK (item_code = upper(item_code)),
  CONSTRAINT payslip_items_item_kind_check CHECK (item_kind IN ('earning','deduction','employer_cost')),
  CONSTRAINT payslip_items_meta_is_object_check CHECK (jsonb_typeof(meta) = 'object'),
  CONSTRAINT payslip_items_payslip_fk FOREIGN KEY (tenant_id, payslip_id) REFERENCES staffing.payslips(tenant_id, id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS payslip_items_by_payslip_btree
  ON staffing.payslip_items (tenant_id, payslip_id, id);

CREATE INDEX IF NOT EXISTS payslip_items_by_event_btree
  ON staffing.payslip_items (tenant_id, last_run_event_id, id);

ALTER TABLE staffing.pay_period_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.pay_period_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.pay_period_events;
CREATE POLICY tenant_isolation ON staffing.pay_period_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.pay_periods ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.pay_periods FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.pay_periods;
CREATE POLICY tenant_isolation ON staffing.pay_periods
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.payroll_run_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payroll_run_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payroll_run_events;
CREATE POLICY tenant_isolation ON staffing.payroll_run_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.payroll_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payroll_runs FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payroll_runs;
CREATE POLICY tenant_isolation ON staffing.payroll_runs
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.payslips ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payslips FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payslips;
CREATE POLICY tenant_isolation ON staffing.payslips
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.payslip_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payslip_items FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payslip_items;
CREATE POLICY tenant_isolation ON staffing.payslip_items
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/staffing/infrastructure/persistence/schema/00004_staffing_payroll_tables.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00005_staffing_payroll_engine.sql
CREATE OR REPLACE FUNCTION staffing.submit_payroll_pay_period_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_pay_period_id uuid,
  p_pay_group text,
  p_period daterange,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.pay_period_events%ROWTYPE;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_pay_period_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'pay_period_id is required';
  END IF;
  IF p_pay_group IS NULL OR btrim(p_pay_group) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'pay_group is required';
  END IF;
  IF p_pay_group <> btrim(p_pay_group) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'pay_group must be trimmed';
  END IF;
  IF p_pay_group <> lower(p_pay_group) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'pay_group must be lower';
  END IF;
  IF p_period IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'period is required';
  END IF;
  IF isempty(p_period) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'period must be non-empty';
  END IF;
  IF NOT lower_inc(p_period) OR upper_inc(p_period) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'period must be [)';
  END IF;
  IF lower_inf(p_period) OR upper_inf(p_period) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'period must be bounded';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_lock_key := format('staffing:payroll:pay_period:%s:%s', p_tenant_id, p_pay_group);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  INSERT INTO staffing.pay_period_events (
    event_id,
    tenant_id,
    pay_period_id,
    event_type,
    pay_group,
    period,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_pay_period_id,
    'CREATE',
    p_pay_group,
    p_period,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.pay_period_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.pay_period_id <> p_pay_period_id
      OR v_existing.event_type <> 'CREATE'
      OR v_existing.pay_group <> p_pay_group
      OR v_existing.period <> p_period
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  BEGIN
    INSERT INTO staffing.pay_periods (
      tenant_id,
      id,
      pay_group,
      period,
      status,
      closed_at,
      last_event_id
    )
    VALUES (
      p_tenant_id,
      p_pay_period_id,
      p_pay_group,
      p_period,
      'open',
      NULL,
      v_event_db_id
    );
  EXCEPTION
    WHEN unique_violation THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_EXISTS',
        DETAIL = format('pay_period_id=%s', p_pay_period_id);
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_OVERLAP',
        DETAIL = format('pay_group=%s period=%s', p_pay_group, p_period);
  END;

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.payroll_run_events_after_insert_ensure_payslips_on_calc_finish()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_period daterange;
  v_now timestamptz;
BEGIN
  PERFORM staffing.assert_current_tenant(NEW.tenant_id);

  SELECT period INTO v_period
  FROM staffing.pay_periods
  WHERE tenant_id = NEW.tenant_id AND id = NEW.pay_period_id;

  IF v_period IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_NOT_FOUND',
      DETAIL = format('pay_period_id=%s', NEW.pay_period_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM staffing.assignment_versions av
    WHERE av.tenant_id = NEW.tenant_id
      AND av.assignment_type = 'primary'
      AND av.status = 'active'
      AND av.validity && v_period
      AND av.base_salary IS NULL
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_MISSING_BASE_SALARY',
      DETAIL = format('run_id=%s', NEW.run_id);
  END IF;

  v_now := now();

  INSERT INTO staffing.payslips (
    tenant_id,
    id,
    run_id,
    pay_period_id,
    person_uuid,
    assignment_id,
    currency,
    gross_pay,
    net_pay,
    employer_total,
    last_run_event_id,
    created_at,
    updated_at
  )
  SELECT
    NEW.tenant_id,
    gen_random_uuid(),
    NEW.run_id,
    NEW.pay_period_id,
    av.person_uuid,
    av.assignment_id,
    av.currency,
    0,
    0,
    0,
    NEW.id,
    v_now,
    v_now
  FROM staffing.assignment_versions av
  WHERE av.tenant_id = NEW.tenant_id
    AND av.assignment_type = 'primary'
    AND av.status = 'active'
    AND av.validity && v_period
  GROUP BY av.person_uuid, av.assignment_id, av.currency
  ON CONFLICT ON CONSTRAINT payslips_run_person_assignment_unique
  DO UPDATE SET
    pay_period_id = EXCLUDED.pay_period_id,
    currency = EXCLUDED.currency,
    last_run_event_id = EXCLUDED.last_run_event_id,
    updated_at = EXCLUDED.updated_at;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS payroll_run_events_calc_finish_ensure_payslips ON staffing.payroll_run_events;
CREATE TRIGGER payroll_run_events_calc_finish_ensure_payslips
AFTER INSERT ON staffing.payroll_run_events
FOR EACH ROW
WHEN (NEW.event_type = 'CALC_FINISH')
EXECUTE FUNCTION staffing.payroll_run_events_after_insert_ensure_payslips_on_calc_finish();

CREATE OR REPLACE FUNCTION staffing.submit_payroll_run_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_run_id uuid,
  p_pay_period_id uuid,
  p_event_type text,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.payroll_run_events%ROWTYPE;
  v_existing_run staffing.payroll_runs%ROWTYPE;
  v_payload jsonb;
  v_next_state text;
  v_now timestamptz;
  v_period_status text;
  v_pay_group text;
  v_period daterange;
  v_period_start date;
  v_period_end_excl date;
  v_period_days int;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_run_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'run_id is required';
  END IF;
  IF p_pay_period_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'pay_period_id is required';
  END IF;
  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_type is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','CALC_START','CALC_FINISH','CALC_FAIL','FINALIZE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;

  v_lock_key := format('staffing:payroll-run:%s:%s', p_tenant_id, p_run_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_now := now();

  BEGIN
    INSERT INTO staffing.payroll_run_events (
      event_id,
      tenant_id,
      run_id,
      pay_period_id,
      event_type,
      payload,
      request_id,
      initiator_id
    )
    VALUES (
      p_event_id,
      p_tenant_id,
      p_run_id,
      p_pay_period_id,
      p_event_type,
      v_payload,
      p_request_id,
      p_initiator_id
    )
    ON CONFLICT (event_id) DO NOTHING
    RETURNING id INTO v_event_db_id;
  EXCEPTION
    WHEN unique_violation THEN
      RAISE;
  END;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.payroll_run_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.run_id <> p_run_id
      OR v_existing.pay_period_id <> p_pay_period_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  SELECT * INTO v_existing_run
  FROM staffing.payroll_runs
  WHERE tenant_id = p_tenant_id AND id = p_run_id;

  IF p_event_type = 'CREATE' THEN
    IF FOUND THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_RUN_EXISTS',
        DETAIL = format('run_id=%s', p_run_id);
    END IF;

    SELECT status, pay_group, period INTO v_period_status, v_pay_group, v_period
    FROM staffing.pay_periods
    WHERE tenant_id = p_tenant_id AND id = p_pay_period_id;

    IF v_period_status IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_NOT_FOUND',
        DETAIL = format('pay_period_id=%s', p_pay_period_id);
    END IF;
    IF v_period_status <> 'open' THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_CLOSED',
        DETAIL = format('pay_period_id=%s status=%s', p_pay_period_id, v_period_status);
    END IF;

    INSERT INTO staffing.payroll_runs (
      tenant_id,
      id,
      pay_period_id,
      run_state,
      last_event_id
    )
    VALUES (
      p_tenant_id,
      p_run_id,
      p_pay_period_id,
      'draft',
      v_event_db_id
    );

    INSERT INTO staffing.payslips (
      tenant_id,
      id,
      run_id,
      pay_period_id,
      person_uuid,
      assignment_id,
      currency,
      gross_pay,
      net_pay,
      employer_total,
      last_run_event_id
    )
    SELECT
      p_tenant_id,
      gen_random_uuid(),
      p_run_id,
      p_pay_period_id,
      av.person_uuid,
      av.assignment_id,
      av.currency,
      0,
      0,
      0,
      v_event_db_id
    FROM staffing.assignment_versions av
    WHERE av.tenant_id = p_tenant_id
      AND av.assignment_type = 'primary'
      AND av.status = 'active'
      AND av.validity @> lower(v_period)
      AND av.base_salary IS NOT NULL;

    RETURN v_event_db_id;
  END IF;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RUN_NOT_FOUND',
      DETAIL = format('run_id=%s', p_run_id);
  END IF;

  IF v_existing_run.pay_period_id <> p_pay_period_id THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RUN_PAY_PERIOD_MISMATCH',
      DETAIL = format('run_id=%s pay_period_id=%s existing_pay_period_id=%s', p_run_id, p_pay_period_id, v_existing_run.pay_period_id);
  END IF;

  IF v_existing_run.run_state = 'finalized' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RUN_FINALIZED_READONLY',
      DETAIL = format('run_id=%s', p_run_id);
  END IF;

  IF p_event_type = 'CALC_START' THEN
    IF v_existing_run.run_state NOT IN ('draft','failed')
      AND NOT (v_existing_run.run_state = 'calculated' AND v_existing_run.needs_recalc = true)
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_RUN_INVALID_TRANSITION',
        DETAIL = format('run_id=%s run_state=%s event_type=%s', p_run_id, v_existing_run.run_state, p_event_type);
    END IF;
    v_next_state := 'calculating';
  ELSIF p_event_type = 'CALC_FINISH' THEN
    IF v_existing_run.run_state <> 'calculating' THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_RUN_INVALID_TRANSITION',
        DETAIL = format('run_id=%s run_state=%s event_type=%s', p_run_id, v_existing_run.run_state, p_event_type);
    END IF;
    v_next_state := 'calculated';
  ELSIF p_event_type = 'CALC_FAIL' THEN
    IF v_existing_run.run_state <> 'calculating' THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_RUN_INVALID_TRANSITION',
        DETAIL = format('run_id=%s run_state=%s event_type=%s', p_run_id, v_existing_run.run_state, p_event_type);
    END IF;
    v_next_state := 'failed';
  ELSIF p_event_type = 'FINALIZE' THEN
    IF v_existing_run.run_state <> 'calculated' THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_RUN_INVALID_TRANSITION',
        DETAIL = format('run_id=%s run_state=%s event_type=%s', p_run_id, v_existing_run.run_state, p_event_type);
    END IF;
    v_next_state := 'finalized';
  ELSE
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unexpected event_type: %s', p_event_type);
  END IF;

  SELECT status, pay_group, period INTO v_period_status, v_pay_group, v_period
  FROM staffing.pay_periods
  WHERE tenant_id = p_tenant_id AND id = p_pay_period_id;

  IF v_period_status IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_NOT_FOUND',
      DETAIL = format('pay_period_id=%s', p_pay_period_id);
  END IF;

  v_period_start := lower(v_period);
  v_period_end_excl := upper(v_period);
  v_period_days := (v_period_end_excl - v_period_start);

  IF p_event_type = 'CALC_START' THEN
    UPDATE staffing.payroll_runs
    SET
      run_state = v_next_state,
      calc_started_at = v_now,
      calc_finished_at = NULL,
      last_event_id = v_event_db_id,
      updated_at = v_now
    WHERE tenant_id = p_tenant_id AND id = p_run_id;
  ELSIF p_event_type = 'CALC_FINISH' THEN
    IF v_pay_group <> 'monthly' THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_PAY_GROUP_NOT_SUPPORTED',
        DETAIL = format('pay_group=%s', v_pay_group);
    END IF;
    IF v_period_start <> date_trunc('month', v_period_start)::date OR v_period_end_excl <> (date_trunc('month', v_period_start)::date + INTERVAL '1 month')::date THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_PERIOD_NOT_NATURAL_MONTH',
        DETAIL = format('period_start=%s period_end_exclusive=%s', v_period_start, v_period_end_excl);
    END IF;

    DELETE FROM staffing.payslip_items i
    USING staffing.payslips p
    WHERE p.tenant_id = p_tenant_id
      AND p.run_id = p_run_id
      AND i.tenant_id = p_tenant_id
      AND i.payslip_id = p.id;

    DELETE FROM staffing.payslips p
    WHERE p.tenant_id = p_tenant_id
      AND p.run_id = p_run_id
      AND NOT EXISTS (
        SELECT 1
        FROM staffing.assignment_versions av
        WHERE av.tenant_id = p_tenant_id
          AND av.assignment_type = 'primary'
          AND av.status = 'active'
          AND av.validity && v_period
          AND av.person_uuid = p.person_uuid
          AND av.assignment_id = p.assignment_id
      );

    INSERT INTO staffing.payslip_items (
      tenant_id,
      payslip_id,
      item_code,
      item_kind,
      amount,
      meta,
      last_run_event_id
    )
    SELECT
      p_tenant_id,
      p.id,
      'EARNING_BASE_SALARY',
      'earning',
      round(
        av.base_salary * av.allocated_fte
          * (least(coalesce(upper(av.validity), v_period_end_excl), v_period_end_excl) - greatest(lower(av.validity), v_period_start))::numeric
          / v_period_days::numeric,
        2
      ) AS amount,
      jsonb_build_object(
        'pay_group', v_pay_group,
        'period_start', v_period_start::text,
        'period_end_exclusive', v_period_end_excl::text,
        'segment_start', greatest(lower(av.validity), v_period_start)::text,
        'segment_end_exclusive', least(coalesce(upper(av.validity), v_period_end_excl), v_period_end_excl)::text,
        'base_salary', av.base_salary::text,
        'allocated_fte', av.allocated_fte::text,
        'overlap_days', (least(coalesce(upper(av.validity), v_period_end_excl), v_period_end_excl) - greatest(lower(av.validity), v_period_start))::text,
        'period_days', v_period_days::text,
        'ratio', ((least(coalesce(upper(av.validity), v_period_end_excl), v_period_end_excl) - greatest(lower(av.validity), v_period_start))::numeric / v_period_days::numeric)::text
      ),
      v_event_db_id
    FROM staffing.assignment_versions av
    JOIN staffing.payslips p
      ON p.tenant_id = p_tenant_id
      AND p.run_id = p_run_id
      AND p.person_uuid = av.person_uuid
      AND p.assignment_id = av.assignment_id
	    WHERE av.tenant_id = p_tenant_id
	      AND av.assignment_type = 'primary'
	      AND av.status = 'active'
	      AND av.validity && v_period;

	    INSERT INTO staffing.payslip_items (
	      tenant_id,
	      payslip_id,
	      item_code,
	      item_kind,
	      amount,
	      meta,
	      last_run_event_id
	    )
	    SELECT
	      p_tenant_id,
	      p.id,
	      a.item_code,
	      a.item_kind,
	      a.amount,
	      a.meta || jsonb_build_object(
	        'recalc_request_id', a.recalc_request_id::text,
	        'application_id', a.application_id::text,
	        'origin_pay_period_id', a.origin_pay_period_id::text,
	        'origin_run_id', a.origin_run_id::text,
	        'origin_payslip_id', a.origin_payslip_id
	      ),
	      v_event_db_id
	    FROM staffing.payslips p
	    JOIN staffing.payroll_adjustments a
	      ON a.tenant_id = p.tenant_id
	      AND a.target_run_id = p.run_id
	      AND a.person_uuid = p.person_uuid
	      AND a.assignment_id = p.assignment_id
	    WHERE p.tenant_id = p_tenant_id
	      AND p.run_id = p_run_id;

	    WITH sums AS (
	      SELECT
	        p.id AS payslip_id,
	        COALESCE(sum(i.amount) FILTER (WHERE i.item_kind = 'earning'), 0) AS gross,
	        COALESCE(sum(i.amount) FILTER (WHERE i.item_kind = 'deduction'), 0) AS deductions,
	        COALESCE(sum(i.amount) FILTER (WHERE i.item_kind = 'employer_cost'), 0) AS employer_cost
	      FROM staffing.payslips p
	      LEFT JOIN staffing.payslip_items i
	        ON i.tenant_id = p.tenant_id AND i.payslip_id = p.id
	      WHERE p.tenant_id = p_tenant_id AND p.run_id = p_run_id
      GROUP BY p.id
    )
	    UPDATE staffing.payslips p
	    SET
	      gross_pay = sums.gross,
	      net_pay = sums.gross - sums.deductions,
	      employer_total = sums.employer_cost,
	      last_run_event_id = v_event_db_id,
	      updated_at = v_now
	    FROM sums
	    WHERE p.tenant_id = p_tenant_id AND p.id = sums.payslip_id;

    -- NOTE: use dynamic SQL to avoid schema file ordering issues (P0-3 adds staffing.payroll_apply_social_insurance later).
    EXECUTE 'SELECT staffing.payroll_apply_social_insurance($1::uuid,$2::uuid,$3::uuid,$4::date,$5::date,$6::bigint,$7::timestamptz);'
    USING p_tenant_id, p_run_id, p_pay_period_id, v_period_start, v_period_end_excl, v_event_db_id, v_now;

    -- NOTE: use dynamic SQL to avoid schema file ordering issues (P0-4 adds staffing.payroll_apply_iit later).
    EXECUTE 'SELECT staffing.payroll_apply_iit($1::uuid,$2::uuid,$3::uuid,$4::bigint,$5::timestamptz);'
    USING p_tenant_id, p_run_id, p_pay_period_id, v_event_db_id, v_now;

    UPDATE staffing.payroll_runs
    SET
      run_state = v_next_state,
      calc_finished_at = v_now,
      needs_recalc = false,
      last_event_id = v_event_db_id,
      updated_at = v_now
    WHERE tenant_id = p_tenant_id AND id = p_run_id;
  ELSIF p_event_type = 'CALC_FAIL' THEN
    UPDATE staffing.payroll_runs
    SET
      run_state = v_next_state,
      last_event_id = v_event_db_id,
      updated_at = v_now
    WHERE tenant_id = p_tenant_id AND id = p_run_id;
  ELSIF p_event_type = 'FINALIZE' THEN
    -- NOTE: use dynamic SQL to avoid schema file ordering issues (P0-4 adds staffing.payroll_post_iit_balances later).
    EXECUTE 'SELECT staffing.payroll_post_iit_balances($1::uuid,$2::uuid,$3::uuid,$4::bigint,$5::timestamptz);'
    USING p_tenant_id, p_run_id, p_pay_period_id, v_event_db_id, v_now;

    BEGIN
      UPDATE staffing.payroll_runs
      SET
        run_state = v_next_state,
        finalized_at = v_now,
        last_event_id = v_event_db_id,
        updated_at = v_now
      WHERE tenant_id = p_tenant_id AND id = p_run_id;
    EXCEPTION
      WHEN unique_violation THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_PAYROLL_RUN_ALREADY_FINALIZED',
          DETAIL = format('pay_period_id=%s', p_pay_period_id);
    END;

    UPDATE staffing.pay_periods
    SET
      status = 'closed',
      closed_at = COALESCE(closed_at, v_now),
      updated_at = v_now
    WHERE tenant_id = p_tenant_id AND id = p_pay_period_id;
  ELSE
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = format('unexpected event_type: %s', p_event_type);
  END IF;

  RETURN v_event_db_id;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00005_staffing_payroll_engine.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00006_staffing_payroll_social_insurance_tables.sql
-- Payroll (P0-3) social insurance tables + RLS

CREATE TABLE IF NOT EXISTS staffing.social_insurance_policies (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  city_code text NOT NULL,
  hukou_type text NOT NULL,
  insurance_type text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id),
  CONSTRAINT social_insurance_policies_city_code_nonempty_check CHECK (btrim(city_code) <> ''),
  CONSTRAINT social_insurance_policies_city_code_trim_check CHECK (city_code = btrim(city_code)),
  CONSTRAINT social_insurance_policies_city_code_upper_check CHECK (city_code = upper(city_code)),
  CONSTRAINT social_insurance_policies_hukou_type_nonempty_check CHECK (btrim(hukou_type) <> ''),
  CONSTRAINT social_insurance_policies_hukou_type_trim_check CHECK (hukou_type = btrim(hukou_type)),
  CONSTRAINT social_insurance_policies_hukou_type_lower_check CHECK (hukou_type = lower(hukou_type)),
  CONSTRAINT social_insurance_policies_insurance_type_check CHECK (
    insurance_type IN ('PENSION','MEDICAL','UNEMPLOYMENT','INJURY','MATERNITY','HOUSING_FUND')
  ),
  CONSTRAINT social_insurance_policies_identity_unique UNIQUE (tenant_id, city_code, hukou_type, insurance_type)
);

CREATE INDEX IF NOT EXISTS social_insurance_policies_lookup_btree
  ON staffing.social_insurance_policies (tenant_id, city_code, hukou_type, insurance_type);

CREATE TABLE IF NOT EXISTS staffing.social_insurance_policy_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  policy_id uuid NOT NULL,
  city_code text NOT NULL,
  hukou_type text NOT NULL,
  insurance_type text NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT social_insurance_policy_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE')),
  CONSTRAINT social_insurance_policy_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT social_insurance_policy_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT social_insurance_policy_events_one_per_day_unique UNIQUE (tenant_id, policy_id, effective_date),
  CONSTRAINT social_insurance_policy_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT social_insurance_policy_events_city_code_trim_check CHECK (city_code = btrim(city_code)),
  CONSTRAINT social_insurance_policy_events_city_code_upper_check CHECK (city_code = upper(city_code)),
  CONSTRAINT social_insurance_policy_events_hukou_type_trim_check CHECK (hukou_type = btrim(hukou_type)),
  CONSTRAINT social_insurance_policy_events_hukou_type_lower_check CHECK (hukou_type = lower(hukou_type)),
  CONSTRAINT social_insurance_policy_events_insurance_type_check CHECK (
    insurance_type IN ('PENSION','MEDICAL','UNEMPLOYMENT','INJURY','MATERNITY','HOUSING_FUND')
  ),
  CONSTRAINT social_insurance_policy_events_policy_fk
    FOREIGN KEY (tenant_id, policy_id) REFERENCES staffing.social_insurance_policies(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS social_insurance_policy_events_tenant_policy_effective_idx
  ON staffing.social_insurance_policy_events (tenant_id, policy_id, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.social_insurance_policy_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  policy_id uuid NOT NULL,
  city_code text NOT NULL,
  hukou_type text NOT NULL,
  insurance_type text NOT NULL,
  employer_rate numeric(9,6) NOT NULL,
  employee_rate numeric(9,6) NOT NULL,
  base_floor numeric(15,2) NOT NULL,
  base_ceiling numeric(15,2) NOT NULL,
  rounding_rule text NOT NULL,
  precision smallint NOT NULL DEFAULT 2,
  rules_config jsonb NOT NULL DEFAULT '{}'::jsonb,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.social_insurance_policy_events(id),
  CONSTRAINT social_insurance_policy_versions_rules_is_object_check CHECK (jsonb_typeof(rules_config) = 'object'),
  CONSTRAINT social_insurance_policy_versions_rate_check CHECK (
    employer_rate >= 0 AND employer_rate <= 1 AND employee_rate >= 0 AND employee_rate <= 1
  ),
  CONSTRAINT social_insurance_policy_versions_base_check CHECK (
    base_floor >= 0 AND base_ceiling >= base_floor
  ),
  CONSTRAINT social_insurance_policy_versions_rounding_rule_check CHECK (rounding_rule IN ('HALF_UP','CEIL')),
  CONSTRAINT social_insurance_policy_versions_precision_check CHECK (precision >= 0 AND precision <= 2),
  CONSTRAINT social_insurance_policy_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT social_insurance_policy_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT social_insurance_policy_versions_policy_fk
    FOREIGN KEY (tenant_id, policy_id) REFERENCES staffing.social_insurance_policies(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT social_insurance_policy_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      policy_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS social_insurance_policy_versions_lookup_btree
  ON staffing.social_insurance_policy_versions (tenant_id, policy_id, lower(validity));

CREATE TABLE IF NOT EXISTS staffing.payslip_social_insurance_items (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  payslip_id uuid NOT NULL,
  run_id uuid NOT NULL,
  pay_period_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  assignment_id uuid NOT NULL,
  city_code text NOT NULL,
  hukou_type text NOT NULL,
  insurance_type text NOT NULL,
  base_amount numeric(15,2) NOT NULL,
  employee_amount numeric(15,2) NOT NULL,
  employer_amount numeric(15,2) NOT NULL,
  currency char(3) NOT NULL DEFAULT 'CNY',
  policy_id uuid NOT NULL,
  policy_last_event_id bigint NOT NULL REFERENCES staffing.social_insurance_policy_events(id),
  last_run_event_id bigint NOT NULL REFERENCES staffing.payroll_run_events(id),
  meta jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT payslip_social_insurance_items_currency_check CHECK (currency = btrim(currency) AND currency = upper(currency)),
  CONSTRAINT payslip_social_insurance_items_meta_is_object_check CHECK (jsonb_typeof(meta) = 'object'),
  CONSTRAINT payslip_social_insurance_items_amounts_check CHECK (base_amount >= 0 AND employee_amount >= 0 AND employer_amount >= 0),
  CONSTRAINT payslip_social_insurance_items_insurance_type_check CHECK (
    insurance_type IN ('PENSION','MEDICAL','UNEMPLOYMENT','INJURY','MATERNITY','HOUSING_FUND')
  ),
  CONSTRAINT payslip_social_insurance_items_payslip_fk
    FOREIGN KEY (tenant_id, payslip_id) REFERENCES staffing.payslips(tenant_id, id) ON DELETE CASCADE,
  CONSTRAINT payslip_social_insurance_items_run_fk
    FOREIGN KEY (tenant_id, run_id) REFERENCES staffing.payroll_runs(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payslip_social_insurance_items_period_fk
    FOREIGN KEY (tenant_id, pay_period_id) REFERENCES staffing.pay_periods(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payslip_social_insurance_items_policy_fk
    FOREIGN KEY (tenant_id, policy_id) REFERENCES staffing.social_insurance_policies(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payslip_social_insurance_items_identity_unique UNIQUE (tenant_id, payslip_id, insurance_type)
);

CREATE INDEX IF NOT EXISTS payslip_social_insurance_items_by_run_btree
  ON staffing.payslip_social_insurance_items (tenant_id, run_id, person_uuid, assignment_id, insurance_type);

ALTER TABLE staffing.social_insurance_policies ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.social_insurance_policies FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.social_insurance_policies;
CREATE POLICY tenant_isolation ON staffing.social_insurance_policies
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.social_insurance_policy_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.social_insurance_policy_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.social_insurance_policy_events;
CREATE POLICY tenant_isolation ON staffing.social_insurance_policy_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.social_insurance_policy_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.social_insurance_policy_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.social_insurance_policy_versions;
CREATE POLICY tenant_isolation ON staffing.social_insurance_policy_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.payslip_social_insurance_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payslip_social_insurance_items FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payslip_social_insurance_items;
CREATE POLICY tenant_isolation ON staffing.payslip_social_insurance_items
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);


-- end: modules/staffing/infrastructure/persistence/schema/00006_staffing_payroll_social_insurance_tables.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00007_staffing_payroll_social_insurance_engine.sql
CREATE OR REPLACE FUNCTION staffing.round_by_rule(
  p_value numeric,
  p_rounding_rule text,
  p_precision smallint
)
RETURNS numeric
LANGUAGE plpgsql
AS $$
DECLARE
  v_scale numeric;
BEGIN
  IF p_rounding_rule IS NULL OR btrim(p_rounding_rule) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'rounding_rule is required';
  END IF;
  IF p_rounding_rule NOT IN ('HALF_UP','CEIL') THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported rounding_rule: %s', p_rounding_rule);
  END IF;
  IF p_precision IS NULL OR p_precision < 0 OR p_precision > 2 THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('precision out of range: %s', p_precision);
  END IF;

  IF p_rounding_rule = 'HALF_UP' THEN
    RETURN round(p_value, p_precision);
  END IF;

  v_scale := power(10::numeric, p_precision);
  RETURN ceiling(p_value * v_scale) / v_scale;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.replay_social_insurance_policy_versions(
  p_tenant_id uuid,
  p_policy_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_prev_effective date;
  v_last_validity daterange;
  v_row RECORD;
  v_validity daterange;
  v_employer_rate numeric(9,6);
  v_employee_rate numeric(9,6);
  v_base_floor numeric(15,2);
  v_base_ceiling numeric(15,2);
  v_rounding_rule text;
  v_precision smallint;
  v_rules_config jsonb;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_policy_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'policy_id is required';
  END IF;

  v_lock_key := format('staffing:social_insurance_policy:%s:%s', p_tenant_id, p_policy_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM staffing.social_insurance_policy_versions
  WHERE tenant_id = p_tenant_id AND policy_id = p_policy_id;

  v_prev_effective := NULL;

  FOR v_row IN
    SELECT
      e.id AS event_db_id,
      e.event_type,
      e.effective_date,
      e.city_code,
      e.hukou_type,
      e.insurance_type,
      e.payload,
      lead(e.effective_date) OVER (ORDER BY e.effective_date ASC, e.id ASC) AS next_effective
    FROM staffing.social_insurance_policy_events e
    WHERE e.tenant_id = p_tenant_id AND e.policy_id = p_policy_id
    ORDER BY e.effective_date ASC, e.id ASC
  LOOP
    IF v_row.event_type = 'CREATE' THEN
      IF v_prev_effective IS NOT NULL THEN
        RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_EVENT', DETAIL = 'CREATE must be the first event';
      END IF;
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev_effective IS NULL THEN
        RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_EVENT', DETAIL = 'UPDATE requires prior state';
      END IF;
    ELSE
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unexpected event_type: %s', v_row.event_type);
    END IF;

    IF jsonb_typeof(v_row.payload) <> 'object'
      OR NOT (v_row.payload ? 'employer_rate')
      OR NOT (v_row.payload ? 'employee_rate')
      OR NOT (v_row.payload ? 'base_floor')
      OR NOT (v_row.payload ? 'base_ceiling')
      OR NOT (v_row.payload ? 'rounding_rule')
      OR NOT (v_row.payload ? 'precision')
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
        DETAIL = format('policy_id=%s event_db_id=%s', p_policy_id, v_row.event_db_id);
    END IF;

    BEGIN
      v_employer_rate := (v_row.payload->>'employer_rate')::numeric;
      v_employee_rate := (v_row.payload->>'employee_rate')::numeric;
      v_base_floor := (v_row.payload->>'base_floor')::numeric;
      v_base_ceiling := (v_row.payload->>'base_ceiling')::numeric;
      v_rounding_rule := btrim(v_row.payload->>'rounding_rule');
      v_precision := (v_row.payload->>'precision')::smallint;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
          DETAIL = format('policy_id=%s event_db_id=%s', p_policy_id, v_row.event_db_id);
    END;

    IF v_employer_rate < 0 OR v_employer_rate > 1 OR v_employee_rate < 0 OR v_employee_rate > 1 THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
        DETAIL = format('policy_id=%s event_db_id=%s rate out of range', p_policy_id, v_row.event_db_id);
    END IF;
    IF v_base_floor < 0 OR v_base_ceiling < v_base_floor THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
        DETAIL = format('policy_id=%s event_db_id=%s base_floor/base_ceiling invalid', p_policy_id, v_row.event_db_id);
    END IF;
    IF v_rounding_rule IS NULL OR v_rounding_rule = '' OR v_rounding_rule NOT IN ('HALF_UP','CEIL') THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
        DETAIL = format('policy_id=%s event_db_id=%s rounding_rule invalid', p_policy_id, v_row.event_db_id);
    END IF;
    IF v_precision < 0 OR v_precision > 2 THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
        DETAIL = format('policy_id=%s event_db_id=%s precision invalid', p_policy_id, v_row.event_db_id);
    END IF;

    IF v_row.payload ? 'rules_config' THEN
      v_rules_config := v_row.payload->'rules_config';
      IF jsonb_typeof(v_rules_config) <> 'object' THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
          DETAIL = format('policy_id=%s event_db_id=%s rules_config must be object', p_policy_id, v_row.event_db_id);
      END IF;
    ELSE
      v_rules_config := '{}'::jsonb;
    END IF;

    IF v_row.next_effective IS NULL THEN
      v_validity := daterange(v_row.effective_date, NULL, '[)');
    ELSE
      v_validity := daterange(v_row.effective_date, v_row.next_effective, '[)');
    END IF;

    INSERT INTO staffing.social_insurance_policy_versions (
      tenant_id,
      policy_id,
      city_code,
      hukou_type,
      insurance_type,
      employer_rate,
      employee_rate,
      base_floor,
      base_ceiling,
      rounding_rule,
      precision,
      rules_config,
      validity,
      last_event_id
    )
    VALUES (
      p_tenant_id,
      p_policy_id,
      v_row.city_code,
      v_row.hukou_type,
      v_row.insurance_type,
      v_employer_rate,
      v_employee_rate,
      v_base_floor,
      v_base_ceiling,
      v_rounding_rule,
      v_precision,
      v_rules_config,
      v_validity,
      v_row.event_db_id
    );

    v_prev_effective := v_row.effective_date;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM staffing.social_insurance_policy_versions
      WHERE tenant_id = p_tenant_id AND policy_id = p_policy_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_VALIDITY_GAP',
      DETAIL = 'social_insurance_policy_versions must be gapless';
  END IF;

  SELECT validity INTO v_last_validity
  FROM staffing.social_insurance_policy_versions
  WHERE tenant_id = p_tenant_id AND policy_id = p_policy_id
  ORDER BY lower(validity) DESC
  LIMIT 1;

  IF v_last_validity IS NOT NULL AND NOT upper_inf(v_last_validity) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_VALIDITY_NOT_INFINITE',
      DETAIL = 'last social_insurance_policy_versions validity must be unbounded (infinity)';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_social_insurance_policy_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_policy_id uuid,
  p_city_code text,
  p_hukou_type text,
  p_insurance_type text,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.social_insurance_policy_events%ROWTYPE;
  v_payload jsonb;
  v_existing_city_code text;
  v_identity_policy_id uuid;
  v_constraint text;
  v_employer_rate numeric(9,6);
  v_employee_rate numeric(9,6);
  v_base_floor numeric(15,2);
  v_base_ceiling numeric(15,2);
  v_rounding_rule text;
  v_precision smallint;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_policy_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'policy_id is required';
  END IF;
  IF p_city_code IS NULL OR btrim(p_city_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'city_code is required';
  END IF;
  IF p_city_code <> btrim(p_city_code) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'city_code must be trimmed';
  END IF;
  IF p_city_code <> upper(p_city_code) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'city_code must be upper';
  END IF;
  IF p_hukou_type IS NULL OR btrim(p_hukou_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'hukou_type is required';
  END IF;
  IF p_hukou_type <> btrim(p_hukou_type) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'hukou_type must be trimmed';
  END IF;
  IF p_hukou_type <> lower(p_hukou_type) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'hukou_type must be lower';
  END IF;
  IF p_hukou_type <> 'default' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_HUKOU_TYPE_NOT_SUPPORTED',
      DETAIL = format('hukou_type=%s', p_hukou_type);
  END IF;
  IF p_insurance_type IS NULL OR btrim(p_insurance_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'insurance_type is required';
  END IF;
  IF p_insurance_type NOT IN ('PENSION','MEDICAL','UNEMPLOYMENT','INJURY','MATERNITY','HOUSING_FUND') THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported insurance_type: %s', p_insurance_type);
  END IF;
  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_type is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;
  IF NOT (v_payload ? 'employer_rate')
    OR NOT (v_payload ? 'employee_rate')
    OR NOT (v_payload ? 'base_floor')
    OR NOT (v_payload ? 'base_ceiling')
    OR NOT (v_payload ? 'rounding_rule')
    OR NOT (v_payload ? 'precision')
  THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
      DETAIL = format('policy_id=%s', p_policy_id);
  END IF;
  BEGIN
    v_employer_rate := (v_payload->>'employer_rate')::numeric;
    v_employee_rate := (v_payload->>'employee_rate')::numeric;
    v_base_floor := (v_payload->>'base_floor')::numeric;
    v_base_ceiling := (v_payload->>'base_ceiling')::numeric;
    v_rounding_rule := btrim(v_payload->>'rounding_rule');
    v_precision := (v_payload->>'precision')::smallint;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
        DETAIL = format('policy_id=%s', p_policy_id);
  END;
  IF v_employer_rate < 0 OR v_employer_rate > 1 OR v_employee_rate < 0 OR v_employee_rate > 1 THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
      DETAIL = format('policy_id=%s rate out of range', p_policy_id);
  END IF;
  IF v_base_floor < 0 OR v_base_ceiling < v_base_floor THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
      DETAIL = format('policy_id=%s base_floor/base_ceiling invalid', p_policy_id);
  END IF;
  IF v_rounding_rule IS NULL OR v_rounding_rule = '' OR v_rounding_rule NOT IN ('HALF_UP','CEIL') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
      DETAIL = format('policy_id=%s rounding_rule invalid', p_policy_id);
  END IF;
  IF v_precision < 0 OR v_precision > 2 THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
      DETAIL = format('policy_id=%s precision invalid', p_policy_id);
  END IF;
  IF v_payload ? 'rules_config' AND jsonb_typeof(v_payload->'rules_config') <> 'object' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_PAYLOAD_REQUIRED',
      DETAIL = format('policy_id=%s rules_config must be object', p_policy_id);
  END IF;

  SELECT city_code INTO v_existing_city_code
  FROM staffing.social_insurance_policies
  WHERE tenant_id = p_tenant_id
  LIMIT 1;
  IF FOUND AND v_existing_city_code <> p_city_code THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_MULTI_CITY_NOT_SUPPORTED',
      DETAIL = format('existing_city_code=%s requested_city_code=%s', v_existing_city_code, p_city_code);
  END IF;

  INSERT INTO staffing.social_insurance_policies (
    tenant_id,
    id,
    city_code,
    hukou_type,
    insurance_type
  )
  VALUES (
    p_tenant_id,
    p_policy_id,
    p_city_code,
    p_hukou_type,
    p_insurance_type
  )
  ON CONFLICT (tenant_id, city_code, hukou_type, insurance_type) DO NOTHING;

  SELECT id INTO v_identity_policy_id
  FROM staffing.social_insurance_policies
  WHERE tenant_id = p_tenant_id
    AND city_code = p_city_code
    AND hukou_type = p_hukou_type
    AND insurance_type = p_insurance_type;

  IF v_identity_policy_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'policy identity missing after upsert';
  END IF;
  IF v_identity_policy_id <> p_policy_id THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_SOCIAL_INSURANCE_POLICY_ID_MISMATCH',
      DETAIL = format('policy_id=%s existing_policy_id=%s', p_policy_id, v_identity_policy_id);
  END IF;

  v_lock_key := format('staffing:social_insurance_policy:%s:%s', p_tenant_id, p_policy_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  BEGIN
    INSERT INTO staffing.social_insurance_policy_events (
      event_id,
      tenant_id,
      policy_id,
      city_code,
      hukou_type,
      insurance_type,
      event_type,
      effective_date,
      payload,
      request_id,
      initiator_id
    )
    VALUES (
      p_event_id,
      p_tenant_id,
      p_policy_id,
      p_city_code,
      p_hukou_type,
      p_insurance_type,
      p_event_type,
      p_effective_date,
      v_payload,
      p_request_id,
      p_initiator_id
    )
    ON CONFLICT (event_id) DO NOTHING
    RETURNING id INTO v_event_db_id;
  EXCEPTION
    WHEN unique_violation THEN
      GET STACKED DIAGNOSTICS v_constraint = CONSTRAINT_NAME;
      IF v_constraint = 'social_insurance_policy_events_one_per_day_unique' THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_EVENT_ONE_PER_DAY_CONFLICT',
          DETAIL = format('policy_id=%s effective_date=%s', p_policy_id, p_effective_date);
      END IF;
      RAISE;
  END;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.social_insurance_policy_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.policy_id <> p_policy_id
      OR v_existing.city_code <> p_city_code
      OR v_existing.hukou_type <> p_hukou_type
      OR v_existing.insurance_type <> p_insurance_type
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM staffing.replay_social_insurance_policy_versions(p_tenant_id, p_policy_id);

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.payroll_apply_social_insurance(
  p_tenant_id uuid,
  p_run_id uuid,
  p_pay_period_id uuid,
  p_period_start date,
  p_period_end_excl date,
  p_run_event_db_id bigint,
  p_now timestamptz
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_types int;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_run_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'run_id is required';
  END IF;
  IF p_pay_period_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'pay_period_id is required';
  END IF;
  IF p_period_start IS NULL OR p_period_end_excl IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'period bounds are required';
  END IF;
  IF p_period_end_excl <= p_period_start THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'invalid period bounds';
  END IF;
  IF p_run_event_db_id IS NULL OR p_run_event_db_id <= 0 THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'run_event_db_id is required';
  END IF;
  IF p_now IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'now is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM staffing.social_insurance_policies
    WHERE tenant_id = p_tenant_id
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_MISSING',
      DETAIL = format('tenant_id=%s', p_tenant_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM staffing.social_insurance_policy_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.effective_date > p_period_start
      AND e.effective_date < p_period_end_excl
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_CHANGED_WITHIN_PERIOD',
      DETAIL = format('period_start=%s period_end_exclusive=%s', p_period_start, p_period_end_excl);
  END IF;

  SELECT count(DISTINCT insurance_type) INTO v_types
  FROM staffing.social_insurance_policy_versions v
  WHERE v.tenant_id = p_tenant_id
    AND v.validity @> p_period_start;

  IF v_types <> 6 THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_SI_POLICY_NOT_FOUND_AS_OF',
      DETAIL = format('as_of=%s types_found=%s', p_period_start, v_types);
  END IF;

  DELETE FROM staffing.payslip_social_insurance_items i
  USING staffing.payslips p
  WHERE p.tenant_id = p_tenant_id
    AND p.run_id = p_run_id
    AND i.tenant_id = p_tenant_id
    AND i.payslip_id = p.id;

  WITH policy_as_of AS (
    SELECT
      v.policy_id,
      v.city_code,
      v.hukou_type,
      v.insurance_type,
      v.employer_rate,
      v.employee_rate,
      v.base_floor,
      v.base_ceiling,
      v.rounding_rule,
      v.precision,
      v.rules_config,
      v.validity,
      v.last_event_id
    FROM staffing.social_insurance_policy_versions v
    WHERE v.tenant_id = p_tenant_id
      AND v.validity @> p_period_start
  )
  INSERT INTO staffing.payslip_social_insurance_items (
    tenant_id,
    payslip_id,
    run_id,
    pay_period_id,
    person_uuid,
    assignment_id,
    city_code,
    hukou_type,
    insurance_type,
    base_amount,
    employee_amount,
    employer_amount,
    currency,
    policy_id,
    policy_last_event_id,
    last_run_event_id,
    meta,
    created_at,
    updated_at
  )
  SELECT
    p_tenant_id,
    p.id,
    p_run_id,
    p_pay_period_id,
    p.person_uuid,
    p.assignment_id,
    pol.city_code,
    pol.hukou_type,
    pol.insurance_type,
    GREATEST(pol.base_floor, LEAST(p.gross_pay, pol.base_ceiling)) AS base_amount,
    staffing.round_by_rule(
      GREATEST(pol.base_floor, LEAST(p.gross_pay, pol.base_ceiling)) * pol.employee_rate,
      pol.rounding_rule,
      pol.precision
    ) AS employee_amount,
    staffing.round_by_rule(
      GREATEST(pol.base_floor, LEAST(p.gross_pay, pol.base_ceiling)) * pol.employer_rate,
      pol.rounding_rule,
      pol.precision
    ) AS employer_amount,
    p.currency,
    pol.policy_id,
    pol.last_event_id,
    p_run_event_db_id,
    jsonb_build_object(
      'as_of', p_period_start::text,
      'policy_effective_date', lower(pol.validity)::text,
      'employer_rate', pol.employer_rate::text,
      'employee_rate', pol.employee_rate::text,
      'base_floor', pol.base_floor::text,
      'base_ceiling', pol.base_ceiling::text,
      'rounding_rule', pol.rounding_rule,
      'precision', pol.precision::text,
      'gross_pay', p.gross_pay::text
    ),
    p_now,
    p_now
  FROM staffing.payslips p
  CROSS JOIN policy_as_of pol
  WHERE p.tenant_id = p_tenant_id AND p.run_id = p_run_id;

  WITH sums AS (
    SELECT
      p.id AS payslip_id,
      COALESCE(sum(i.employee_amount), 0) AS employee_total,
      COALESCE(sum(i.employer_amount), 0) AS employer_total
    FROM staffing.payslips p
    LEFT JOIN staffing.payslip_social_insurance_items i
      ON i.tenant_id = p.tenant_id AND i.payslip_id = p.id
    WHERE p.tenant_id = p_tenant_id AND p.run_id = p_run_id
    GROUP BY p.id
  )
  UPDATE staffing.payslips p
  SET
    net_pay = p.net_pay - sums.employee_total,
    employer_total = p.employer_total + sums.employer_total,
    last_run_event_id = p_run_event_db_id,
    updated_at = p_now
  FROM sums
  WHERE p.tenant_id = p_tenant_id AND p.id = sums.payslip_id;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00007_staffing_payroll_social_insurance_engine.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00008_staffing_iit_deduction_claims.sql
CREATE TABLE IF NOT EXISTS staffing.iit_special_additional_deduction_claim_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  tax_year integer NOT NULL,
  tax_month smallint NOT NULL,
  amount numeric(15,2) NOT NULL,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT iit_sad_claim_events_tax_year_check CHECK (tax_year >= 2000 AND tax_year <= 9999),
  CONSTRAINT iit_sad_claim_events_tax_month_check CHECK (tax_month >= 1 AND tax_month <= 12),
  CONSTRAINT iit_sad_claim_events_amount_check CHECK (amount >= 0),
  CONSTRAINT iit_sad_claim_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT iit_sad_claim_events_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE INDEX IF NOT EXISTS iit_sad_claim_events_lookup_btree
  ON staffing.iit_special_additional_deduction_claim_events (tenant_id, person_uuid, tax_year, tax_month, id);

CREATE TABLE IF NOT EXISTS staffing.iit_special_additional_deduction_claims (
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  tax_year integer NOT NULL,
  tax_month smallint NOT NULL,
  amount numeric(15,2) NOT NULL DEFAULT 0,
  last_event_id bigint NOT NULL REFERENCES staffing.iit_special_additional_deduction_claim_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, person_uuid, tax_year, tax_month),
  CONSTRAINT iit_sad_claims_tax_year_check CHECK (tax_year >= 2000 AND tax_year <= 9999),
  CONSTRAINT iit_sad_claims_tax_month_check CHECK (tax_month >= 1 AND tax_month <= 12),
  CONSTRAINT iit_sad_claims_amount_check CHECK (amount >= 0)
);

ALTER TABLE staffing.iit_special_additional_deduction_claim_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.iit_special_additional_deduction_claim_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.iit_special_additional_deduction_claim_events;
CREATE POLICY tenant_isolation ON staffing.iit_special_additional_deduction_claim_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.iit_special_additional_deduction_claims ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.iit_special_additional_deduction_claims FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.iit_special_additional_deduction_claims;
CREATE POLICY tenant_isolation ON staffing.iit_special_additional_deduction_claims
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/staffing/infrastructure/persistence/schema/00008_staffing_iit_deduction_claims.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00009_staffing_payroll_balances.sql
CREATE TABLE IF NOT EXISTS staffing.payroll_balances (
  tenant_id uuid NOT NULL,
  tax_entity_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  tax_year integer NOT NULL,

  first_tax_month smallint NOT NULL,
  last_tax_month smallint NOT NULL,

  ytd_income numeric(15,2) NOT NULL DEFAULT 0,
  ytd_tax_exempt_income numeric(15,2) NOT NULL DEFAULT 0,
  ytd_standard_deduction numeric(15,2) NOT NULL DEFAULT 0,
  ytd_special_deduction numeric(15,2) NOT NULL DEFAULT 0,
  ytd_special_additional_deduction numeric(15,2) NOT NULL DEFAULT 0,

  ytd_taxable_income numeric(15,2) NOT NULL DEFAULT 0,
  ytd_iit_tax_liability numeric(15,2) NOT NULL DEFAULT 0,
  ytd_iit_withheld numeric(15,2) NOT NULL DEFAULT 0,
  ytd_iit_credit numeric(15,2) NOT NULL DEFAULT 0,

  last_pay_period_id uuid NOT NULL,
  last_run_id uuid NOT NULL,

  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),

  PRIMARY KEY (tenant_id, tax_entity_id, person_uuid, tax_year),
  CONSTRAINT payroll_balances_tax_year_check CHECK (tax_year >= 2000 AND tax_year <= 9999),
  CONSTRAINT payroll_balances_first_month_check CHECK (first_tax_month >= 1 AND first_tax_month <= 12),
  CONSTRAINT payroll_balances_last_month_check CHECK (last_tax_month >= 1 AND last_tax_month <= 12),
  CONSTRAINT payroll_balances_months_order_check CHECK (last_tax_month >= first_tax_month),
  CONSTRAINT payroll_balances_amounts_nonneg_check CHECK (
    ytd_income >= 0 AND ytd_tax_exempt_income >= 0 AND ytd_standard_deduction >= 0
    AND ytd_special_deduction >= 0 AND ytd_special_additional_deduction >= 0
    AND ytd_taxable_income >= 0 AND ytd_iit_tax_liability >= 0 AND ytd_iit_withheld >= 0 AND ytd_iit_credit >= 0
  )
);

CREATE INDEX IF NOT EXISTS payroll_balances_lookup_btree
  ON staffing.payroll_balances (tenant_id, person_uuid, tax_year);

ALTER TABLE staffing.payroll_balances ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payroll_balances FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payroll_balances;
CREATE POLICY tenant_isolation ON staffing.payroll_balances
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/staffing/infrastructure/persistence/schema/00009_staffing_payroll_balances.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00010_staffing_payroll_iit_engine.sql
CREATE OR REPLACE FUNCTION staffing.submit_iit_special_additional_deduction_claim_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_person_uuid uuid,
  p_tax_year integer,
  p_tax_month smallint,
  p_amount numeric,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_event_db_id bigint;
  v_existing staffing.iit_special_additional_deduction_claim_events%ROWTYPE;
  v_now timestamptz;
  v_lock_key text;
  v_period_start date;
  v_period_end_excl date;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_tax_year IS NULL OR p_tax_year < 2000 OR p_tax_year > 9999 THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'tax_year out of range';
  END IF;
  IF p_tax_month IS NULL OR p_tax_month < 1 OR p_tax_month > 12 THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'tax_month out of range';
  END IF;
  IF p_amount IS NULL OR p_amount < 0 THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'amount must be >= 0';
  END IF;
  IF btrim(coalesce(p_request_id, '')) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_lock_key := format('staffing:iit:sad:%s:%s:%s:%s', p_tenant_id, p_person_uuid, p_tax_year, p_tax_month);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_period_start := make_date(p_tax_year, p_tax_month, 1);
  v_period_end_excl := (v_period_start + interval '1 month')::date;

  IF EXISTS (
    SELECT 1
    FROM staffing.payroll_runs r
    JOIN staffing.pay_periods pp
      ON pp.tenant_id = r.tenant_id AND pp.id = r.pay_period_id
    WHERE r.tenant_id = p_tenant_id
      AND r.run_state = 'finalized'
      AND lower(pp.period) = v_period_start
      AND upper(pp.period) = v_period_end_excl
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_IIT_SAD_CLAIM_MONTH_FINALIZED',
      DETAIL = format('tax_year=%s tax_month=%s', p_tax_year, p_tax_month);
  END IF;

  INSERT INTO staffing.iit_special_additional_deduction_claim_events (
    event_id,
    tenant_id,
    person_uuid,
    tax_year,
    tax_month,
    amount,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_person_uuid,
    p_tax_year,
    p_tax_month,
    p_amount,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.iit_special_additional_deduction_claim_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.person_uuid <> p_person_uuid
      OR v_existing.tax_year <> p_tax_year
      OR v_existing.tax_month <> p_tax_month
      OR v_existing.amount <> p_amount
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  v_now := now();

  INSERT INTO staffing.iit_special_additional_deduction_claims (
    tenant_id,
    person_uuid,
    tax_year,
    tax_month,
    amount,
    last_event_id,
    created_at,
    updated_at
  )
  VALUES (
    p_tenant_id,
    p_person_uuid,
    p_tax_year,
    p_tax_month,
    p_amount,
    v_event_db_id,
    v_now,
    v_now
  )
  ON CONFLICT (tenant_id, person_uuid, tax_year, tax_month)
  DO UPDATE SET
    amount = EXCLUDED.amount,
    last_event_id = EXCLUDED.last_event_id,
    updated_at = EXCLUDED.updated_at;

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.iit_compute_cumulative_withholding(
  p_ytd_income numeric,
  p_ytd_tax_exempt_income numeric,
  p_ytd_standard_deduction numeric,
  p_ytd_special_deduction numeric,
  p_ytd_special_additional_deduction numeric,
  p_effective_withheld numeric
)
RETURNS TABLE (
  taxable_income numeric,
  tax_liability numeric,
  delta numeric,
  withhold_this_month numeric,
  credit numeric,
  rate numeric,
  quick_deduction numeric
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_taxable numeric;
  v_rate numeric;
  v_quick numeric;
  v_tax_liability numeric;
  v_delta numeric;
BEGIN
  v_taxable := greatest(
    0,
    coalesce(p_ytd_income, 0)
      - coalesce(p_ytd_tax_exempt_income, 0)
      - coalesce(p_ytd_standard_deduction, 0)
      - coalesce(p_ytd_special_deduction, 0)
      - coalesce(p_ytd_special_additional_deduction, 0)
  );

  IF v_taxable <= 36000 THEN
    v_rate := 0.03;
    v_quick := 0;
  ELSIF v_taxable <= 144000 THEN
    v_rate := 0.10;
    v_quick := 2520;
  ELSIF v_taxable <= 300000 THEN
    v_rate := 0.20;
    v_quick := 16920;
  ELSIF v_taxable <= 420000 THEN
    v_rate := 0.25;
    v_quick := 31920;
  ELSIF v_taxable <= 660000 THEN
    v_rate := 0.30;
    v_quick := 52920;
  ELSIF v_taxable <= 960000 THEN
    v_rate := 0.35;
    v_quick := 85920;
  ELSE
    v_rate := 0.45;
    v_quick := 181920;
  END IF;

  v_tax_liability := round(v_taxable * v_rate - v_quick, 2);
  IF v_tax_liability < 0 THEN
    v_tax_liability := 0;
  END IF;

  v_delta := v_tax_liability - coalesce(p_effective_withheld, 0);

  taxable_income := round(v_taxable, 2);
  tax_liability := v_tax_liability;
  delta := round(v_delta, 2);
  rate := v_rate;
  quick_deduction := v_quick;

  IF v_delta > 0 THEN
    withhold_this_month := round(v_delta, 2);
    credit := 0;
  ELSE
    withhold_this_month := 0;
    credit := round(-v_delta, 2);
  END IF;

  RETURN NEXT;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.iit_withhold_this_month_cents(
  p_ytd_income_cents bigint,
  p_ytd_tax_exempt_income_cents bigint,
  p_ytd_standard_deduction_cents bigint,
  p_ytd_special_deduction_cents bigint,
  p_ytd_special_additional_deduction_cents bigint,
  p_effective_withheld_cents bigint
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_withhold_this_month numeric;
BEGIN
  SELECT t.withhold_this_month INTO v_withhold_this_month
  FROM staffing.iit_compute_cumulative_withholding(
    round(coalesce(p_ytd_income_cents, 0)::numeric / 100, 2),
    round(coalesce(p_ytd_tax_exempt_income_cents, 0)::numeric / 100, 2),
    round(coalesce(p_ytd_standard_deduction_cents, 0)::numeric / 100, 2),
    round(coalesce(p_ytd_special_deduction_cents, 0)::numeric / 100, 2),
    round(coalesce(p_ytd_special_additional_deduction_cents, 0)::numeric / 100, 2),
    round(coalesce(p_effective_withheld_cents, 0)::numeric / 100, 2)
  ) t;

  RETURN round(coalesce(v_withhold_this_month, 0) * 100, 0)::bigint;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.payroll_apply_iit(
  p_tenant_id uuid,
  p_run_id uuid,
  p_pay_period_id uuid,
  p_run_event_db_id bigint,
  p_now timestamptz
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_period daterange;
  v_period_start date;
  v_period_end_excl date;
  v_tax_year integer;
  v_tax_month smallint;

  v_int64_max constant bigint := 9223372036854775807;
  v_net_guaranteed_payslip record;

  v_base_income_cents bigint;
  v_si_employee_cents bigint;
  v_sad_amount_cents bigint;
  v_first_tax_month smallint;

  v_prev_ytd_income_cents bigint;
  v_prev_ytd_tax_exempt_income_cents bigint;
  v_prev_ytd_special_deduction_cents bigint;
  v_prev_ytd_special_additional_deduction_cents bigint;
  v_prev_ytd_iit_withheld_cents bigint;
  v_prev_ytd_iit_credit_cents bigint;

  v_ytd_income_base_cents bigint;
  v_ytd_tax_exempt_income_cents bigint;
  v_ytd_standard_deduction_cents bigint;
  v_ytd_special_deduction_cents bigint;
  v_ytd_special_additional_deduction_cents bigint;
  v_effective_withheld_cents bigint;

  v_group_target_net_cents bigint;
  v_base_iit_withhold_cents bigint;
  v_test_iit_withhold_cents bigint;
  v_delta_iit_cents bigint;
  v_test_net_cents bigint;

  v_lo_cents bigint;
  v_hi_cents bigint;
  v_mid_cents bigint;
  v_expand int;
  v_iters int;
  v_solved_gross_cents bigint;
  v_group_delta_iit_cents bigint;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_run_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'run_id is required';
  END IF;
  IF p_pay_period_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'pay_period_id is required';
  END IF;
  IF p_run_event_db_id IS NULL OR p_run_event_db_id <= 0 THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'run_event_db_id is required';
  END IF;
  IF p_now IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'now is required';
  END IF;

  SELECT period INTO v_period
  FROM staffing.pay_periods
  WHERE tenant_id = p_tenant_id AND id = p_pay_period_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_NOT_FOUND',
      DETAIL = format('pay_period_id=%s', p_pay_period_id);
  END IF;

  v_period_start := lower(v_period);
  v_period_end_excl := upper(v_period);
  IF v_period_start IS NULL OR v_period_end_excl IS NULL
    OR date_trunc('month', v_period_start)::date <> v_period_start
    OR (v_period_start + interval '1 month')::date <> v_period_end_excl
  THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_IIT_PERIOD_NOT_MONTHLY',
      DETAIL = format('period=%s', v_period);
  END IF;

  v_tax_year := extract(year from v_period_start)::integer;
  v_tax_month := extract(month from v_period_start)::smallint;

  IF EXISTS (
    SELECT 1
    FROM staffing.payslips p
    JOIN staffing.payroll_balances b
      ON b.tenant_id = p.tenant_id
      AND b.tax_entity_id = p.tenant_id
      AND b.person_uuid = p.person_uuid
      AND b.tax_year = v_tax_year
    WHERE p.tenant_id = p_tenant_id
      AND p.run_id = p_run_id
      AND v_tax_month <= b.last_tax_month
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_IIT_BALANCES_MONTH_NOT_ADVANCING',
      DETAIL = format('tax_year=%s tax_month=%s', v_tax_year, v_tax_month);
  END IF;

  FOR v_net_guaranteed_payslip IN
    WITH
    si AS (
      SELECT
        i.payslip_id,
        COALESCE(sum(i.employee_amount), 0) AS employee_amount
      FROM staffing.payslip_social_insurance_items i
      WHERE i.tenant_id = p_tenant_id AND i.run_id = p_run_id
      GROUP BY i.payslip_id
    ),
    sad AS (
      SELECT
        c.person_uuid,
        c.amount
      FROM staffing.iit_special_additional_deduction_claims c
      WHERE c.tenant_id = p_tenant_id
        AND c.tax_year = v_tax_year
        AND c.tax_month = v_tax_month
    )
    SELECT
      p.id AS payslip_id,
      p.person_uuid,
      p.assignment_id,
      round(p.gross_pay * 100, 0)::bigint AS base_income_cents,
      round(COALESCE(si.employee_amount, 0) * 100, 0)::bigint AS si_employee_cents,
      round(COALESCE(sad.amount, 0) * 100, 0)::bigint AS sad_amount_cents,
      COALESCE(b.first_tax_month, v_tax_month) AS first_tax_month,
      round(COALESCE(b.ytd_income, 0) * 100, 0)::bigint AS prev_ytd_income_cents,
      round(COALESCE(b.ytd_tax_exempt_income, 0) * 100, 0)::bigint AS prev_ytd_tax_exempt_income_cents,
      round(COALESCE(b.ytd_special_deduction, 0) * 100, 0)::bigint AS prev_ytd_special_deduction_cents,
      round(COALESCE(b.ytd_special_additional_deduction, 0) * 100, 0)::bigint AS prev_ytd_special_additional_deduction_cents,
      round(COALESCE(b.ytd_iit_withheld, 0) * 100, 0)::bigint AS prev_ytd_iit_withheld_cents,
      round(COALESCE(b.ytd_iit_credit, 0) * 100, 0)::bigint AS prev_ytd_iit_credit_cents
    FROM staffing.payslips p
    LEFT JOIN staffing.payroll_balances b
      ON b.tenant_id = p.tenant_id
      AND b.tax_entity_id = p.tenant_id
      AND b.person_uuid = p.person_uuid
      AND b.tax_year = v_tax_year
    LEFT JOIN si ON si.payslip_id = p.id
    LEFT JOIN sad ON sad.person_uuid = p.person_uuid
    WHERE p.tenant_id = p_tenant_id
      AND p.run_id = p_run_id
      AND EXISTS (
        SELECT 1
        FROM staffing.payslip_item_inputs i
        WHERE i.tenant_id = p.tenant_id
          AND i.run_id = p.run_id
          AND i.person_uuid = p.person_uuid
          AND i.assignment_id = p.assignment_id
          AND i.calc_mode = 'net_guaranteed_iit'
      )
  LOOP
    v_base_income_cents := v_net_guaranteed_payslip.base_income_cents;
    v_si_employee_cents := v_net_guaranteed_payslip.si_employee_cents;
    v_sad_amount_cents := v_net_guaranteed_payslip.sad_amount_cents;
    v_first_tax_month := v_net_guaranteed_payslip.first_tax_month;

    v_prev_ytd_income_cents := v_net_guaranteed_payslip.prev_ytd_income_cents;
    v_prev_ytd_tax_exempt_income_cents := v_net_guaranteed_payslip.prev_ytd_tax_exempt_income_cents;
    v_prev_ytd_special_deduction_cents := v_net_guaranteed_payslip.prev_ytd_special_deduction_cents;
    v_prev_ytd_special_additional_deduction_cents := v_net_guaranteed_payslip.prev_ytd_special_additional_deduction_cents;
    v_prev_ytd_iit_withheld_cents := v_net_guaranteed_payslip.prev_ytd_iit_withheld_cents;
    v_prev_ytd_iit_credit_cents := v_net_guaranteed_payslip.prev_ytd_iit_credit_cents;

    SELECT round(sum(i.amount) * 100, 0)::bigint INTO v_group_target_net_cents
    FROM staffing.payslip_item_inputs i
    WHERE i.tenant_id = p_tenant_id
      AND i.run_id = p_run_id
      AND i.person_uuid = v_net_guaranteed_payslip.person_uuid
      AND i.assignment_id = v_net_guaranteed_payslip.assignment_id
      AND i.calc_mode = 'net_guaranteed_iit';

    IF v_group_target_net_cents IS NULL OR v_group_target_net_cents <= 0 THEN
      CONTINUE;
    END IF;

    v_ytd_income_base_cents := v_prev_ytd_income_cents + v_base_income_cents;
    v_ytd_tax_exempt_income_cents := v_prev_ytd_tax_exempt_income_cents;
    v_ytd_special_deduction_cents := v_prev_ytd_special_deduction_cents + v_si_employee_cents;
    v_ytd_special_additional_deduction_cents := v_prev_ytd_special_additional_deduction_cents + v_sad_amount_cents;
    v_ytd_standard_deduction_cents := 5000 * 100 * (v_tax_month - v_first_tax_month + 1);
    v_effective_withheld_cents := v_prev_ytd_iit_withheld_cents + v_prev_ytd_iit_credit_cents;

    v_base_iit_withhold_cents := staffing.iit_withhold_this_month_cents(
      v_ytd_income_base_cents,
      v_ytd_tax_exempt_income_cents,
      v_ytd_standard_deduction_cents,
      v_ytd_special_deduction_cents,
      v_ytd_special_additional_deduction_cents,
      v_effective_withheld_cents
    );

    v_lo_cents := v_group_target_net_cents;
    v_hi_cents := v_group_target_net_cents;

    FOR v_expand IN 1..32 LOOP
      v_test_iit_withhold_cents := staffing.iit_withhold_this_month_cents(
        v_ytd_income_base_cents + v_hi_cents,
        v_ytd_tax_exempt_income_cents,
        v_ytd_standard_deduction_cents,
        v_ytd_special_deduction_cents,
        v_ytd_special_additional_deduction_cents,
        v_effective_withheld_cents
      );
      v_delta_iit_cents := v_test_iit_withhold_cents - v_base_iit_withhold_cents;
      v_test_net_cents := v_hi_cents - v_delta_iit_cents;

      IF v_test_net_cents >= v_group_target_net_cents THEN
        EXIT;
      END IF;

      IF v_hi_cents > v_int64_max / 2 OR v_hi_cents > v_int64_max - v_ytd_income_base_cents THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_SOLVER_UPPER_BOUND_EXHAUSTED',
          DETAIL = format(
            'payslip_id=%s person_uuid=%s assignment_id=%s base_income=%s target_net=%s',
            v_net_guaranteed_payslip.payslip_id,
            v_net_guaranteed_payslip.person_uuid,
            v_net_guaranteed_payslip.assignment_id,
            (v_base_income_cents::numeric / 100)::text,
            (v_group_target_net_cents::numeric / 100)::text
          );
      END IF;

      v_hi_cents := v_hi_cents * 2;
    END LOOP;

    v_test_iit_withhold_cents := staffing.iit_withhold_this_month_cents(
      v_ytd_income_base_cents + v_hi_cents,
      v_ytd_tax_exempt_income_cents,
      v_ytd_standard_deduction_cents,
      v_ytd_special_deduction_cents,
      v_ytd_special_additional_deduction_cents,
      v_effective_withheld_cents
    );
    v_delta_iit_cents := v_test_iit_withhold_cents - v_base_iit_withhold_cents;
    v_test_net_cents := v_hi_cents - v_delta_iit_cents;
    IF v_test_net_cents < v_group_target_net_cents THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_SOLVER_UPPER_BOUND_EXHAUSTED',
        DETAIL = format(
          'payslip_id=%s person_uuid=%s assignment_id=%s base_income=%s target_net=%s hi=%s hi_net=%s',
          v_net_guaranteed_payslip.payslip_id,
          v_net_guaranteed_payslip.person_uuid,
          v_net_guaranteed_payslip.assignment_id,
          (v_base_income_cents::numeric / 100)::text,
          (v_group_target_net_cents::numeric / 100)::text,
          (v_hi_cents::numeric / 100)::text,
          (v_test_net_cents::numeric / 100)::text
        );
    END IF;

    v_iters := 0;
    WHILE v_lo_cents < v_hi_cents LOOP
      v_iters := v_iters + 1;
      v_mid_cents := (v_lo_cents + v_hi_cents) / 2;

      v_test_iit_withhold_cents := staffing.iit_withhold_this_month_cents(
        v_ytd_income_base_cents + v_mid_cents,
        v_ytd_tax_exempt_income_cents,
        v_ytd_standard_deduction_cents,
        v_ytd_special_deduction_cents,
        v_ytd_special_additional_deduction_cents,
        v_effective_withheld_cents
      );
      v_delta_iit_cents := v_test_iit_withhold_cents - v_base_iit_withhold_cents;
      v_test_net_cents := v_mid_cents - v_delta_iit_cents;

      IF v_test_net_cents >= v_group_target_net_cents THEN
        v_hi_cents := v_mid_cents;
      ELSE
        v_lo_cents := v_mid_cents + 1;
      END IF;
    END LOOP;

    v_solved_gross_cents := v_lo_cents;
    v_test_iit_withhold_cents := staffing.iit_withhold_this_month_cents(
      v_ytd_income_base_cents + v_solved_gross_cents,
      v_ytd_tax_exempt_income_cents,
      v_ytd_standard_deduction_cents,
      v_ytd_special_deduction_cents,
      v_ytd_special_additional_deduction_cents,
      v_effective_withheld_cents
    );
    v_group_delta_iit_cents := v_test_iit_withhold_cents - v_base_iit_withhold_cents;

    IF v_solved_gross_cents - v_group_delta_iit_cents <> v_group_target_net_cents THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_SOLVER_CONTRACT_VIOLATION',
        DETAIL = format(
          'payslip_id=%s person_uuid=%s assignment_id=%s target_net=%s solved_gross=%s delta_iit=%s',
          v_net_guaranteed_payslip.payslip_id,
          v_net_guaranteed_payslip.person_uuid,
          v_net_guaranteed_payslip.assignment_id,
          (v_group_target_net_cents::numeric / 100)::text,
          (v_solved_gross_cents::numeric / 100)::text,
          (v_group_delta_iit_cents::numeric / 100)::text
        );
    END IF;

    WITH
    inputs AS (
      SELECT
        i.id AS input_id,
        i.item_code,
        round(i.amount * 100, 0)::bigint AS target_net_cents,
        i.last_event_id AS input_last_event_id
      FROM staffing.payslip_item_inputs i
      WHERE i.tenant_id = p_tenant_id
        AND i.run_id = p_run_id
        AND i.person_uuid = v_net_guaranteed_payslip.person_uuid
        AND i.assignment_id = v_net_guaranteed_payslip.assignment_id
        AND i.calc_mode = 'net_guaranteed_iit'
    ),
    alloc_base AS (
      SELECT
        i.*,
        (v_group_delta_iit_cents::numeric * i.target_net_cents::numeric) AS mul,
        floor((v_group_delta_iit_cents::numeric * i.target_net_cents::numeric) / v_group_target_net_cents::numeric)::bigint AS q
      FROM inputs i
    ),
    alloc AS (
      SELECT
        a.*,
        (a.mul - (a.q::numeric * v_group_target_net_cents::numeric))::bigint AS r
      FROM alloc_base a
    ),
    residual AS (
      SELECT
        v_group_delta_iit_cents - sum(a.q) AS residual
      FROM alloc a
    ),
    ranked AS (
      SELECT
        a.*,
        row_number() OVER (ORDER BY a.r DESC, a.item_code ASC) AS rn,
        (SELECT residual FROM residual) AS residual
      FROM alloc a
    )
    INSERT INTO staffing.payslip_items (
      tenant_id,
      payslip_id,
      item_code,
      item_kind,
      amount,
      meta,
      last_run_event_id,
      calc_mode,
      tax_bearer,
      target_net,
      iit_delta
    )
    SELECT
      p_tenant_id,
      v_net_guaranteed_payslip.payslip_id,
      r.item_code,
      'earning',
      round(((r.target_net_cents + (r.q + CASE WHEN r.rn <= r.residual THEN 1 ELSE 0 END))::numeric) / 100, 2),
      jsonb_build_object(
        'input_id', r.input_id::text,
        'input_last_event_id', r.input_last_event_id::text,
        'tax_year', v_tax_year::text,
        'tax_month', v_tax_month::text,
        'group_target_net', (v_group_target_net_cents::numeric / 100)::text,
        'group_solved_gross', (v_solved_gross_cents::numeric / 100)::text,
        'group_delta_iit', (v_group_delta_iit_cents::numeric / 100)::text,
        'base_income', (v_base_income_cents::numeric / 100)::text,
        'base_iit_withhold', (v_base_iit_withhold_cents::numeric / 100)::text,
        'iterations', v_iters::text
      ),
      p_run_event_db_id,
      'net_guaranteed_iit',
      'employer',
      round((r.target_net_cents::numeric) / 100, 2),
      round(((r.q + CASE WHEN r.rn <= r.residual THEN 1 ELSE 0 END)::numeric) / 100, 2)
    FROM ranked r;

    UPDATE staffing.payslips p
    SET
      gross_pay = p.gross_pay + round(v_solved_gross_cents::numeric / 100, 2),
      net_pay = p.net_pay + round(v_solved_gross_cents::numeric / 100, 2),
      last_run_event_id = p_run_event_db_id,
      updated_at = p_now
    WHERE p.tenant_id = p_tenant_id AND p.id = v_net_guaranteed_payslip.payslip_id;
  END LOOP;

  WITH
  si AS (
    SELECT
      i.payslip_id,
      COALESCE(sum(i.employee_amount), 0) AS employee_amount
    FROM staffing.payslip_social_insurance_items i
    WHERE i.tenant_id = p_tenant_id AND i.run_id = p_run_id
    GROUP BY i.payslip_id
  ),
  sad AS (
    SELECT
      c.person_uuid,
      c.amount
    FROM staffing.iit_special_additional_deduction_claims c
    WHERE c.tenant_id = p_tenant_id
      AND c.tax_year = v_tax_year
      AND c.tax_month = v_tax_month
  ),
  calc AS (
    SELECT
      p.id AS payslip_id,
      p.person_uuid,
      p.gross_pay AS income_this_month,
      COALESCE(si.employee_amount, 0) AS si_employee_amount,
      COALESCE(sad.amount, 0) AS sad_amount_this_month,
      COALESCE(b.first_tax_month, v_tax_month) AS first_tax_month,
      COALESCE(b.ytd_income, 0) AS prev_ytd_income,
      COALESCE(b.ytd_tax_exempt_income, 0) AS prev_ytd_tax_exempt_income,
      COALESCE(b.ytd_special_deduction, 0) AS prev_ytd_special_deduction,
      COALESCE(b.ytd_special_additional_deduction, 0) AS prev_ytd_special_additional_deduction,
      COALESCE(b.ytd_iit_withheld, 0) AS prev_ytd_iit_withheld,
      COALESCE(b.ytd_iit_credit, 0) AS prev_ytd_iit_credit
    FROM staffing.payslips p
    LEFT JOIN staffing.payroll_balances b
      ON b.tenant_id = p.tenant_id
      AND b.tax_entity_id = p.tenant_id
      AND b.person_uuid = p.person_uuid
      AND b.tax_year = v_tax_year
    LEFT JOIN si ON si.payslip_id = p.id
    LEFT JOIN sad ON sad.person_uuid = p.person_uuid
    WHERE p.tenant_id = p_tenant_id AND p.run_id = p_run_id
  ),
  ytd AS (
    SELECT
      c.*,
      (c.prev_ytd_income + c.income_this_month) AS ytd_income,
      c.prev_ytd_tax_exempt_income AS ytd_tax_exempt_income,
      (c.prev_ytd_special_deduction + c.si_employee_amount) AS ytd_special_deduction,
      (c.prev_ytd_special_additional_deduction + c.sad_amount_this_month) AS ytd_special_additional_deduction,
      (5000::numeric * (v_tax_month - c.first_tax_month + 1)::numeric) AS ytd_standard_deduction,
      (c.prev_ytd_iit_withheld + c.prev_ytd_iit_credit) AS effective_withheld
    FROM calc c
  ),
  iit AS (
    SELECT
      y.*,
      t.taxable_income,
      t.tax_liability,
      t.delta,
      t.withhold_this_month,
      t.credit,
      t.rate,
      t.quick_deduction
    FROM ytd y
    CROSS JOIN LATERAL staffing.iit_compute_cumulative_withholding(
      y.ytd_income,
      y.ytd_tax_exempt_income,
      y.ytd_standard_deduction,
      y.ytd_special_deduction,
      y.ytd_special_additional_deduction,
      y.effective_withheld
    ) t
  )
  INSERT INTO staffing.payslip_items (
    tenant_id,
    payslip_id,
    item_code,
    item_kind,
    amount,
    meta,
    last_run_event_id
  )
  SELECT
    p_tenant_id,
    iit.payslip_id,
    'DEDUCTION_IIT_WITHHOLDING',
    'deduction',
    iit.withhold_this_month,
    jsonb_build_object(
      'tax_year', v_tax_year::text,
      'tax_month', v_tax_month::text,
      'first_tax_month', iit.first_tax_month::text,
      'income_this_month', iit.income_this_month::text,
      'si_employee_amount', iit.si_employee_amount::text,
      'sad_amount_this_month', iit.sad_amount_this_month::text,
      'ytd_income', iit.ytd_income::text,
      'ytd_tax_exempt_income', iit.ytd_tax_exempt_income::text,
      'ytd_standard_deduction', iit.ytd_standard_deduction::text,
      'ytd_special_deduction', iit.ytd_special_deduction::text,
      'ytd_special_additional_deduction', iit.ytd_special_additional_deduction::text,
      'taxable_income', iit.taxable_income::text,
      'rate', iit.rate::text,
      'quick_deduction', iit.quick_deduction::text,
      'tax_liability', iit.tax_liability::text,
      'effective_withheld', iit.effective_withheld::text,
      'delta', iit.delta::text,
      'withhold_this_month', iit.withhold_this_month::text,
      'credit', iit.credit::text
    ),
    p_run_event_db_id
  FROM iit;

  UPDATE staffing.payslips p
  SET
    net_pay = p.net_pay - iit.withhold_this_month,
    last_run_event_id = p_run_event_db_id,
    updated_at = p_now
  FROM (
    SELECT
      p.id AS payslip_id,
      i.amount AS withhold_this_month
    FROM staffing.payslips p
    JOIN staffing.payslip_items i
      ON i.tenant_id = p.tenant_id
      AND i.payslip_id = p.id
      AND i.item_code = 'DEDUCTION_IIT_WITHHOLDING'
      AND i.last_run_event_id = p_run_event_db_id
    WHERE p.tenant_id = p_tenant_id AND p.run_id = p_run_id
  ) AS iit
  WHERE p.tenant_id = p_tenant_id AND p.id = iit.payslip_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.payroll_post_iit_balances(
  p_tenant_id uuid,
  p_run_id uuid,
  p_pay_period_id uuid,
  p_run_event_db_id bigint,
  p_now timestamptz
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_period daterange;
  v_period_start date;
  v_period_end_excl date;
  v_tax_year integer;
  v_tax_month smallint;

  v_first_tax_month smallint;
  v_prev_last_tax_month smallint;
  v_prev_ytd_income numeric;
  v_prev_ytd_tax_exempt_income numeric;
  v_prev_ytd_special_deduction numeric;
  v_prev_ytd_special_additional_deduction numeric;
  v_prev_ytd_iit_withheld numeric;
  v_prev_ytd_iit_credit numeric;

  v_income_this_month numeric;
  v_si_employee_amount numeric;
  v_sad_amount_this_month numeric;

  v_ytd_income numeric;
  v_ytd_tax_exempt_income numeric;
  v_ytd_standard_deduction numeric;
  v_ytd_special_deduction numeric;
  v_ytd_special_additional_deduction numeric;

  v_taxable_income numeric;
  v_tax_liability numeric;
  v_delta numeric;
  v_withhold_this_month numeric;
  v_credit numeric;
  v_rate numeric;
  v_quick numeric;

  v_effective_withheld numeric;
  v_payslip_item_amount numeric;

  rec record;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_run_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'run_id is required';
  END IF;
  IF p_pay_period_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'pay_period_id is required';
  END IF;
  IF p_run_event_db_id IS NULL OR p_run_event_db_id <= 0 THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'run_event_db_id is required';
  END IF;
  IF p_now IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'now is required';
  END IF;

  SELECT period INTO v_period
  FROM staffing.pay_periods
  WHERE tenant_id = p_tenant_id AND id = p_pay_period_id
  FOR UPDATE;
  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_NOT_FOUND',
      DETAIL = format('pay_period_id=%s', p_pay_period_id);
  END IF;

  v_period_start := lower(v_period);
  v_period_end_excl := upper(v_period);
  IF v_period_start IS NULL OR v_period_end_excl IS NULL
    OR date_trunc('month', v_period_start)::date <> v_period_start
    OR (v_period_start + interval '1 month')::date <> v_period_end_excl
  THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_IIT_PERIOD_NOT_MONTHLY',
      DETAIL = format('period=%s', v_period);
  END IF;

  v_tax_year := extract(year from v_period_start)::integer;
  v_tax_month := extract(month from v_period_start)::smallint;

  FOR rec IN
    SELECT
      p.id AS payslip_id,
      p.person_uuid,
      p.gross_pay AS income_this_month,
      COALESCE((
        SELECT sum(i.employee_amount)
        FROM staffing.payslip_social_insurance_items i
        WHERE i.tenant_id = p.tenant_id AND i.payslip_id = p.id AND i.run_id = p_run_id
      ), 0) AS si_employee_amount,
      COALESCE((
        SELECT c.amount
        FROM staffing.iit_special_additional_deduction_claims c
        WHERE c.tenant_id = p.tenant_id
          AND c.person_uuid = p.person_uuid
          AND c.tax_year = v_tax_year
          AND c.tax_month = v_tax_month
      ), 0) AS sad_amount_this_month
    FROM staffing.payslips p
    WHERE p.tenant_id = p_tenant_id AND p.run_id = p_run_id
  LOOP
    SELECT amount INTO v_payslip_item_amount
    FROM staffing.payslip_items
    WHERE tenant_id = p_tenant_id
      AND payslip_id = rec.payslip_id
      AND item_code = 'DEDUCTION_IIT_WITHHOLDING'
    ORDER BY id DESC
    LIMIT 1;
    IF v_payslip_item_amount IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IIT_PAYSLIP_ITEM_MISSING',
        DETAIL = format('payslip_id=%s', rec.payslip_id);
    END IF;

    SELECT
      first_tax_month,
      last_tax_month,
      ytd_income,
      ytd_tax_exempt_income,
      ytd_special_deduction,
      ytd_special_additional_deduction,
      ytd_iit_withheld,
      ytd_iit_credit
    INTO
      v_first_tax_month,
      v_prev_last_tax_month,
      v_prev_ytd_income,
      v_prev_ytd_tax_exempt_income,
      v_prev_ytd_special_deduction,
      v_prev_ytd_special_additional_deduction,
      v_prev_ytd_iit_withheld,
      v_prev_ytd_iit_credit
    FROM staffing.payroll_balances
    WHERE tenant_id = p_tenant_id
      AND tax_entity_id = p_tenant_id
      AND person_uuid = rec.person_uuid
      AND tax_year = v_tax_year
    FOR UPDATE;

    IF NOT FOUND THEN
      v_first_tax_month := v_tax_month;
      v_prev_last_tax_month := 0;
      v_prev_ytd_income := 0;
      v_prev_ytd_tax_exempt_income := 0;
      v_prev_ytd_special_deduction := 0;
      v_prev_ytd_special_additional_deduction := 0;
      v_prev_ytd_iit_withheld := 0;
      v_prev_ytd_iit_credit := 0;
    ELSE
      IF v_tax_month <= v_prev_last_tax_month THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_IIT_BALANCES_MONTH_NOT_ADVANCING',
          DETAIL = format('tax_year=%s tax_month=%s last_tax_month=%s', v_tax_year, v_tax_month, v_prev_last_tax_month);
      END IF;
    END IF;

    v_income_this_month := rec.income_this_month;
    v_si_employee_amount := rec.si_employee_amount;
    v_sad_amount_this_month := rec.sad_amount_this_month;

    v_ytd_income := v_prev_ytd_income + v_income_this_month;
    v_ytd_tax_exempt_income := v_prev_ytd_tax_exempt_income;
    v_ytd_special_deduction := v_prev_ytd_special_deduction + v_si_employee_amount;
    v_ytd_special_additional_deduction := v_prev_ytd_special_additional_deduction + v_sad_amount_this_month;
    v_ytd_standard_deduction := 5000::numeric * (v_tax_month - v_first_tax_month + 1)::numeric;

    v_effective_withheld := v_prev_ytd_iit_withheld + v_prev_ytd_iit_credit;

    SELECT
      taxable_income,
      tax_liability,
      delta,
      withhold_this_month,
      credit,
      rate,
      quick_deduction
    INTO
      v_taxable_income,
      v_tax_liability,
      v_delta,
      v_withhold_this_month,
      v_credit,
      v_rate,
      v_quick
    FROM staffing.iit_compute_cumulative_withholding(
      v_ytd_income,
      v_ytd_tax_exempt_income,
      v_ytd_standard_deduction,
      v_ytd_special_deduction,
      v_ytd_special_additional_deduction,
      v_effective_withheld
    );

    IF v_payslip_item_amount <> v_withhold_this_month THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IIT_WITHHOLDING_MISMATCH_RECALC_REQUIRED',
        DETAIL = format('payslip_id=%s item=%s expected=%s', rec.payslip_id, v_payslip_item_amount::text, v_withhold_this_month::text);
    END IF;

    INSERT INTO staffing.payroll_balances (
      tenant_id,
      tax_entity_id,
      person_uuid,
      tax_year,
      first_tax_month,
      last_tax_month,
      ytd_income,
      ytd_tax_exempt_income,
      ytd_standard_deduction,
      ytd_special_deduction,
      ytd_special_additional_deduction,
      ytd_taxable_income,
      ytd_iit_tax_liability,
      ytd_iit_withheld,
      ytd_iit_credit,
      last_pay_period_id,
      last_run_id,
      created_at,
      updated_at
    )
    VALUES (
      p_tenant_id,
      p_tenant_id,
      rec.person_uuid,
      v_tax_year,
      v_first_tax_month,
      v_tax_month,
      v_ytd_income,
      v_ytd_tax_exempt_income,
      v_ytd_standard_deduction,
      v_ytd_special_deduction,
      v_ytd_special_additional_deduction,
      v_taxable_income,
      v_tax_liability,
      v_prev_ytd_iit_withheld + v_withhold_this_month,
      v_credit,
      p_pay_period_id,
      p_run_id,
      p_now,
      p_now
    )
    ON CONFLICT (tenant_id, tax_entity_id, person_uuid, tax_year)
    DO UPDATE SET
      last_tax_month = EXCLUDED.last_tax_month,
      ytd_income = EXCLUDED.ytd_income,
      ytd_tax_exempt_income = EXCLUDED.ytd_tax_exempt_income,
      ytd_standard_deduction = EXCLUDED.ytd_standard_deduction,
      ytd_special_deduction = EXCLUDED.ytd_special_deduction,
      ytd_special_additional_deduction = EXCLUDED.ytd_special_additional_deduction,
      ytd_taxable_income = EXCLUDED.ytd_taxable_income,
      ytd_iit_tax_liability = EXCLUDED.ytd_iit_tax_liability,
      ytd_iit_withheld = EXCLUDED.ytd_iit_withheld,
      ytd_iit_credit = EXCLUDED.ytd_iit_credit,
      last_pay_period_id = EXCLUDED.last_pay_period_id,
      last_run_id = EXCLUDED.last_run_id,
      updated_at = EXCLUDED.updated_at;
  END LOOP;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00010_staffing_payroll_iit_engine.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00011_staffing_payroll_recalc_tables.sql
-- Payroll (P0-5) retroactive accounting tables + RLS

CREATE TABLE IF NOT EXISTS staffing.payroll_recalc_requests (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  recalc_request_id uuid NOT NULL DEFAULT gen_random_uuid(),
  trigger_event_id uuid NOT NULL,
  trigger_source text NOT NULL DEFAULT 'assignment',
  person_uuid uuid NOT NULL,
  assignment_id uuid NOT NULL,
  effective_date date NOT NULL,
  hit_pay_period_id uuid NOT NULL,
  hit_run_id uuid NOT NULL,
  hit_payslip_id uuid NULL,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT payroll_recalc_requests_trigger_source_check CHECK (trigger_source IN ('assignment')),
  CONSTRAINT payroll_recalc_requests_request_id_nonempty_check CHECK (btrim(request_id) <> ''),
  CONSTRAINT payroll_recalc_requests_tenant_recalc_request_id_unique UNIQUE (tenant_id, recalc_request_id),
  CONSTRAINT payroll_recalc_requests_trigger_event_unique UNIQUE (tenant_id, trigger_event_id),
  CONSTRAINT payroll_recalc_requests_assignment_fk FOREIGN KEY (tenant_id, assignment_id) REFERENCES staffing.assignments(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_recalc_requests_hit_period_fk FOREIGN KEY (tenant_id, hit_pay_period_id) REFERENCES staffing.pay_periods(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_recalc_requests_hit_run_fk FOREIGN KEY (tenant_id, hit_run_id) REFERENCES staffing.payroll_runs(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_recalc_requests_hit_payslip_fk FOREIGN KEY (tenant_id, hit_payslip_id) REFERENCES staffing.payslips(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS payroll_recalc_requests_tenant_created_idx
  ON staffing.payroll_recalc_requests (tenant_id, created_at DESC, id DESC);

CREATE INDEX IF NOT EXISTS payroll_recalc_requests_tenant_person_effective_idx
  ON staffing.payroll_recalc_requests (tenant_id, person_uuid, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.payroll_recalc_applications (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  recalc_request_id uuid NOT NULL,
  target_run_id uuid NOT NULL,
  target_pay_period_id uuid NOT NULL,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT payroll_recalc_applications_request_id_nonempty_check CHECK (btrim(request_id) <> ''),
  CONSTRAINT payroll_recalc_applications_event_id_unique UNIQUE (event_id),
  CONSTRAINT payroll_recalc_applications_one_per_request_unique UNIQUE (tenant_id, recalc_request_id),
  CONSTRAINT payroll_recalc_applications_request_fk FOREIGN KEY (tenant_id, recalc_request_id) REFERENCES staffing.payroll_recalc_requests(tenant_id, recalc_request_id) ON DELETE RESTRICT,
  CONSTRAINT payroll_recalc_applications_target_run_fk FOREIGN KEY (tenant_id, target_run_id) REFERENCES staffing.payroll_runs(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_recalc_applications_target_period_fk FOREIGN KEY (tenant_id, target_pay_period_id) REFERENCES staffing.pay_periods(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS payroll_recalc_applications_tenant_created_idx
  ON staffing.payroll_recalc_applications (tenant_id, created_at DESC, id DESC);

CREATE TABLE IF NOT EXISTS staffing.payroll_adjustments (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  application_id bigint NOT NULL REFERENCES staffing.payroll_recalc_applications(id) ON DELETE RESTRICT,
  recalc_request_id uuid NOT NULL,
  target_run_id uuid NOT NULL,
  target_pay_period_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  assignment_id uuid NOT NULL,
  origin_pay_period_id uuid NOT NULL,
  origin_run_id uuid NOT NULL,
  origin_payslip_id uuid NULL,
  item_kind text NOT NULL,
  item_code text NOT NULL,
  amount numeric(15,2) NOT NULL,
  meta jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT payroll_adjustments_item_kind_check CHECK (item_kind IN ('earning','deduction','employer_cost')),
  CONSTRAINT payroll_adjustments_item_code_nonempty_check CHECK (btrim(item_code) <> ''),
  CONSTRAINT payroll_adjustments_item_code_trim_check CHECK (item_code = btrim(item_code)),
  CONSTRAINT payroll_adjustments_item_code_upper_check CHECK (item_code = upper(item_code)),
  CONSTRAINT payroll_adjustments_meta_is_object_check CHECK (jsonb_typeof(meta) = 'object'),
  CONSTRAINT payroll_adjustments_request_fk FOREIGN KEY (tenant_id, recalc_request_id) REFERENCES staffing.payroll_recalc_requests(tenant_id, recalc_request_id) ON DELETE RESTRICT,
  CONSTRAINT payroll_adjustments_target_run_fk FOREIGN KEY (tenant_id, target_run_id) REFERENCES staffing.payroll_runs(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_adjustments_target_period_fk FOREIGN KEY (tenant_id, target_pay_period_id) REFERENCES staffing.pay_periods(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_adjustments_assignment_fk FOREIGN KEY (tenant_id, assignment_id) REFERENCES staffing.assignments(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_adjustments_origin_period_fk FOREIGN KEY (tenant_id, origin_pay_period_id) REFERENCES staffing.pay_periods(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_adjustments_origin_run_fk FOREIGN KEY (tenant_id, origin_run_id) REFERENCES staffing.payroll_runs(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_adjustments_origin_payslip_fk FOREIGN KEY (tenant_id, origin_payslip_id) REFERENCES staffing.payslips(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT payroll_adjustments_no_duplicate_per_apply_unique UNIQUE (
    tenant_id,
    application_id,
    person_uuid,
    assignment_id,
    origin_pay_period_id,
    item_kind,
    item_code
  )
);

CREATE INDEX IF NOT EXISTS payroll_adjustments_target_lookup_idx
  ON staffing.payroll_adjustments (tenant_id, target_run_id, person_uuid, assignment_id, id);

CREATE INDEX IF NOT EXISTS payroll_adjustments_origin_lookup_idx
  ON staffing.payroll_adjustments (tenant_id, origin_pay_period_id, person_uuid, assignment_id, id);

ALTER TABLE staffing.payroll_recalc_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payroll_recalc_requests FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payroll_recalc_requests;
CREATE POLICY tenant_isolation ON staffing.payroll_recalc_requests
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.payroll_recalc_applications ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payroll_recalc_applications FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payroll_recalc_applications;
CREATE POLICY tenant_isolation ON staffing.payroll_recalc_applications
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.payroll_adjustments ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payroll_adjustments FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payroll_adjustments;
CREATE POLICY tenant_isolation ON staffing.payroll_adjustments
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);


-- end: modules/staffing/infrastructure/persistence/schema/00011_staffing_payroll_recalc_tables.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00012_staffing_payroll_recalc_engine.sql
-- Payroll (P0-5) retroactive accounting kernel functions

CREATE OR REPLACE FUNCTION staffing.maybe_create_payroll_recalc_request_from_assignment_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_assignment_id uuid,
  p_person_uuid uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
  v_hit_pay_period_id uuid;
  v_hit_run_id uuid;
  v_hit_payslip_id uuid;
  v_recalc_request_id uuid;
  v_payload jsonb;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_assignment_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_id is required';
  END IF;
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF btrim(coalesce(p_request_id, '')) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  IF p_event_type = 'UPDATE' THEN
    v_payload := COALESCE(p_payload, '{}'::jsonb);
    IF jsonb_typeof(v_payload) <> 'object' THEN
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be object';
    END IF;
    IF NOT (
      v_payload ? 'status'
      OR v_payload ? 'allocated_fte'
      OR v_payload ? 'base_salary'
      OR v_payload ? 'currency'
    ) THEN
      RETURN NULL;
    END IF;
  END IF;

  SELECT id INTO v_hit_pay_period_id
  FROM staffing.pay_periods
  WHERE tenant_id = p_tenant_id
    AND status = 'closed'
    AND upper(period) > p_effective_date
  ORDER BY lower(period) ASC, id ASC
  LIMIT 1;

  IF v_hit_pay_period_id IS NULL THEN
    RETURN NULL;
  END IF;

  SELECT id INTO v_hit_run_id
  FROM staffing.payroll_runs
  WHERE tenant_id = p_tenant_id
    AND pay_period_id = v_hit_pay_period_id
    AND run_state = 'finalized'
  ORDER BY created_at DESC, id ASC
  LIMIT 1;

  IF v_hit_run_id IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RECALC_HIT_FINALIZED_BUT_MISSING_RUN',
      DETAIL = format('hit_pay_period_id=%s', v_hit_pay_period_id);
  END IF;

  SELECT id INTO v_hit_payslip_id
  FROM staffing.payslips
  WHERE tenant_id = p_tenant_id
    AND run_id = v_hit_run_id
    AND person_uuid = p_person_uuid
    AND assignment_id = p_assignment_id
  LIMIT 1;

  INSERT INTO staffing.payroll_recalc_requests (
    tenant_id,
    trigger_event_id,
    trigger_source,
    person_uuid,
    assignment_id,
    effective_date,
    hit_pay_period_id,
    hit_run_id,
    hit_payslip_id,
    request_id,
    initiator_id
  )
  VALUES (
    p_tenant_id,
    p_event_id,
    'assignment',
    p_person_uuid,
    p_assignment_id,
    p_effective_date,
    v_hit_pay_period_id,
    v_hit_run_id,
    v_hit_payslip_id,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (tenant_id, trigger_event_id) DO NOTHING
  RETURNING recalc_request_id INTO v_recalc_request_id;

  IF v_recalc_request_id IS NULL THEN
    SELECT recalc_request_id INTO v_recalc_request_id
    FROM staffing.payroll_recalc_requests
    WHERE tenant_id = p_tenant_id
      AND trigger_event_id = p_event_id;
  END IF;

  RETURN v_recalc_request_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_payroll_recalc_apply_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_recalc_request_id uuid,
  p_target_run_id uuid,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_now timestamptz;

  v_req staffing.payroll_recalc_requests%ROWTYPE;
  v_existing_app staffing.payroll_recalc_applications%ROWTYPE;
  v_target_run staffing.payroll_runs%ROWTYPE;
  v_target_period staffing.pay_periods%ROWTYPE;
  v_hit_period staffing.pay_periods%ROWTYPE;

  v_target_period_start date;
  v_origin_tax_year integer;
  v_target_tax_year integer;

  v_app_id bigint;
  v_inserted int := 0;

  v_origin record;
  v_period_start date;
  v_period_end_excl date;
  v_period_days int;
  v_origin_payslip_id uuid;

  v_original_base_salary numeric(15,2);
  v_already_forwarded_base_salary numeric(15,2);
  v_recalculated_base_salary numeric(15,2);
  v_delta numeric(15,2);
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_recalc_request_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'recalc_request_id is required';
  END IF;
  IF p_target_run_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'target_run_id is required';
  END IF;
  IF btrim(coalesce(p_request_id, '')) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_lock_key := format('staffing:payroll:recalc:apply:%s:%s', p_tenant_id, p_recalc_request_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_req
  FROM staffing.payroll_recalc_requests
  WHERE tenant_id = p_tenant_id
    AND recalc_request_id = p_recalc_request_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RECALC_REQUEST_NOT_FOUND',
      DETAIL = format('recalc_request_id=%s', p_recalc_request_id);
  END IF;

  SELECT * INTO v_existing_app
  FROM staffing.payroll_recalc_applications
  WHERE tenant_id = p_tenant_id
    AND recalc_request_id = p_recalc_request_id;

  IF FOUND THEN
    IF v_existing_app.event_id <> p_event_id THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_RECALC_ALREADY_APPLIED',
        DETAIL = format('recalc_request_id=%s', p_recalc_request_id);
    END IF;
    RETURN v_existing_app.id;
  END IF;

  SELECT * INTO v_target_run
  FROM staffing.payroll_runs
  WHERE tenant_id = p_tenant_id
    AND id = p_target_run_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RUN_NOT_FOUND',
      DETAIL = format('run_id=%s', p_target_run_id);
  END IF;

  IF v_target_run.run_state NOT IN ('draft','failed') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RECALC_TARGET_RUN_NOT_EDITABLE',
      DETAIL = format('target_run_id=%s run_state=%s', p_target_run_id, v_target_run.run_state);
  END IF;

  SELECT * INTO v_target_period
  FROM staffing.pay_periods
  WHERE tenant_id = p_tenant_id
    AND id = v_target_run.pay_period_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_NOT_FOUND',
      DETAIL = format('pay_period_id=%s', v_target_run.pay_period_id);
  END IF;

  IF v_target_period.status <> 'open' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RECALC_TARGET_PERIOD_CLOSED',
      DETAIL = format('target_pay_period_id=%s status=%s', v_target_run.pay_period_id, v_target_period.status);
  END IF;

  SELECT * INTO v_hit_period
  FROM staffing.pay_periods
  WHERE tenant_id = p_tenant_id
    AND id = v_req.hit_pay_period_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_PAY_PERIOD_NOT_FOUND',
      DETAIL = format('hit_pay_period_id=%s', v_req.hit_pay_period_id);
  END IF;

  IF v_target_period.pay_group <> v_hit_period.pay_group THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RECALC_PAY_GROUP_MISMATCH',
      DETAIL = format('hit_pay_group=%s target_pay_group=%s', v_hit_period.pay_group, v_target_period.pay_group);
  END IF;

  v_origin_tax_year := extract(year from lower(v_hit_period.period))::integer;
  v_target_tax_year := extract(year from lower(v_target_period.period))::integer;
  IF v_origin_tax_year <> v_target_tax_year THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RECALC_CROSS_TAX_YEAR_UNSUPPORTED',
      DETAIL = format('origin_tax_year=%s target_tax_year=%s', v_origin_tax_year, v_target_tax_year);
  END IF;

  v_now := now();

  INSERT INTO staffing.payroll_recalc_applications (
    event_id,
    tenant_id,
    recalc_request_id,
    target_run_id,
    target_pay_period_id,
    request_id,
    initiator_id,
    transaction_time,
    created_at
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_recalc_request_id,
    p_target_run_id,
    v_target_run.pay_period_id,
    p_request_id,
    p_initiator_id,
    v_now,
    v_now
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_app_id;

  IF v_app_id IS NULL THEN
    SELECT * INTO v_existing_app
    FROM staffing.payroll_recalc_applications
    WHERE event_id = p_event_id;

    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s', p_event_id);
    END IF;

    IF v_existing_app.tenant_id <> p_tenant_id
      OR v_existing_app.recalc_request_id <> p_recalc_request_id
      OR v_existing_app.target_run_id <> p_target_run_id
      OR v_existing_app.target_pay_period_id <> v_target_run.pay_period_id
      OR v_existing_app.request_id <> p_request_id
      OR v_existing_app.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing_app.id);
    END IF;

    RETURN v_existing_app.id;
  END IF;

  v_target_period_start := lower(v_target_period.period);

  FOR v_origin IN
    SELECT
      pp.id AS pay_period_id,
      pp.period AS period,
      r.id AS run_id
    FROM staffing.pay_periods pp
    JOIN staffing.payroll_runs r
      ON r.tenant_id = pp.tenant_id
      AND r.pay_period_id = pp.id
      AND r.run_state = 'finalized'
    WHERE pp.tenant_id = p_tenant_id
      AND pp.status = 'closed'
      AND pp.pay_group = v_hit_period.pay_group
      AND upper(pp.period) > v_req.effective_date
      AND lower(pp.period) < v_target_period_start
    ORDER BY lower(pp.period) ASC, pp.id ASC
  LOOP
    v_period_start := lower(v_origin.period);
    v_period_end_excl := upper(v_origin.period);
    v_period_days := (v_period_end_excl - v_period_start);

    SELECT id INTO v_origin_payslip_id
    FROM staffing.payslips
    WHERE tenant_id = p_tenant_id
      AND run_id = v_origin.run_id
      AND person_uuid = v_req.person_uuid
      AND assignment_id = v_req.assignment_id
    LIMIT 1;

    IF v_origin_payslip_id IS NULL THEN
      v_original_base_salary := 0;
    ELSE
      SELECT COALESCE(sum(amount), 0) INTO v_original_base_salary
      FROM staffing.payslip_items
      WHERE tenant_id = p_tenant_id
        AND payslip_id = v_origin_payslip_id
        AND item_kind = 'earning'
        AND item_code = 'EARNING_BASE_SALARY';
    END IF;

    SELECT COALESCE(sum(amount), 0) INTO v_already_forwarded_base_salary
    FROM staffing.payroll_adjustments
    WHERE tenant_id = p_tenant_id
      AND person_uuid = v_req.person_uuid
      AND assignment_id = v_req.assignment_id
      AND origin_pay_period_id = v_origin.pay_period_id
      AND item_kind = 'earning'
      AND item_code = 'EARNING_BASE_SALARY';

    IF EXISTS (
      SELECT 1
      FROM staffing.assignment_versions av
      WHERE av.tenant_id = p_tenant_id
        AND av.assignment_id = v_req.assignment_id
        AND av.assignment_type = 'primary'
        AND av.status = 'active'
        AND av.validity && v_origin.period
        AND av.base_salary IS NULL
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_MISSING_BASE_SALARY',
        DETAIL = format('assignment_id=%s origin_pay_period_id=%s', v_req.assignment_id, v_origin.pay_period_id);
    END IF;

    SELECT COALESCE(sum(
      round(
        av.base_salary * av.allocated_fte
          * (least(coalesce(upper(av.validity), v_period_end_excl), v_period_end_excl) - greatest(lower(av.validity), v_period_start))::numeric
          / v_period_days::numeric,
        2
      )
    ), 0) INTO v_recalculated_base_salary
    FROM staffing.assignment_versions av
    WHERE av.tenant_id = p_tenant_id
      AND av.assignment_id = v_req.assignment_id
      AND av.person_uuid = v_req.person_uuid
      AND av.assignment_type = 'primary'
      AND av.status = 'active'
      AND av.validity && v_origin.period
      AND av.base_salary IS NOT NULL;

    v_delta := round(v_recalculated_base_salary - (v_original_base_salary + v_already_forwarded_base_salary), 2);

    IF v_delta <> 0 THEN
      INSERT INTO staffing.payroll_adjustments (
        tenant_id,
        application_id,
        recalc_request_id,
        target_run_id,
        target_pay_period_id,
        person_uuid,
        assignment_id,
        origin_pay_period_id,
        origin_run_id,
        origin_payslip_id,
        item_kind,
        item_code,
        amount,
        meta,
        created_at
      )
      VALUES (
        p_tenant_id,
        v_app_id,
        p_recalc_request_id,
        p_target_run_id,
        v_target_run.pay_period_id,
        v_req.person_uuid,
        v_req.assignment_id,
        v_origin.pay_period_id,
        v_origin.run_id,
        v_origin_payslip_id,
        'earning',
        'EARNING_BASE_SALARY',
        v_delta,
        jsonb_build_object(
          'trigger_event_id', v_req.trigger_event_id::text
        ),
        v_now
      );
      v_inserted := v_inserted + 1;
    END IF;
  END LOOP;

  IF v_inserted = 0 THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RECALC_NOTHING_TO_APPLY',
      DETAIL = format('recalc_request_id=%s', p_recalc_request_id);
  END IF;

  RETURN v_app_id;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00012_staffing_payroll_recalc_engine.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00013_staffing_payroll_item_inputs.sql
-- Payroll item inputs (net-guaranteed IIT / amount)  SSOT.

CREATE TABLE IF NOT EXISTS staffing.payslip_item_input_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,

  --  payslip natural key payslip_id 
  run_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  assignment_id uuid NOT NULL,

  event_type text NOT NULL, -- UPSERT / DELETE

  item_code text NOT NULL,
  item_kind text NOT NULL,  -- earning / deduction / employer_costP0-6  earning earning

  currency char(3) NOT NULL DEFAULT 'CNY',
  calc_mode text NOT NULL,   -- amount / net_guaranteed_iit
  tax_bearer text NOT NULL,  -- employee / employer

  -- amount 
  -- - calc_mode=amountamount 
  -- - calc_mode=net_guaranteed_iitamount  target_net IIT 
  amount numeric(15,2) NOT NULL,

  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT payslip_item_input_events_event_type_check CHECK (event_type IN ('UPSERT','DELETE')),
  CONSTRAINT payslip_item_input_events_code_check CHECK (btrim(item_code) <> '' AND item_code = btrim(item_code) AND item_code = upper(item_code) AND item_code ~ '^[A-Z0-9_]+$'),
  CONSTRAINT payslip_item_input_events_item_kind_check CHECK (item_kind IN ('earning','deduction','employer_cost')),
  CONSTRAINT payslip_item_input_events_currency_check CHECK (currency = btrim(currency) AND currency = upper(currency)),
  CONSTRAINT payslip_item_input_events_calc_mode_check CHECK (calc_mode IN ('amount','net_guaranteed_iit')),
  CONSTRAINT payslip_item_input_events_tax_bearer_check CHECK (tax_bearer IN ('employee','employer')),
  CONSTRAINT payslip_item_input_events_amount_positive_check CHECK (amount > 0),
  CONSTRAINT payslip_item_input_events_net_guaranteed_contract_check CHECK (
    calc_mode <> 'net_guaranteed_iit'
    OR (
      item_kind = 'earning'
      AND tax_bearer = 'employer'
      AND currency = 'CNY'
    )
  ),
  CONSTRAINT payslip_item_input_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT payslip_item_input_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT payslip_item_input_events_run_fk FOREIGN KEY (tenant_id, run_id) REFERENCES staffing.payroll_runs(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS payslip_item_input_events_lookup_btree
  ON staffing.payslip_item_input_events (tenant_id, run_id, person_uuid, assignment_id, item_code, id);

CREATE TABLE IF NOT EXISTS staffing.payslip_item_inputs (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),

  run_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  assignment_id uuid NOT NULL,

  item_code text NOT NULL,
  item_kind text NOT NULL,
  currency char(3) NOT NULL DEFAULT 'CNY',
  calc_mode text NOT NULL,
  tax_bearer text NOT NULL,
  amount numeric(15,2) NOT NULL,

  last_event_id bigint NOT NULL REFERENCES staffing.payslip_item_input_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),

  PRIMARY KEY (tenant_id, id),
  CONSTRAINT payslip_item_inputs_code_check CHECK (btrim(item_code) <> '' AND item_code = btrim(item_code) AND item_code = upper(item_code) AND item_code ~ '^[A-Z0-9_]+$'),
  CONSTRAINT payslip_item_inputs_item_kind_check CHECK (item_kind IN ('earning','deduction','employer_cost')),
  CONSTRAINT payslip_item_inputs_currency_check CHECK (currency = btrim(currency) AND currency = upper(currency)),
  CONSTRAINT payslip_item_inputs_calc_mode_check CHECK (calc_mode IN ('amount','net_guaranteed_iit')),
  CONSTRAINT payslip_item_inputs_tax_bearer_check CHECK (tax_bearer IN ('employee','employer')),
  CONSTRAINT payslip_item_inputs_amount_positive_check CHECK (amount > 0),
  CONSTRAINT payslip_item_inputs_net_guaranteed_contract_check CHECK (
    calc_mode <> 'net_guaranteed_iit'
    OR (
      item_kind = 'earning'
      AND tax_bearer = 'employer'
      AND currency = 'CNY'
    )
  ),
  CONSTRAINT payslip_item_inputs_natural_unique UNIQUE (tenant_id, run_id, person_uuid, assignment_id, item_code),
  CONSTRAINT payslip_item_inputs_run_fk FOREIGN KEY (tenant_id, run_id) REFERENCES staffing.payroll_runs(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS payslip_item_inputs_by_run_person_btree
  ON staffing.payslip_item_inputs (tenant_id, run_id, person_uuid, assignment_id, item_code);

ALTER TABLE staffing.payslip_items
  ADD COLUMN IF NOT EXISTS calc_mode text NOT NULL DEFAULT 'amount',
  ADD COLUMN IF NOT EXISTS tax_bearer text NOT NULL DEFAULT 'employee',
  ADD COLUMN IF NOT EXISTS target_net numeric(15,2) NULL,
  ADD COLUMN IF NOT EXISTS iit_delta numeric(15,2) NULL;

ALTER TABLE staffing.payslip_items
  DROP CONSTRAINT IF EXISTS payslip_items_calc_mode_check,
  DROP CONSTRAINT IF EXISTS payslip_items_tax_bearer_check,
  DROP CONSTRAINT IF EXISTS payslip_items_iit_delta_nonneg_check,
  DROP CONSTRAINT IF EXISTS payslip_items_target_net_positive_check,
  DROP CONSTRAINT IF EXISTS payslip_items_net_guaranteed_contract_check;

ALTER TABLE staffing.payslip_items
  ADD CONSTRAINT payslip_items_calc_mode_check CHECK (calc_mode IN ('amount','net_guaranteed_iit')),
  ADD CONSTRAINT payslip_items_tax_bearer_check CHECK (tax_bearer IN ('employee','employer')),
  ADD CONSTRAINT payslip_items_iit_delta_nonneg_check CHECK (iit_delta IS NULL OR iit_delta >= 0),
  ADD CONSTRAINT payslip_items_target_net_positive_check CHECK (target_net IS NULL OR target_net > 0),
  ADD CONSTRAINT payslip_items_net_guaranteed_contract_check CHECK (
    calc_mode <> 'net_guaranteed_iit'
    OR (
      tax_bearer = 'employer'
      AND item_kind = 'earning'
      AND target_net IS NOT NULL
      AND iit_delta IS NOT NULL
      AND amount = target_net + iit_delta
    )
  );

ALTER TABLE staffing.payslip_item_input_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payslip_item_input_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payslip_item_input_events;
CREATE POLICY tenant_isolation ON staffing.payslip_item_input_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.payslip_item_inputs ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.payslip_item_inputs FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.payslip_item_inputs;
CREATE POLICY tenant_isolation ON staffing.payslip_item_inputs
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/staffing/infrastructure/persistence/schema/00013_staffing_payroll_item_inputs.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00014_staffing_payroll_item_inputs_engine.sql
CREATE OR REPLACE FUNCTION staffing.submit_payslip_item_input_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_run_id uuid,
  p_person_uuid uuid,
  p_assignment_id uuid,
  p_event_type text,
  p_item_code text,
  p_item_kind text,
  p_currency char(3),
  p_calc_mode text,
  p_tax_bearer text,
  p_amount numeric(15,2),
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing_event staffing.payslip_item_input_events%ROWTYPE;
  v_run staffing.payroll_runs%ROWTYPE;
  v_existing_input staffing.payslip_item_inputs%ROWTYPE;

  v_now timestamptz;

  v_item_code text;
  v_item_kind text;
  v_currency char(3);
  v_calc_mode text;
  v_tax_bearer text;
  v_amount numeric(15,2);

  v_currency_trim text;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_run_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'run_id is required';
  END IF;
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_assignment_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'assignment_id is required';
  END IF;
  IF p_event_type IS NULL OR p_event_type NOT IN ('UPSERT','DELETE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_item_code := COALESCE(p_item_code, '');
  IF btrim(v_item_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'item_code is required';
  END IF;
  IF v_item_code <> btrim(v_item_code) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'item_code must be trimmed';
  END IF;
  IF v_item_code <> upper(v_item_code) THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'item_code must be upper';
  END IF;
  IF v_item_code !~ '^[A-Z0-9_]+$' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'item_code invalid';
  END IF;

  IF btrim(COALESCE(p_request_id, '')) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_lock_key := format('staffing:payroll-run:%s:%s', p_tenant_id, p_run_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_run
  FROM staffing.payroll_runs
  WHERE tenant_id = p_tenant_id AND id = p_run_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RUN_NOT_FOUND',
      DETAIL = format('run_id=%s', p_run_id);
  END IF;

  IF v_run.run_state = 'finalized' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_RUN_FINALIZED_READONLY',
      DETAIL = format('run_id=%s', p_run_id);
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM staffing.payslips p
    WHERE p.tenant_id = p_tenant_id
      AND p.run_id = p_run_id
      AND p.person_uuid = p_person_uuid
      AND p.assignment_id = p_assignment_id
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
      DETAIL = format('payslip not found: run_id=%s person_uuid=%s assignment_id=%s', p_run_id, p_person_uuid, p_assignment_id);
  END IF;

  v_now := now();

  IF p_event_type = 'DELETE' THEN
    SELECT * INTO v_existing_input
    FROM staffing.payslip_item_inputs i
    WHERE i.tenant_id = p_tenant_id
      AND i.run_id = p_run_id
      AND i.person_uuid = p_person_uuid
      AND i.assignment_id = p_assignment_id
      AND i.item_code = v_item_code;

    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
        DETAIL = format('input not found: run_id=%s person_uuid=%s assignment_id=%s item_code=%s', p_run_id, p_person_uuid, p_assignment_id, v_item_code);
    END IF;

    v_item_kind := v_existing_input.item_kind;
    v_currency := v_existing_input.currency;
    v_calc_mode := v_existing_input.calc_mode;
    v_tax_bearer := v_existing_input.tax_bearer;
    v_amount := v_existing_input.amount;
  ELSE
    IF p_item_kind IS NULL OR p_item_kind NOT IN ('earning','deduction','employer_cost') THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
        DETAIL = format('unsupported item_kind: %s', p_item_kind);
    END IF;

    IF p_calc_mode IS NULL OR p_calc_mode NOT IN ('amount','net_guaranteed_iit') THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
        DETAIL = format('unsupported calc_mode: %s', p_calc_mode);
    END IF;

    IF p_tax_bearer IS NULL OR p_tax_bearer NOT IN ('employee','employer') THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
        DETAIL = format('unsupported tax_bearer: %s', p_tax_bearer);
    END IF;

    IF p_currency IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
        DETAIL = 'currency is required';
    END IF;

    v_currency_trim := btrim(p_currency::text);
    IF v_currency_trim = '' THEN
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'currency is required';
    END IF;
    IF v_currency_trim <> upper(v_currency_trim) THEN
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'currency must be upper';
    END IF;
    IF length(v_currency_trim) <> 3 THEN
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'currency must be 3 letters';
    END IF;

    IF p_amount IS NULL OR p_amount <= 0 THEN
      RAISE EXCEPTION USING MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT', DETAIL = 'amount must be > 0';
    END IF;

    IF p_calc_mode = 'net_guaranteed_iit' THEN
      IF v_currency_trim <> 'CNY' THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_CURRENCY_MISMATCH',
          DETAIL = format('currency=%s', v_currency_trim);
      END IF;
      IF p_tax_bearer <> 'employer' THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
          DETAIL = format('tax_bearer must be employer, got=%s', p_tax_bearer);
      END IF;
      IF p_item_kind <> 'earning' THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_PAYROLL_NET_GUARANTEED_IIT_INVALID_ARGUMENT',
          DETAIL = format('item_kind must be earning, got=%s', p_item_kind);
      END IF;
    END IF;

    v_item_kind := p_item_kind;
    v_currency := p_currency;
    v_calc_mode := p_calc_mode;
    v_tax_bearer := p_tax_bearer;
    v_amount := p_amount;
  END IF;

  INSERT INTO staffing.payslip_item_input_events (
    event_id,
    tenant_id,
    run_id,
    person_uuid,
    assignment_id,
    event_type,
    item_code,
    item_kind,
    currency,
    calc_mode,
    tax_bearer,
    amount,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_run_id,
    p_person_uuid,
    p_assignment_id,
    p_event_type,
    v_item_code,
    v_item_kind,
    v_currency,
    v_calc_mode,
    v_tax_bearer,
    v_amount,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing_event
    FROM staffing.payslip_item_input_events
    WHERE event_id = p_event_id;

    IF v_existing_event.tenant_id <> p_tenant_id
      OR v_existing_event.run_id <> p_run_id
      OR v_existing_event.person_uuid <> p_person_uuid
      OR v_existing_event.assignment_id <> p_assignment_id
      OR v_existing_event.event_type <> p_event_type
      OR v_existing_event.item_code <> v_item_code
      OR v_existing_event.item_kind <> v_item_kind
      OR v_existing_event.currency <> v_currency
      OR v_existing_event.calc_mode <> v_calc_mode
      OR v_existing_event.tax_bearer <> v_tax_bearer
      OR v_existing_event.amount <> v_amount
      OR v_existing_event.request_id <> p_request_id
      OR v_existing_event.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing_event.id);
    END IF;

    RETURN v_existing_event.id;
  END IF;

  IF p_event_type = 'UPSERT' THEN
    INSERT INTO staffing.payslip_item_inputs (
      tenant_id,
      run_id,
      person_uuid,
      assignment_id,
      item_code,
      item_kind,
      currency,
      calc_mode,
      tax_bearer,
      amount,
      last_event_id,
      created_at,
      updated_at
    )
    VALUES (
      p_tenant_id,
      p_run_id,
      p_person_uuid,
      p_assignment_id,
      v_item_code,
      v_item_kind,
      v_currency,
      v_calc_mode,
      v_tax_bearer,
      v_amount,
      v_event_db_id,
      v_now,
      v_now
    )
    ON CONFLICT ON CONSTRAINT payslip_item_inputs_natural_unique
    DO UPDATE SET
      item_kind = EXCLUDED.item_kind,
      currency = EXCLUDED.currency,
      calc_mode = EXCLUDED.calc_mode,
      tax_bearer = EXCLUDED.tax_bearer,
      amount = EXCLUDED.amount,
      last_event_id = EXCLUDED.last_event_id,
      updated_at = EXCLUDED.updated_at;
  ELSE
    DELETE FROM staffing.payslip_item_inputs
    WHERE tenant_id = p_tenant_id
      AND run_id = p_run_id
      AND person_uuid = p_person_uuid
      AND assignment_id = p_assignment_id
      AND item_code = v_item_code;
  END IF;

  IF v_run.run_state = 'calculated' THEN
    UPDATE staffing.payroll_runs
    SET
      needs_recalc = true,
      updated_at = v_now
    WHERE tenant_id = p_tenant_id AND id = p_run_id;
  END IF;

  RETURN v_event_db_id;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00014_staffing_payroll_item_inputs_engine.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00015_staffing_read.sql
CREATE OR REPLACE FUNCTION staffing.get_position_snapshot(
  p_tenant_id uuid,
  p_query_date date
)
RETURNS TABLE (
  position_id uuid,
  org_unit_id uuid,
  reports_to_position_id uuid,
  business_unit_id text,
  jobcatalog_setid text,
  job_profile_id uuid,
  job_profile_code text,
  name text,
  lifecycle_status text,
  capacity_fte numeric(9,2),
  effective_date date
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

	  RETURN QUERY
	  SELECT
	    pv.position_id,
	    pv.org_unit_id,
	    pv.reports_to_position_id,
	    pv.business_unit_id,
	    pv.jobcatalog_setid,
	    pv.job_profile_id,
	    jp.code::text AS job_profile_code,
	    pv.name,
	    pv.lifecycle_status,
	    pv.capacity_fte,
	    lower(pv.validity) AS effective_date
	  FROM staffing.position_versions pv
	  LEFT JOIN jobcatalog.job_profiles jp
	    ON jp.tenant_id = pv.tenant_id
   AND jp.setid = pv.jobcatalog_setid
   AND jp.id = pv.job_profile_id
  WHERE pv.tenant_id = p_tenant_id
    AND pv.validity @> p_query_date;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.get_assignment_snapshot(
  p_tenant_id uuid,
  p_person_uuid uuid,
  p_query_date date
)
RETURNS TABLE (
  assignment_id uuid,
  person_uuid uuid,
  position_id uuid,
  status text,
  effective_date date
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'person_uuid is required';
  END IF;
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  RETURN QUERY
  SELECT
    av.assignment_id,
    av.person_uuid,
    av.position_id,
    av.status,
    lower(av.validity) AS effective_date
  FROM staffing.assignment_versions av
  WHERE av.tenant_id = p_tenant_id
    AND av.person_uuid = p_person_uuid
    AND av.validity @> p_query_date;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00015_staffing_read.sql

-- begin: modules/person/infrastructure/persistence/schema/00001_person_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS person;


-- end: modules/person/infrastructure/persistence/schema/00001_person_schema.sql

-- begin: modules/person/infrastructure/persistence/schema/00002_person_persons.sql
CREATE TABLE IF NOT EXISTS person.persons (
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  pernr text NOT NULL,
  display_name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, person_uuid),
  CONSTRAINT persons_pernr_trim_check CHECK (btrim(pernr) = pernr),
  CONSTRAINT persons_pernr_digits_max8_check CHECK (pernr ~ '^[0-9]{1,8}$'),
  CONSTRAINT persons_pernr_canonical_check CHECK (pernr = '0' OR pernr !~ '^0'),
  CONSTRAINT persons_display_name_trim_check CHECK (btrim(display_name) = display_name),
  CONSTRAINT persons_display_name_nonempty_check CHECK (display_name <> ''),
  CONSTRAINT persons_status_check CHECK (status IN ('active','inactive')),
  CONSTRAINT persons_tenant_pernr_unique UNIQUE (tenant_id, pernr)
);

CREATE INDEX IF NOT EXISTS persons_tenant_display_name_idx
  ON person.persons (tenant_id, display_name);

ALTER TABLE person.persons ENABLE ROW LEVEL SECURITY;
ALTER TABLE person.persons FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON person.persons;
CREATE POLICY tenant_isolation ON person.persons
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

CREATE TABLE IF NOT EXISTS person.external_identity_links (
  tenant_id uuid NOT NULL,
  provider text NOT NULL,
  external_user_id text NOT NULL,
  status text NOT NULL DEFAULT 'pending',
  person_uuid uuid NULL,
  first_seen_at timestamptz NOT NULL DEFAULT now(),
  last_seen_at timestamptz NOT NULL DEFAULT now(),
  seen_count int NOT NULL DEFAULT 1,
  last_seen_payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, provider, external_user_id),
  CONSTRAINT external_identity_links_provider_check CHECK (provider IN ('DINGTALK','WECOM')),
  CONSTRAINT external_identity_links_external_user_id_nonempty_check CHECK (btrim(external_user_id) <> ''),
  CONSTRAINT external_identity_links_external_user_id_trim_check CHECK (external_user_id = btrim(external_user_id)),
  CONSTRAINT external_identity_links_status_check CHECK (status IN ('pending','active','disabled','ignored')),
  CONSTRAINT external_identity_links_status_person_uuid_check CHECK (
    (status IN ('pending','ignored') AND person_uuid IS NULL)
    OR (status IN ('active','disabled') AND person_uuid IS NOT NULL)
  ),
  CONSTRAINT external_identity_links_last_seen_payload_is_object_check CHECK (jsonb_typeof(last_seen_payload) = 'object')
);

CREATE INDEX IF NOT EXISTS external_identity_links_lookup_idx
  ON person.external_identity_links (tenant_id, provider, status, last_seen_at DESC);

ALTER TABLE person.external_identity_links ENABLE ROW LEVEL SECURITY;
ALTER TABLE person.external_identity_links FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON person.external_identity_links;
CREATE POLICY tenant_isolation ON person.external_identity_links
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/person/infrastructure/persistence/schema/00002_person_persons.sql

-- begin: modules/person/infrastructure/persistence/schema/00003_person_engine.sql
CREATE OR REPLACE FUNCTION person.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_INVALID_ARGUMENT',
      DETAIL = 'tenant_id is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_id THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION person.normalize_pernr(p_pernr text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v text;
BEGIN
  IF p_pernr IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_PERNR_INVALID',
      DETAIL = 'pernr is required';
  END IF;

  v := btrim(p_pernr);
  IF v = '' OR v !~ '^[0-9]{1,8}$' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_PERNR_INVALID',
      DETAIL = format('pernr=%s', v);
  END IF;

  v := regexp_replace(v, '^0+', '');
  IF v = '' THEN
    v := '0';
  END IF;
  RETURN v;
END;
$$;


-- end: modules/person/infrastructure/persistence/schema/00003_person_engine.sql

