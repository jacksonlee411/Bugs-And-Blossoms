-- Code generated by scripts/sqlc/export-schema.sh; DO NOT EDIT.
-- Source: modules/*/infrastructure/persistence/schema/*.sql

-- begin: modules/iam/infrastructure/persistence/schema/00001_iam_baseline.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS iam;

CREATE OR REPLACE FUNCTION public.current_tenant_id()
RETURNS uuid
LANGUAGE sql
STABLE
AS $$
  SELECT current_setting('app.current_tenant')::uuid;
$$;

CREATE OR REPLACE FUNCTION public.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  IF p_tenant_id <> public.current_tenant_id() THEN
    RAISE EXCEPTION 'RLS_TENANT_MISMATCH'
      USING
        ERRCODE = 'P0001',
        DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, public.current_tenant_id());
  END IF;
END;
$$;


-- end: modules/iam/infrastructure/persistence/schema/00001_iam_baseline.sql

-- begin: modules/iam/infrastructure/persistence/schema/00002_iam_tenancy.sql
CREATE TABLE IF NOT EXISTS iam.tenants (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT tenants_name_nonempty_check CHECK (btrim(name) <> '')
);

CREATE TABLE IF NOT EXISTS iam.tenant_domains (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  hostname text NOT NULL,
  is_primary boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT tenant_domains_hostname_nonempty_check CHECK (hostname <> ''),
  CONSTRAINT tenant_domains_hostname_lower_check CHECK (hostname = lower(hostname)),
  CONSTRAINT tenant_domains_hostname_trim_check CHECK (hostname = btrim(hostname)),
  CONSTRAINT tenant_domains_hostname_no_port_check CHECK (position(':' in hostname) = 0)
);

CREATE UNIQUE INDEX IF NOT EXISTS tenant_domains_hostname_unique ON iam.tenant_domains (hostname);
CREATE INDEX IF NOT EXISTS tenant_domains_tenant_idx ON iam.tenant_domains (tenant_id);
CREATE UNIQUE INDEX IF NOT EXISTS tenant_domains_primary_unique ON iam.tenant_domains (tenant_id) WHERE is_primary = true;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT USAGE ON SCHEMA iam TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.tenants TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.tenant_domains TO superadmin_runtime';
  END IF;
END
$$;

-- end: modules/iam/infrastructure/persistence/schema/00002_iam_tenancy.sql

-- begin: modules/iam/infrastructure/persistence/schema/00003_iam_superadmin_audit.sql
CREATE TABLE IF NOT EXISTS iam.superadmin_audit_logs (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  actor text NOT NULL,
  action text NOT NULL,
  target_tenant_id uuid NULL REFERENCES iam.tenants(id) ON DELETE SET NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_audit_logs_actor_nonempty_check CHECK (btrim(actor) <> ''),
  CONSTRAINT superadmin_audit_logs_action_nonempty_check CHECK (btrim(action) <> ''),
  CONSTRAINT superadmin_audit_logs_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE UNIQUE INDEX IF NOT EXISTS superadmin_audit_logs_event_id_unique ON iam.superadmin_audit_logs (event_id);
CREATE INDEX IF NOT EXISTS superadmin_audit_logs_target_tenant_idx ON iam.superadmin_audit_logs (target_tenant_id, id);

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT INSERT, SELECT ON iam.superadmin_audit_logs TO superadmin_runtime';
    EXECUTE 'GRANT USAGE, SELECT ON SEQUENCE iam.superadmin_audit_logs_id_seq TO superadmin_runtime';
  END IF;
END
$$;

-- end: modules/iam/infrastructure/persistence/schema/00003_iam_superadmin_audit.sql

-- begin: modules/iam/infrastructure/persistence/schema/00004_iam_principals_and_sessions.sql
CREATE TABLE IF NOT EXISTS iam.principals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  email text NOT NULL,
  role_slug text NOT NULL,
  display_name text NULL,
  status text NOT NULL,
  kratos_identity_id uuid NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT principals_email_nonempty_check CHECK (btrim(email) <> ''),
  CONSTRAINT principals_email_lower_check CHECK (email = lower(email)),
  CONSTRAINT principals_email_trim_check CHECK (email = btrim(email)),
  CONSTRAINT principals_role_slug_nonempty_check CHECK (btrim(role_slug) <> ''),
  CONSTRAINT principals_role_slug_lower_check CHECK (role_slug = lower(role_slug)),
  CONSTRAINT principals_status_check CHECK (status IN ('active', 'disabled'))
);

CREATE UNIQUE INDEX IF NOT EXISTS principals_tenant_email_unique ON iam.principals (tenant_id, email);
CREATE INDEX IF NOT EXISTS principals_tenant_idx ON iam.principals (tenant_id);

CREATE TABLE IF NOT EXISTS iam.sessions (
  token_sha256 bytea PRIMARY KEY,
  tenant_id uuid NOT NULL REFERENCES iam.tenants(id) ON DELETE CASCADE,
  principal_id uuid NOT NULL REFERENCES iam.principals(id) ON DELETE CASCADE,
  expires_at timestamptz NOT NULL,
  revoked_at timestamptz NULL,
  ip text NULL,
  user_agent text NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT sessions_token_sha256_len_check CHECK (octet_length(token_sha256) = 32)
);

CREATE INDEX IF NOT EXISTS sessions_tenant_idx ON iam.sessions (tenant_id);
CREATE INDEX IF NOT EXISTS sessions_principal_idx ON iam.sessions (principal_id);


-- end: modules/iam/infrastructure/persistence/schema/00004_iam_principals_and_sessions.sql

-- begin: modules/iam/infrastructure/persistence/schema/00005_iam_superadmin_principals_and_sessions.sql
CREATE TABLE IF NOT EXISTS iam.superadmin_principals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text NOT NULL UNIQUE,
  display_name text NULL,
  status text NOT NULL,
  kratos_identity_id uuid NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_principals_email_nonempty_check CHECK (btrim(email) <> ''),
  CONSTRAINT superadmin_principals_email_lower_check CHECK (email = lower(email)),
  CONSTRAINT superadmin_principals_email_trim_check CHECK (email = btrim(email)),
  CONSTRAINT superadmin_principals_status_check CHECK (status IN ('active', 'disabled'))
);

CREATE TABLE IF NOT EXISTS iam.superadmin_sessions (
  token_sha256 bytea PRIMARY KEY,
  principal_id uuid NOT NULL REFERENCES iam.superadmin_principals(id) ON DELETE CASCADE,
  expires_at timestamptz NOT NULL,
  revoked_at timestamptz NULL,
  ip text NULL,
  user_agent text NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT superadmin_sessions_token_sha256_len_check CHECK (octet_length(token_sha256) = 32)
);

CREATE INDEX IF NOT EXISTS superadmin_sessions_principal_idx ON iam.superadmin_sessions (principal_id);

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.superadmin_principals TO superadmin_runtime';
    EXECUTE 'GRANT SELECT, INSERT, UPDATE, DELETE ON iam.superadmin_sessions TO superadmin_runtime';
  END IF;
END
$$;


-- end: modules/iam/infrastructure/persistence/schema/00005_iam_superadmin_principals_and_sessions.sql

-- begin: modules/iam/infrastructure/persistence/schema/00006_iam_global_tenant.sql
INSERT INTO iam.tenants (id, name, is_active)
VALUES ('00000000-0000-0000-0000-000000000000', 'GLOBAL', true)
ON CONFLICT (id) DO NOTHING;

-- end: modules/iam/infrastructure/persistence/schema/00006_iam_global_tenant.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00001_orgunit_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS orgunit;

CREATE OR REPLACE FUNCTION orgunit.global_tenant_id()
RETURNS uuid
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT '00000000-0000-0000-0000-000000000000'::uuid;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00001_orgunit_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00002_orgunit_org_schema.sql
CREATE EXTENSION IF NOT EXISTS ltree;
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- org_id -> ltree label (8-digit int)
CREATE OR REPLACE FUNCTION orgunit.org_ltree_label(p_id int)
RETURNS text
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT p_id::text;
$$;

-- ltree path -> int[] (for long name / ancestors join)
CREATE OR REPLACE FUNCTION orgunit.org_path_ids(p_path ltree)
RETURNS int[]
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT array_agg((t.part)::int ORDER BY t.ord)
  FROM unnest(string_to_array(p_path::text, '.')) WITH ORDINALITY AS t(part, ord);
$$;

CREATE TABLE IF NOT EXISTS orgunit.org_trees (
  tenant_uuid uuid NOT NULL,
  hierarchy_type text NOT NULL DEFAULT 'OrgUnit',
  root_org_id int NOT NULL CHECK (root_org_id BETWEEN 10000000 AND 99999999),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, hierarchy_type),
  CONSTRAINT org_trees_hierarchy_type_check CHECK (hierarchy_type IN ('OrgUnit'))
);

CREATE TABLE IF NOT EXISTS orgunit.org_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  hierarchy_type text NOT NULL DEFAULT 'OrgUnit',
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT org_events_hierarchy_type_check CHECK (hierarchy_type IN ('OrgUnit')),
  CONSTRAINT org_events_event_type_check CHECK (event_type IN ('CREATE','MOVE','RENAME','DISABLE','SET_BUSINESS_UNIT')),
  CONSTRAINT org_events_one_per_day_unique UNIQUE (tenant_uuid, hierarchy_type, org_id, effective_date)
);

CREATE UNIQUE INDEX IF NOT EXISTS org_events_event_uuid_unique ON orgunit.org_events (event_uuid);
CREATE INDEX IF NOT EXISTS org_events_tenant_org_effective_idx ON orgunit.org_events (tenant_uuid, org_id, effective_date, id);
CREATE INDEX IF NOT EXISTS org_events_tenant_type_effective_idx ON orgunit.org_events (tenant_uuid, hierarchy_type, effective_date, id);

CREATE TABLE IF NOT EXISTS orgunit.org_unit_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  hierarchy_type text NOT NULL DEFAULT 'OrgUnit',
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  parent_id int NULL CHECK (parent_id BETWEEN 10000000 AND 99999999),
  node_path ltree NOT NULL,
  validity daterange NOT NULL,
  path_ids int[] GENERATED ALWAYS AS (orgunit.org_path_ids(node_path)) STORED,
  name varchar(255) NOT NULL,
  full_name_path text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  is_business_unit boolean NOT NULL DEFAULT false,
  manager_uuid uuid NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.org_events(id),
  CONSTRAINT org_unit_versions_hierarchy_type_check CHECK (hierarchy_type IN ('OrgUnit')),
  CONSTRAINT org_unit_versions_status_check CHECK (status IN ('active','disabled')),
  CONSTRAINT org_unit_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT org_unit_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT org_unit_versions_no_overlap
    EXCLUDE USING gist (
      tenant_uuid gist_uuid_ops WITH =,
      hierarchy_type gist_text_ops WITH =,
      org_id gist_int4_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS org_unit_versions_search_gist
  ON orgunit.org_unit_versions
  USING gist (tenant_uuid gist_uuid_ops, hierarchy_type gist_text_ops, node_path, validity);

CREATE INDEX IF NOT EXISTS org_unit_versions_active_day_gist
  ON orgunit.org_unit_versions
  USING gist (tenant_uuid gist_uuid_ops, hierarchy_type gist_text_ops, validity)
  WHERE status = 'active';

CREATE INDEX IF NOT EXISTS org_unit_versions_lookup_btree
  ON orgunit.org_unit_versions (tenant_uuid, hierarchy_type, org_id, lower(validity));

CREATE INDEX IF NOT EXISTS org_unit_versions_path_ids_gin
  ON orgunit.org_unit_versions
  USING gin (path_ids);

CREATE TABLE IF NOT EXISTS orgunit.org_unit_codes (
  tenant_uuid uuid NOT NULL,
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  org_code text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, org_id),
  CONSTRAINT org_unit_codes_org_code_format CHECK (
    length(org_code) BETWEEN 1 AND 16
    AND org_code = upper(btrim(org_code))
    AND org_code ~ '^[A-Z0-9_-]{1,16}$'
  ),
  CONSTRAINT org_unit_codes_org_code_unique UNIQUE (tenant_uuid, org_code)
);

ALTER TABLE orgunit.org_trees ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_trees FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_trees;
CREATE POLICY tenant_isolation ON orgunit.org_trees
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.org_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_events;
CREATE POLICY tenant_isolation ON orgunit.org_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.org_unit_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_unit_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_unit_versions;
CREATE POLICY tenant_isolation ON orgunit.org_unit_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.org_unit_codes ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_unit_codes FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_unit_codes;
CREATE POLICY tenant_isolation ON orgunit.org_unit_codes
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

-- end: modules/orgunit/infrastructure/persistence/schema/00002_orgunit_org_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00003_orgunit_engine.sql
CREATE OR REPLACE FUNCTION orgunit.assert_current_tenant(p_tenant_uuid uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'tenant_uuid is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_uuid THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_uuid, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.split_org_unit_version_at(
  p_tenant_uuid uuid,
  p_hierarchy_type text,
  p_org_id int,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_row orgunit.org_unit_versions%ROWTYPE;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  SELECT * INTO v_row
  FROM orgunit.org_unit_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND hierarchy_type = p_hierarchy_type
    AND org_id = p_org_id
    AND validity @> p_effective_date
    AND lower(validity) < p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  UPDATE orgunit.org_unit_versions
  SET validity = daterange(lower(validity), p_effective_date, '[)')
  WHERE id = v_row.id;

  INSERT INTO orgunit.org_unit_versions (
    tenant_uuid,
    hierarchy_type,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    full_name_path,
    status,
    is_business_unit,
    manager_uuid,
    last_event_id
  )
  VALUES (
    v_row.tenant_uuid,
    v_row.hierarchy_type,
    v_row.org_id,
    v_row.parent_id,
    v_row.node_path,
    daterange(p_effective_date, upper(v_row.validity), '[)'),
    v_row.name,
    v_row.full_name_path,
    v_row.status,
    v_row.is_business_unit,
    v_row.manager_uuid,
    p_event_db_id
  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_create_logic(
  p_tenant_uuid uuid,
  p_hierarchy_type text,
  p_org_id int,
  p_org_code text,
  p_parent_id int,
  p_effective_date date,
  p_name text,
  p_manager_uuid uuid,
  p_is_business_unit boolean,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_parent_path ltree;
  v_node_path ltree;
  v_root_org_id int;
  v_is_business_unit boolean;
  v_org_code text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_name IS NULL OR btrim(p_name) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'name is required';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid AND hierarchy_type = p_hierarchy_type AND org_id = p_org_id
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_ALREADY_EXISTS', DETAIL = format('org_id=%s', p_org_id);
  END IF;

  IF p_parent_id IS NULL THEN
    SELECT t.root_org_id INTO v_root_org_id
    FROM orgunit.org_trees t
    WHERE t.tenant_uuid = p_tenant_uuid AND t.hierarchy_type = p_hierarchy_type
    FOR UPDATE;

    IF v_root_org_id IS NOT NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_ROOT_ALREADY_EXISTS',
        DETAIL = format('root_org_id=%s', v_root_org_id);
    END IF;

    INSERT INTO orgunit.org_trees (tenant_uuid, hierarchy_type, root_org_id)
    VALUES (p_tenant_uuid, p_hierarchy_type, p_org_id);

    v_node_path := text2ltree(orgunit.org_ltree_label(p_org_id));
    IF p_is_business_unit IS NOT NULL AND p_is_business_unit = false THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_ROOT_BUSINESS_UNIT_REQUIRED',
        DETAIL = format('org_id=%s', p_org_id);
    END IF;
    v_is_business_unit := true;
  ELSE
    SELECT t.root_org_id INTO v_root_org_id
    FROM orgunit.org_trees t
    WHERE t.tenant_uuid = p_tenant_uuid AND t.hierarchy_type = p_hierarchy_type;

    IF v_root_org_id IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_TREE_NOT_INITIALIZED',
        DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
    END IF;

    SELECT v.node_path INTO v_parent_path
    FROM orgunit.org_unit_versions v
    WHERE v.tenant_uuid = p_tenant_uuid
      AND v.hierarchy_type = p_hierarchy_type
      AND v.org_id = p_parent_id
      AND v.status = 'active'
      AND v.validity @> p_effective_date
    LIMIT 1;

    IF v_parent_path IS NULL THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_PARENT_NOT_FOUND_AS_OF',
        DETAIL = format('parent_id=%s as_of=%s', p_parent_id, p_effective_date);
    END IF;

    v_node_path := v_parent_path || text2ltree(orgunit.org_ltree_label(p_org_id));
    v_is_business_unit := COALESCE(p_is_business_unit, false);
  END IF;

  v_org_code := NULLIF(btrim(p_org_code), '');
  IF v_org_code IS NOT NULL THEN
    v_org_code := upper(v_org_code);
    INSERT INTO orgunit.org_unit_codes (tenant_uuid, org_id, org_code)
    VALUES (p_tenant_uuid, p_org_id, v_org_code);
  END IF;

  INSERT INTO orgunit.org_unit_versions (
    tenant_uuid,
    hierarchy_type,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    full_name_path,
    status,
    is_business_unit,
    manager_uuid,
    last_event_id
  )
  VALUES (
    p_tenant_uuid,
	    p_hierarchy_type,
	    p_org_id,
	    p_parent_id,
    v_node_path,
    daterange(p_effective_date, NULL, '[)'),
    p_name,
    p_name,
    'active',
    v_is_business_unit,
    p_manager_uuid,
    p_event_db_id
  );
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_move_logic(
  p_tenant_uuid uuid,
  p_hierarchy_type text,
  p_org_id int,
  p_new_parent_id int,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_root_org_id int;
  v_old_path ltree;
  v_new_parent_path ltree;
  v_new_prefix ltree;
  v_old_level int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_new_parent_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'new_parent_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid AND t.hierarchy_type = p_hierarchy_type;

  IF v_root_org_id IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_TREE_NOT_INITIALIZED',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;
  IF v_root_org_id = p_org_id THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ROOT_CANNOT_BE_MOVED',
      DETAIL = format('root_org_id=%s', v_root_org_id);
  END IF;

  SELECT v.node_path INTO v_old_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = p_hierarchy_type
    AND v.org_id = p_org_id
    AND v.status = 'active'
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1
  FOR UPDATE;

  IF v_old_path IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  SELECT v.node_path INTO v_new_parent_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = p_hierarchy_type
    AND v.org_id = p_new_parent_id
    AND v.status = 'active'
    AND v.validity @> p_effective_date
  LIMIT 1;

  IF v_new_parent_path IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_PARENT_NOT_FOUND_AS_OF',
      DETAIL = format('parent_id=%s as_of=%s', p_new_parent_id, p_effective_date);
  END IF;

  IF v_new_parent_path <@ v_old_path THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_CYCLE_MOVE',
      DETAIL = format('cycle move: org_id=%s new_parent_id=%s', p_org_id, p_new_parent_id);
  END IF;

  v_new_prefix := v_new_parent_path || text2ltree(orgunit.org_ltree_label(p_org_id));
  v_old_level := nlevel(v_old_path);

  WITH split AS (
    SELECT *
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND hierarchy_type = p_hierarchy_type
      AND node_path <@ v_old_path
      AND validity @> p_effective_date
      AND lower(validity) < p_effective_date
  ),
  upd AS (
    UPDATE orgunit.org_unit_versions v
    SET validity = daterange(lower(v.validity), p_effective_date, '[)')
    FROM split s
    WHERE v.id = s.id
    RETURNING s.*
  )
  INSERT INTO orgunit.org_unit_versions (
    tenant_uuid,
    hierarchy_type,
    org_id,
    parent_id,
    node_path,
    validity,
    name,
    full_name_path,
    status,
    is_business_unit,
    manager_uuid,
    last_event_id
  )
  SELECT
    u.tenant_uuid,
    u.hierarchy_type,
    u.org_id,
    CASE WHEN u.org_id = p_org_id THEN p_new_parent_id ELSE u.parent_id END,
    CASE
      WHEN u.org_id = p_org_id THEN v_new_prefix
      ELSE v_new_prefix || subpath(u.node_path, v_old_level)
    END,
    daterange(p_effective_date, upper(u.validity), '[)'),
    u.name,
    u.full_name_path,
    u.status,
    u.is_business_unit,
    u.manager_uuid,
    p_event_db_id
  FROM upd u;

  UPDATE orgunit.org_unit_versions v
  SET
    node_path = CASE
        WHEN v.org_id = p_org_id THEN v_new_prefix
        ELSE v_new_prefix || subpath(v.node_path, v_old_level)
      END,
    parent_id = CASE WHEN v.org_id = p_org_id THEN p_new_parent_id ELSE v.parent_id END,
    last_event_id = p_event_db_id
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = p_hierarchy_type
    AND v.node_path <@ v_old_path
    AND lower(v.validity) >= p_effective_date;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_rename_logic(
  p_tenant_uuid uuid,
  p_hierarchy_type text,
  p_org_id int,
  p_effective_date date,
  p_new_name text,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_stop_date date;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_new_name IS NULL OR btrim(p_new_name) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'new_name is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND hierarchy_type = p_hierarchy_type
      AND org_id = p_org_id
      AND validity @> p_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_uuid, p_hierarchy_type, p_org_id, p_effective_date, p_event_db_id);

  SELECT MIN(e.effective_date) INTO v_stop_date
  FROM orgunit.org_events e
  WHERE e.tenant_uuid = p_tenant_uuid
    AND e.hierarchy_type = p_hierarchy_type
    AND e.org_id = p_org_id
    AND e.event_type = 'RENAME'
    AND e.effective_date > p_effective_date;

  UPDATE orgunit.org_unit_versions
  SET name = p_new_name, last_event_id = p_event_db_id
  WHERE tenant_uuid = p_tenant_uuid
    AND hierarchy_type = p_hierarchy_type
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date
    AND (v_stop_date IS NULL OR lower(validity) < v_stop_date);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_disable_logic(
  p_tenant_uuid uuid,
  p_hierarchy_type text,
  p_org_id int,
  p_effective_date date,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.org_unit_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND hierarchy_type = p_hierarchy_type
      AND org_id = p_org_id
      AND validity @> p_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_uuid, p_hierarchy_type, p_org_id, p_effective_date, p_event_db_id);

  UPDATE orgunit.org_unit_versions
  SET status = 'disabled', last_event_id = p_event_db_id
  WHERE tenant_uuid = p_tenant_uuid
    AND hierarchy_type = p_hierarchy_type
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.apply_set_business_unit_logic(
  p_tenant_uuid uuid,
  p_hierarchy_type text,
  p_org_id int,
  p_effective_date date,
  p_is_business_unit boolean,
  p_event_db_id bigint
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_stop_date date;
  v_status text;
  v_root_org_id int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_is_business_unit IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'is_business_unit is required';
  END IF;

  SELECT v.status INTO v_status
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = p_hierarchy_type
    AND v.org_id = p_org_id
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_status IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;
  IF v_status <> 'active' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INACTIVE_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid AND t.hierarchy_type = p_hierarchy_type;

  IF v_root_org_id IS NOT NULL AND v_root_org_id = p_org_id AND p_is_business_unit = false THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ROOT_BUSINESS_UNIT_REQUIRED',
      DETAIL = format('org_id=%s', p_org_id);
  END IF;

  PERFORM orgunit.split_org_unit_version_at(p_tenant_uuid, p_hierarchy_type, p_org_id, p_effective_date, p_event_db_id);

  SELECT MIN(e.effective_date) INTO v_stop_date
  FROM orgunit.org_events e
  WHERE e.tenant_uuid = p_tenant_uuid
    AND e.hierarchy_type = p_hierarchy_type
    AND e.org_id = p_org_id
    AND e.event_type = 'SET_BUSINESS_UNIT'
    AND e.effective_date > p_effective_date;

  UPDATE orgunit.org_unit_versions
  SET is_business_unit = p_is_business_unit, last_event_id = p_event_db_id
  WHERE tenant_uuid = p_tenant_uuid
    AND hierarchy_type = p_hierarchy_type
    AND org_id = p_org_id
    AND lower(validity) >= p_effective_date
    AND (v_stop_date IS NULL OR lower(validity) < v_stop_date);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.replay_org_unit_versions(
  p_tenant_uuid uuid,
  p_hierarchy_type text
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event orgunit.org_events%ROWTYPE;
  v_payload jsonb;
  v_parent_id int;
  v_new_parent_id int;
  v_name text;
  v_new_name text;
  v_manager_uuid uuid;
  v_is_business_unit boolean;
  v_org_code text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;

  v_lock_key := format('org:write-lock:%s:%s', p_tenant_uuid, p_hierarchy_type);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM orgunit.org_unit_versions
  WHERE tenant_uuid = p_tenant_uuid AND hierarchy_type = p_hierarchy_type;

  DELETE FROM orgunit.org_trees
  WHERE tenant_uuid = p_tenant_uuid AND hierarchy_type = p_hierarchy_type;

  DELETE FROM orgunit.org_unit_codes
  WHERE tenant_uuid = p_tenant_uuid;

  FOR v_event IN
    SELECT *
    FROM orgunit.org_events
    WHERE tenant_uuid = p_tenant_uuid AND hierarchy_type = p_hierarchy_type
    ORDER BY effective_date, id
  LOOP
    v_payload := COALESCE(v_event.payload, '{}'::jsonb);

    IF v_event.event_type = 'CREATE' THEN
      v_parent_id := NULLIF(v_payload->>'parent_id', '')::int;
      v_name := NULLIF(btrim(v_payload->>'name'), '');
      v_manager_uuid := NULLIF(v_payload->>'manager_uuid', '')::uuid;
      v_org_code := NULLIF(btrim(v_payload->>'org_code'), '');
      v_is_business_unit := NULL;
      IF v_payload ? 'is_business_unit' THEN
        BEGIN
          v_is_business_unit := (v_payload->>'is_business_unit')::boolean;
        EXCEPTION
          WHEN invalid_text_representation THEN
            RAISE EXCEPTION USING
              MESSAGE = 'ORG_INVALID_ARGUMENT',
              DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
        END;
      END IF;
      PERFORM orgunit.apply_create_logic(p_tenant_uuid, p_hierarchy_type, v_event.org_id, v_org_code, v_parent_id, v_event.effective_date, v_name, v_manager_uuid, v_is_business_unit, v_event.id);
    ELSIF v_event.event_type = 'MOVE' THEN
      v_new_parent_id := NULLIF(v_payload->>'new_parent_id', '')::int;
      PERFORM orgunit.apply_move_logic(p_tenant_uuid, p_hierarchy_type, v_event.org_id, v_new_parent_id, v_event.effective_date, v_event.id);
    ELSIF v_event.event_type = 'RENAME' THEN
      v_new_name := NULLIF(btrim(v_payload->>'new_name'), '');
      PERFORM orgunit.apply_rename_logic(p_tenant_uuid, p_hierarchy_type, v_event.org_id, v_event.effective_date, v_new_name, v_event.id);
    ELSIF v_event.event_type = 'DISABLE' THEN
      PERFORM orgunit.apply_disable_logic(p_tenant_uuid, p_hierarchy_type, v_event.org_id, v_event.effective_date, v_event.id);
    ELSIF v_event.event_type = 'SET_BUSINESS_UNIT' THEN
      IF NOT (v_payload ? 'is_business_unit') THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_INVALID_ARGUMENT',
          DETAIL = 'is_business_unit is required';
      END IF;
      BEGIN
        v_is_business_unit := (v_payload->>'is_business_unit')::boolean;
      EXCEPTION
        WHEN invalid_text_representation THEN
          RAISE EXCEPTION USING
            MESSAGE = 'ORG_INVALID_ARGUMENT',
            DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
      END;
      PERFORM orgunit.apply_set_business_unit_logic(p_tenant_uuid, p_hierarchy_type, v_event.org_id, v_event.effective_date, v_is_business_unit, v_event.id);
    ELSE
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_event.event_type);
    END IF;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        org_id,
        validity,
        lag(validity) OVER (PARTITION BY org_id ORDER BY lower(validity)) AS prev_validity
      FROM orgunit.org_unit_versions
      WHERE tenant_uuid = p_tenant_uuid AND hierarchy_type = p_hierarchy_type
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_VALIDITY_GAP',
      DETAIL = 'org_unit_versions must be gapless';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT DISTINCT ON (org_id) org_id, validity
      FROM orgunit.org_unit_versions
      WHERE tenant_uuid = p_tenant_uuid AND hierarchy_type = p_hierarchy_type
      ORDER BY org_id, lower(validity) DESC
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_VALIDITY_NOT_INFINITE',
      DETAIL = 'last version validity must be unbounded (infinity)';
  END IF;

  UPDATE orgunit.org_unit_versions v
  SET full_name_path = (
    SELECT string_agg(a.name, ' / ' ORDER BY t.idx)
    FROM unnest(v.path_ids) WITH ORDINALITY AS t(uid, idx)
    JOIN orgunit.org_unit_versions a
      ON a.tenant_uuid = v.tenant_uuid
     AND a.hierarchy_type = v.hierarchy_type
     AND a.org_id = t.uid
     AND a.validity @> lower(v.validity)
  )
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = 'OrgUnit';
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_org_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_hierarchy_type text,
  p_org_id int,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing orgunit.org_events%ROWTYPE;
  v_payload jsonb;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'event_uuid is required';
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_event_type NOT IN ('CREATE','MOVE','RENAME','DISABLE','SET_BUSINESS_UNIT') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_lock_key := format('org:write-lock:%s:%s', p_tenant_uuid, p_hierarchy_type);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF p_event_type = 'SET_BUSINESS_UNIT' THEN
    IF NOT (v_payload ? 'is_business_unit') THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_INVALID_ARGUMENT',
        DETAIL = 'is_business_unit is required';
    END IF;
    BEGIN
      PERFORM (v_payload->>'is_business_unit')::boolean;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_INVALID_ARGUMENT',
          DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
    END;
  END IF;

  INSERT INTO orgunit.org_events (
    event_uuid,
    tenant_uuid,
    hierarchy_type,
    org_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_hierarchy_type,
    p_org_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (event_uuid) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM orgunit.org_events
    WHERE event_uuid = p_event_uuid;

    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.hierarchy_type <> p_hierarchy_type
      OR v_existing.org_id <> p_org_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM orgunit.replay_org_unit_versions(p_tenant_uuid, p_hierarchy_type);

  RETURN v_event_db_id;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00003_orgunit_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00004_orgunit_read.sql
CREATE OR REPLACE FUNCTION orgunit.get_org_snapshot(p_tenant_uuid uuid, p_query_date date)
RETURNS TABLE (
  org_id int,
  parent_id int,
  name varchar(255),
  is_business_unit boolean,
  full_name_path text,
  depth int,
  manager_uuid uuid,
  node_path ltree
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  RETURN QUERY
  SELECT
    v.org_id,
    v.parent_id,
    v.name,
    v.is_business_unit,
    v.full_name_path,
    nlevel(v.node_path) - 1 AS depth,
    v.manager_uuid,
    v.node_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = 'OrgUnit'
    AND v.status = 'active'
    AND v.validity @> p_query_date
  ORDER BY v.node_path;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00004_orgunit_read.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00005_orgunit_setid_schema.sql
CREATE TABLE IF NOT EXISTS orgunit.setid_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  event_type text NOT NULL,
  setid text NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_events_event_type_check CHECK (event_type IN ('BOOTSTRAP','CREATE','RENAME','DISABLE')),
  CONSTRAINT setid_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setid_events_share_forbidden CHECK (setid <> 'SHARE'),
  CONSTRAINT setid_events_request_id_unique UNIQUE (tenant_uuid, request_code)
);

CREATE UNIQUE INDEX IF NOT EXISTS setid_events_event_id_unique ON orgunit.setid_events (event_uuid);
CREATE INDEX IF NOT EXISTS setid_events_tenant_time_idx ON orgunit.setid_events (tenant_uuid, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.setids (
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, setid),
  CONSTRAINT setids_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setids_share_forbidden CHECK (setid <> 'SHARE'),
  CONSTRAINT setids_status_check CHECK (status IN ('active','disabled')),
  CONSTRAINT setids_deflt_active_check CHECK (setid <> 'DEFLT' OR status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.global_setid_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  event_type text NOT NULL,
  setid text NOT NULL DEFAULT 'SHARE',
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT global_setid_events_event_type_check CHECK (event_type IN ('BOOTSTRAP','CREATE','RENAME','DISABLE')),
  CONSTRAINT global_setid_events_setid_check CHECK (setid = 'SHARE'),
  CONSTRAINT global_setid_events_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_setid_events_request_id_unique UNIQUE (tenant_uuid, request_code)
);

CREATE UNIQUE INDEX IF NOT EXISTS global_setid_events_event_id_unique ON orgunit.global_setid_events (event_uuid);
CREATE INDEX IF NOT EXISTS global_setid_events_tenant_time_idx ON orgunit.global_setid_events (tenant_uuid, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.global_setids (
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  setid text NOT NULL DEFAULT 'SHARE',
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  last_event_id bigint NOT NULL REFERENCES orgunit.global_setid_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid, setid),
  CONSTRAINT global_setids_share_only CHECK (setid = 'SHARE'),
  CONSTRAINT global_setids_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_setids_status_check CHECK (status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.setid_binding_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_binding_events_event_type_check CHECK (event_type IN ('BIND')),
  CONSTRAINT setid_binding_events_event_id_unique UNIQUE (event_uuid),
  CONSTRAINT setid_binding_events_request_id_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT setid_binding_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS setid_binding_events_tenant_effective_idx ON orgunit.setid_binding_events (tenant_uuid, org_id, effective_date, id);

CREATE TABLE IF NOT EXISTS orgunit.setid_binding_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  org_id int NOT NULL CHECK (org_id BETWEEN 10000000 AND 99999999),
  setid text NOT NULL,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_binding_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_binding_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setid_binding_setid_fk FOREIGN KEY (tenant_uuid, setid) REFERENCES orgunit.setids (tenant_uuid, setid),
  CONSTRAINT setid_binding_no_share CHECK (setid <> 'SHARE'),
  CONSTRAINT setid_binding_validity_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT setid_binding_no_overlap EXCLUDE USING gist (
    tenant_uuid WITH =,
    org_id gist_int4_ops WITH =,
    validity WITH &&
  )
);

ALTER TABLE orgunit.setid_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_events;
CREATE POLICY tenant_isolation ON orgunit.setid_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setids ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setids FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setids;
CREATE POLICY tenant_isolation ON orgunit.setids
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_binding_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_binding_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_binding_events;
CREATE POLICY tenant_isolation ON orgunit.setid_binding_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_binding_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_binding_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_binding_versions;
CREATE POLICY tenant_isolation ON orgunit.setid_binding_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.global_setid_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setid_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setid_events;
CREATE POLICY share_scope ON orgunit.global_setid_events
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

ALTER TABLE orgunit.global_setids ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setids FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setids;
CREATE POLICY share_scope ON orgunit.global_setids
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

-- end: modules/orgunit/infrastructure/persistence/schema/00005_orgunit_setid_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00006_orgunit_setid_engine.sql
CREATE OR REPLACE FUNCTION orgunit.normalize_setid(p_setid text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v text;
BEGIN
  IF p_setid IS NULL OR btrim(p_setid) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_FORMAT',
      DETAIL = 'setid is required';
  END IF;

  v := upper(btrim(p_setid));
  IF v !~ '^[A-Z0-9]{5}$' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_FORMAT',
      DETAIL = format('setid=%s', v);
  END IF;

  RETURN v;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.lock_setid_governance(p_tenant_uuid uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  k bigint;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  k := hashtextextended('orgunit.setid.governance:' || p_tenant_uuid::text, 0);
  PERFORM pg_advisory_xact_lock(k);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.assert_actor_scope_saas()
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_scope text;
BEGIN
  v_scope := current_setting('app.current_actor_scope', true);
  IF v_scope IS NULL OR btrim(v_scope) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ACTOR_SCOPE_FORBIDDEN',
      DETAIL = 'app.current_actor_scope is required';
  END IF;
  IF v_scope <> 'saas' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ACTOR_SCOPE_FORBIDDEN',
      DETAIL = format('app.current_actor_scope=%s', v_scope);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.ensure_setid_bootstrap(
  p_tenant_uuid uuid,
  p_initiator_uuid uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_evt_id uuid;
  v_evt_db_id bigint;
  v_root_org_id int;
  v_root_valid_from date;
  v_scope_code text;
  v_scope_share_mode text;
  v_package_id uuid;
  v_global_tenant_id uuid;
  v_prev_actor text;
  v_prev_allow_share text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  v_global_tenant_id := orgunit.global_tenant_id();
  v_prev_actor := current_setting('app.current_actor_scope', true);
  v_prev_allow_share := current_setting('app.allow_share_read', true);

  IF NOT EXISTS (
    SELECT 1 FROM orgunit.setids WHERE tenant_uuid = p_tenant_uuid AND setid = 'DEFLT'
  ) THEN
    v_evt_id := gen_random_uuid();
    INSERT INTO orgunit.setid_events (event_uuid, tenant_uuid, event_type, setid, payload, request_code, initiator_uuid)
    VALUES (v_evt_id, p_tenant_uuid, 'BOOTSTRAP', 'DEFLT', jsonb_build_object('name', 'Default'), 'bootstrap:deflt', p_initiator_uuid)
    ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

    SELECT id INTO v_evt_db_id
    FROM orgunit.setid_events
    WHERE tenant_uuid = p_tenant_uuid AND request_code = 'bootstrap:deflt'
    ORDER BY id DESC
    LIMIT 1;

    INSERT INTO orgunit.setids (tenant_uuid, setid, name, status, last_event_id)
    VALUES (p_tenant_uuid, 'DEFLT', 'Default', 'active', v_evt_db_id)
    ON CONFLICT (tenant_uuid, setid) DO NOTHING;
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid AND t.hierarchy_type = 'OrgUnit'
  FOR UPDATE;

  IF v_root_org_id IS NULL THEN
    RETURN;
  END IF;

  SELECT lower(v.validity)::date INTO v_root_valid_from
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = 'OrgUnit'
    AND v.org_id = v_root_org_id
    AND v.status = 'active'
    AND v.is_business_unit = true
    AND v.validity @> current_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_root_valid_from IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_NOT_BUSINESS_UNIT_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', v_root_org_id, current_date);
  END IF;

  FOR v_scope_code, v_scope_share_mode IN
    SELECT scope_code, share_mode
    FROM orgunit.scope_code_registry()
    WHERE is_stable = true
  LOOP
    IF v_scope_share_mode = 'shared-only' THEN
      PERFORM set_config('app.current_actor_scope', 'saas', true);
      PERFORM set_config('app.current_tenant', v_global_tenant_id::text, true);
      PERFORM set_config('app.allow_share_read', 'on', true);

      SELECT p.package_id INTO v_package_id
      FROM orgunit.global_setid_scope_packages p
      WHERE p.tenant_uuid = v_global_tenant_id
        AND p.scope_code = v_scope_code
        AND p.package_code = 'DEFLT';

      IF v_package_id IS NULL THEN
        v_package_id := gen_random_uuid();
        PERFORM orgunit.submit_global_scope_package_event(
          gen_random_uuid(),
          v_global_tenant_id,
          v_scope_code,
          v_package_id,
          'BOOTSTRAP',
          v_root_valid_from,
          jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
          format('bootstrap:global-scope-package:deflt:%s', v_scope_code),
          v_global_tenant_id
        );

        SELECT p.package_id INTO v_package_id
        FROM orgunit.global_setid_scope_packages p
        WHERE p.tenant_uuid = v_global_tenant_id
          AND p.scope_code = v_scope_code
          AND p.package_code = 'DEFLT';
      END IF;

      IF v_package_id IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'SUBSCRIPTION_DEFLT_MISSING',
          DETAIL = format('scope_code=%s', v_scope_code);
      END IF;

      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.global_setid_scope_package_versions v
        WHERE v.tenant_uuid = v_global_tenant_id
          AND v.scope_code = v_scope_code
          AND v.package_id = v_package_id
          AND v.status = 'active'
          AND v.validity @> v_root_valid_from
      ) THEN
        PERFORM orgunit.submit_global_scope_package_event(
          gen_random_uuid(),
          v_global_tenant_id,
          v_scope_code,
          v_package_id,
          'BOOTSTRAP',
          v_root_valid_from,
          jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
          format('bootstrap:global-scope-package:deflt:%s:%s', v_scope_code, v_root_valid_from),
          v_global_tenant_id
        );
      END IF;

      PERFORM set_config('app.current_tenant', p_tenant_uuid::text, true);
      PERFORM set_config('app.allow_share_read', COALESCE(v_prev_allow_share, 'off'), true);

      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.setid_scope_subscriptions s
        WHERE s.tenant_uuid = p_tenant_uuid
          AND s.setid = 'DEFLT'
          AND s.scope_code = v_scope_code
          AND s.validity @> v_root_valid_from
      ) THEN
        PERFORM orgunit.submit_scope_subscription_event(
          gen_random_uuid(),
          p_tenant_uuid,
          'DEFLT',
          v_scope_code,
          v_package_id,
          v_global_tenant_id,
          'BOOTSTRAP',
          v_root_valid_from,
          format('bootstrap:scope-subscription:deflt:%s', v_scope_code),
          p_initiator_uuid
        );
      END IF;

      CONTINUE;
    END IF;

    SELECT p.package_id INTO v_package_id
    FROM orgunit.setid_scope_packages p
    WHERE p.tenant_uuid = p_tenant_uuid
      AND p.scope_code = v_scope_code
      AND p.package_code = 'DEFLT';

    IF v_package_id IS NULL THEN
      v_package_id := gen_random_uuid();
      PERFORM orgunit.submit_scope_package_event(
        gen_random_uuid(),
        p_tenant_uuid,
        v_scope_code,
        v_package_id,
        'BOOTSTRAP',
        v_root_valid_from,
        jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
        format('bootstrap:scope-package:deflt:%s', v_scope_code),
        p_initiator_uuid
      );

      SELECT p.package_id INTO v_package_id
      FROM orgunit.setid_scope_packages p
      WHERE p.tenant_uuid = p_tenant_uuid
        AND p.scope_code = v_scope_code
        AND p.package_code = 'DEFLT';
    END IF;

    IF v_package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SUBSCRIPTION_DEFLT_MISSING',
        DETAIL = format('scope_code=%s', v_scope_code);
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_package_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.scope_code = v_scope_code
        AND v.package_id = v_package_id
        AND v.status = 'active'
        AND v.validity @> v_root_valid_from
    ) THEN
      PERFORM orgunit.submit_scope_package_event(
        gen_random_uuid(),
        p_tenant_uuid,
        v_scope_code,
        v_package_id,
        'BOOTSTRAP',
        v_root_valid_from,
        jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
        format('bootstrap:scope-package:deflt:%s:%s', v_scope_code, v_root_valid_from),
        p_initiator_uuid
      );
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_subscriptions s
      WHERE s.tenant_uuid = p_tenant_uuid
        AND s.setid = 'DEFLT'
        AND s.scope_code = v_scope_code
        AND s.validity @> v_root_valid_from
    ) THEN
      PERFORM orgunit.submit_scope_subscription_event(
        gen_random_uuid(),
        p_tenant_uuid,
        'DEFLT',
        v_scope_code,
        v_package_id,
        p_tenant_uuid,
        'BOOTSTRAP',
        v_root_valid_from,
        format('bootstrap:scope-subscription:deflt:%s', v_scope_code),
        p_initiator_uuid
      );
    END IF;
  END LOOP;

  PERFORM set_config('app.current_tenant', p_tenant_uuid::text, true);
  PERFORM set_config('app.current_actor_scope', COALESCE(v_prev_actor, ''), true);
  PERFORM set_config('app.allow_share_read', COALESCE(v_prev_allow_share, 'off'), true);

  IF NOT EXISTS (
    SELECT 1
    FROM orgunit.setid_binding_versions
    WHERE tenant_uuid = p_tenant_uuid
      AND org_id = v_root_org_id
      AND validity @> v_root_valid_from
  ) THEN
    PERFORM orgunit.submit_setid_binding_event(
      gen_random_uuid(),
      p_tenant_uuid,
      v_root_org_id,
      v_root_valid_from,
      'DEFLT',
      'bootstrap:binding:deflt',
      p_initiator_uuid
    );
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_setid_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_event_type text,
  p_setid text,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_name text;
  v_scope_code text;
  v_scope_share_mode text;
  v_package_id uuid;
  v_effective_date date;
  v_global_tenant_id uuid;
  v_prev_actor text;
  v_prev_allow_share text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  v_global_tenant_id := orgunit.global_tenant_id();
  v_prev_actor := current_setting('app.current_actor_scope', true);
  v_prev_allow_share := current_setting('app.allow_share_read', true);

  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'event_type is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'SHARE is reserved';
  END IF;

  INSERT INTO orgunit.setid_events (event_uuid, tenant_uuid, event_type, setid, payload, request_code, initiator_uuid)
  VALUES (p_event_uuid, p_tenant_uuid, p_event_type, v_setid, COALESCE(p_payload, '{}'::jsonb), p_request_code, p_initiator_uuid)
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF p_event_type IN ('BOOTSTRAP','CREATE') THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    IF p_event_type = 'CREATE' AND EXISTS (
      SELECT 1 FROM orgunit.setids WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_ALREADY_EXISTS',
        DETAIL = format('setid=%s', v_setid);
    END IF;

    INSERT INTO orgunit.setids (tenant_uuid, setid, name, status, last_event_id)
    VALUES (p_tenant_uuid, v_setid, v_name, 'active', v_evt_db_id)
    ON CONFLICT (tenant_uuid, setid) DO UPDATE
    SET name = EXCLUDED.name,
        status = 'active',
        last_event_id = EXCLUDED.last_event_id,
        updated_at = now();

    v_effective_date := current_date;
    IF p_payload ? 'effective_date' THEN
      v_effective_date := NULLIF(btrim(p_payload->>'effective_date'), '')::date;
    END IF;
    IF v_effective_date IS NULL THEN
      v_effective_date := current_date;
    END IF;

    FOR v_scope_code, v_scope_share_mode IN
      SELECT scope_code, share_mode
      FROM orgunit.scope_code_registry()
      WHERE is_stable = true
    LOOP
      IF v_scope_share_mode = 'shared-only' THEN
        PERFORM set_config('app.current_actor_scope', 'saas', true);
        PERFORM set_config('app.current_tenant', v_global_tenant_id::text, true);
        PERFORM set_config('app.allow_share_read', 'on', true);

        SELECT p.package_id INTO v_package_id
        FROM orgunit.global_setid_scope_packages p
        WHERE p.tenant_uuid = v_global_tenant_id
          AND p.scope_code = v_scope_code
          AND p.package_code = 'DEFLT';

        IF v_package_id IS NULL THEN
          v_package_id := gen_random_uuid();
          PERFORM orgunit.submit_global_scope_package_event(
            gen_random_uuid(),
            v_global_tenant_id,
            v_scope_code,
            v_package_id,
            'BOOTSTRAP',
            v_effective_date,
            jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
            format('bootstrap:global-scope-package:deflt:%s', v_scope_code),
            v_global_tenant_id
          );

          SELECT p.package_id INTO v_package_id
          FROM orgunit.global_setid_scope_packages p
          WHERE p.tenant_uuid = v_global_tenant_id
            AND p.scope_code = v_scope_code
            AND p.package_code = 'DEFLT';
        END IF;

        IF v_package_id IS NULL THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'SUBSCRIPTION_DEFLT_MISSING',
            DETAIL = format('setid=%s scope_code=%s', v_setid, v_scope_code);
        END IF;

        PERFORM set_config('app.current_tenant', p_tenant_uuid::text, true);
        PERFORM set_config('app.allow_share_read', COALESCE(v_prev_allow_share, 'off'), true);

        IF NOT EXISTS (
          SELECT 1
          FROM orgunit.setid_scope_subscriptions s
          WHERE s.tenant_uuid = p_tenant_uuid
            AND s.setid = v_setid
            AND s.scope_code = v_scope_code
            AND s.validity @> v_effective_date
        ) THEN
          PERFORM orgunit.submit_scope_subscription_event(
            gen_random_uuid(),
            p_tenant_uuid,
            v_setid,
            v_scope_code,
            v_package_id,
            v_global_tenant_id,
            'BOOTSTRAP',
            v_effective_date,
            format('bootstrap:scope-subscription:%s:%s', v_setid, v_scope_code),
            p_initiator_uuid
          );
        END IF;

        CONTINUE;
      END IF;

      SELECT p.package_id INTO v_package_id
      FROM orgunit.setid_scope_packages p
      WHERE p.tenant_uuid = p_tenant_uuid
        AND p.scope_code = v_scope_code
        AND p.package_code = 'DEFLT';

      IF v_package_id IS NULL THEN
        v_package_id := gen_random_uuid();
        PERFORM orgunit.submit_scope_package_event(
          gen_random_uuid(),
          p_tenant_uuid,
          v_scope_code,
          v_package_id,
          'BOOTSTRAP',
          v_effective_date,
          jsonb_build_object('package_code', 'DEFLT', 'name', 'Default', 'owner_setid', 'DEFLT'),
          format('bootstrap:scope-package:deflt:%s', v_scope_code),
          p_initiator_uuid
        );

        SELECT p.package_id INTO v_package_id
        FROM orgunit.setid_scope_packages p
        WHERE p.tenant_uuid = p_tenant_uuid
          AND p.scope_code = v_scope_code
          AND p.package_code = 'DEFLT';
      END IF;

      IF v_package_id IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'SUBSCRIPTION_DEFLT_MISSING',
          DETAIL = format('setid=%s scope_code=%s', v_setid, v_scope_code);
      END IF;

      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.setid_scope_subscriptions s
        WHERE s.tenant_uuid = p_tenant_uuid
          AND s.setid = v_setid
          AND s.scope_code = v_scope_code
          AND s.validity @> current_date
      ) THEN
        PERFORM orgunit.submit_scope_subscription_event(
          gen_random_uuid(),
          p_tenant_uuid,
          v_setid,
          v_scope_code,
          v_package_id,
          p_tenant_uuid,
          'BOOTSTRAP',
          v_effective_date,
          format('bootstrap:scope-subscription:%s:%s', v_setid, v_scope_code),
          p_initiator_uuid
        );
      END IF;
    END LOOP;

    PERFORM set_config('app.current_tenant', p_tenant_uuid::text, true);
    PERFORM set_config('app.current_actor_scope', COALESCE(v_prev_actor, ''), true);
    PERFORM set_config('app.allow_share_read', COALESCE(v_prev_allow_share, 'off'), true);
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;
    UPDATE orgunit.setids
    SET name = v_name,
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
  ELSIF p_event_type = 'DISABLE' THEN
    IF v_setid = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_RESERVED_WORD',
        DETAIL = 'DEFLT is reserved';
    END IF;
    IF EXISTS (
      SELECT 1 FROM orgunit.setid_binding_versions
      WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_IN_USE',
        DETAIL = format('setid=%s', v_setid);
    END IF;
    UPDATE orgunit.setids
    SET status = 'disabled',
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_global_setid_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_event_type text,
  p_setid text,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_name text;
BEGIN
  IF p_tenant_uuid <> orgunit.global_tenant_id() THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ACTOR_SCOPE_FORBIDDEN',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;

  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.assert_actor_scope_saas();

  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_event_type IS NULL OR btrim(p_event_type) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'event_type is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid <> 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'only SHARE is allowed';
  END IF;

  INSERT INTO orgunit.global_setid_events (event_uuid, tenant_uuid, event_type, setid, payload, request_code, initiator_uuid)
  VALUES (p_event_uuid, p_tenant_uuid, p_event_type, v_setid, COALESCE(p_payload, '{}'::jsonb), p_request_code, p_initiator_uuid)
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.global_setid_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF p_event_type IN ('BOOTSTRAP','CREATE') THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    INSERT INTO orgunit.global_setids (tenant_uuid, setid, name, status, last_event_id)
    VALUES (p_tenant_uuid, v_setid, v_name, 'active', v_evt_db_id)
    ON CONFLICT (tenant_uuid, setid) DO UPDATE
    SET name = EXCLUDED.name,
        status = 'active',
        last_event_id = EXCLUDED.last_event_id,
        updated_at = now();
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(p_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;
    UPDATE orgunit.global_setids
    SET name = v_name,
        last_event_id = v_evt_db_id,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;
    IF NOT FOUND THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_setid);
    END IF;
  ELSIF p_event_type = 'DISABLE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'SHARE cannot be disabled';
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_setid_binding_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_org_id int,
  p_effective_date date,
  p_setid text,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_org_status text;
  v_org_is_bu boolean;
  v_existing orgunit.setid_binding_versions%ROWTYPE;
  v_next_start date;
  v_current_end date;
  v_root_org_id int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'request_code is required';
  END IF;
  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'org_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_SHARE_FORBIDDEN',
      DETAIL = 'SHARE is reserved';
  END IF;

  SELECT status INTO v_org_status
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = 'OrgUnit'
    AND v.org_id = p_org_id
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_org_status IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;
  IF v_org_status <> 'active' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INACTIVE_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  SELECT is_business_unit INTO v_org_is_bu
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = 'OrgUnit'
    AND v.org_id = p_org_id
    AND v.validity @> p_effective_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_org_is_bu IS DISTINCT FROM true THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_NOT_BUSINESS_UNIT_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_effective_date);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM orgunit.setids WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_NOT_FOUND',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  IF EXISTS (
    SELECT 1 FROM orgunit.setids WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid AND status <> 'active'
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_DISABLED',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  SELECT t.root_org_id INTO v_root_org_id
  FROM orgunit.org_trees t
  WHERE t.tenant_uuid = p_tenant_uuid AND t.hierarchy_type = 'OrgUnit';

  IF v_root_org_id IS NOT NULL AND v_root_org_id = p_org_id AND v_setid <> 'DEFLT' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_ROOT_BINDING_FORBIDDEN',
      DETAIL = format('org_id=%s setid=%s', p_org_id, v_setid);
  END IF;

  INSERT INTO orgunit.setid_binding_events (
    event_uuid,
    tenant_uuid,
    org_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_org_id,
    'BIND',
    p_effective_date,
    jsonb_build_object('setid', v_setid),
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_binding_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  SELECT min(lower(validity)) INTO v_next_start
  FROM orgunit.setid_binding_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND lower(validity) > p_effective_date;

  SELECT * INTO v_existing
  FROM orgunit.setid_binding_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND org_id = p_org_id
    AND validity @> p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  BEGIN
    IF FOUND THEN
      v_current_end := upper(v_existing.validity);
      IF lower(v_existing.validity) = p_effective_date THEN
        UPDATE orgunit.setid_binding_versions
        SET setid = v_setid,
            last_event_id = v_evt_db_id,
            updated_at = now()
        WHERE id = v_existing.id;
      ELSE
        UPDATE orgunit.setid_binding_versions
        SET validity = daterange(lower(v_existing.validity), p_effective_date, '[)'),
            updated_at = now()
        WHERE id = v_existing.id;

        INSERT INTO orgunit.setid_binding_versions (
          tenant_uuid,
          org_id,
          setid,
          validity,
          last_event_id
        )
        VALUES (
          p_tenant_uuid,
          p_org_id,
          v_setid,
          daterange(p_effective_date, v_current_end, '[)'),
          v_evt_db_id
        );
      END IF;
    ELSE
      INSERT INTO orgunit.setid_binding_versions (
        tenant_uuid,
        org_id,
        setid,
        validity,
        last_event_id
      )
      VALUES (
        p_tenant_uuid,
        p_org_id,
        v_setid,
        daterange(p_effective_date, v_next_start, '[)'),
        v_evt_db_id
      );
    END IF;
  EXCEPTION
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_BINDING_OVERLAP',
        DETAIL = format('org_id=%s effective_date=%s', p_org_id, p_effective_date);
  END;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.resolve_setid(
  p_tenant_uuid uuid,
  p_org_id int,
  p_as_of_date date
)
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
  v_node_path ltree;
  v_org_status text;
  v_setid text;
  v_setid_status text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_org_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'org_id is required';
  END IF;
  IF p_as_of_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'as_of_date is required';
  END IF;

  SELECT v.status, v.node_path INTO v_org_status, v_node_path
  FROM orgunit.org_unit_versions v
  WHERE v.tenant_uuid = p_tenant_uuid
    AND v.hierarchy_type = 'OrgUnit'
    AND v.org_id = p_org_id
    AND v.validity @> p_as_of_date
  ORDER BY lower(v.validity) DESC
  LIMIT 1;

  IF v_org_status IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_NOT_FOUND_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_as_of_date);
  END IF;
  IF v_org_status <> 'active' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INACTIVE_AS_OF',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_as_of_date);
  END IF;

  SELECT b.setid INTO v_setid
  FROM orgunit.setid_binding_versions b
  JOIN orgunit.org_unit_versions o
    ON o.tenant_uuid = b.tenant_uuid
   AND o.hierarchy_type = 'OrgUnit'
   AND o.org_id = b.org_id
  WHERE b.tenant_uuid = p_tenant_uuid
    AND b.validity @> p_as_of_date
    AND o.validity @> p_as_of_date
    AND o.status = 'active'
    AND o.is_business_unit = true
    AND o.node_path @> v_node_path
  ORDER BY nlevel(o.node_path) DESC
  LIMIT 1;

  IF v_setid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_BINDING_MISSING',
      DETAIL = format('org_id=%s as_of=%s', p_org_id, p_as_of_date);
  END IF;

  SELECT status INTO v_setid_status
  FROM orgunit.setids
  WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;

  IF v_setid_status IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_NOT_FOUND',
      DETAIL = format('setid=%s', v_setid);
  END IF;
  IF v_setid_status <> 'active' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_DISABLED',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  RETURN v_setid;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00006_orgunit_setid_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00007_orgunit_setid_kernel_privileges.sql
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'orgunit_kernel') THEN
    CREATE ROLE orgunit_kernel NOLOGIN NOBYPASSRLS;
  END IF;
END $$;

GRANT USAGE ON SCHEMA orgunit TO orgunit_kernel;

GRANT SELECT, INSERT, UPDATE ON TABLE
  orgunit.setid_events,
  orgunit.setids,
  orgunit.setid_binding_events,
  orgunit.setid_binding_versions,
  orgunit.global_setid_events,
  orgunit.global_setids,
  orgunit.org_unit_versions,
  orgunit.org_trees
TO orgunit_kernel;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA orgunit TO orgunit_kernel;

ALTER FUNCTION orgunit.submit_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.submit_global_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_global_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_global_setid_event(uuid, uuid, text, text, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.submit_setid_binding_event(uuid, uuid, int, date, text, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_setid_binding_event(uuid, uuid, int, date, text, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_setid_binding_event(uuid, uuid, int, date, text, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.ensure_setid_bootstrap(uuid, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.ensure_setid_bootstrap(uuid, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.ensure_setid_bootstrap(uuid, uuid)
  SET search_path = pg_catalog, orgunit;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_events, ' ||
      'orgunit.setids, ' ||
      'orgunit.setid_binding_events, ' ||
      'orgunit.setid_binding_versions, ' ||
      'orgunit.global_setid_events, ' ||
      'orgunit.global_setids ' ||
      'FROM app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_nobypassrls') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_events, ' ||
      'orgunit.setids, ' ||
      'orgunit.setid_binding_events, ' ||
      'orgunit.setid_binding_versions, ' ||
      'orgunit.global_setid_events, ' ||
      'orgunit.global_setids ' ||
      'FROM app_nobypassrls';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_events, ' ||
      'orgunit.setids, ' ||
      'orgunit.setid_binding_events, ' ||
      'orgunit.setid_binding_versions, ' ||
      'orgunit.global_setid_events, ' ||
      'orgunit.global_setids ' ||
      'FROM superadmin_runtime';
  END IF;
END $$;

-- end: modules/orgunit/infrastructure/persistence/schema/00007_orgunit_setid_kernel_privileges.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00008_orgunit_setid_scope_schema.sql
CREATE OR REPLACE FUNCTION orgunit.scope_code_registry()
RETURNS TABLE(scope_code text, owner_module text, share_mode text, is_stable boolean) AS $$
  VALUES
    ('jobcatalog', 'jobcatalog', 'tenant-only', true),
    ('orgunit_geo_admin', 'orgunit', 'shared-only', true),
    ('orgunit_location', 'orgunit', 'shared-only', true),
    ('person_school', 'person', 'shared-only', true),
    ('person_education_type', 'person', 'shared-only', true),
    ('person_credential_type', 'person', 'shared-only', true)
$$ LANGUAGE SQL IMMUTABLE;

CREATE OR REPLACE FUNCTION orgunit.scope_code_is_valid(p_scope_code text)
RETURNS boolean AS $$
  SELECT EXISTS (
    SELECT 1 FROM orgunit.scope_code_registry() WHERE scope_code = p_scope_code
  );
$$ LANGUAGE SQL IMMUTABLE;

CREATE OR REPLACE FUNCTION orgunit.scope_code_share_mode(p_scope_code text)
RETURNS text AS $$
  SELECT share_mode FROM orgunit.scope_code_registry() WHERE scope_code = p_scope_code
$$ LANGUAGE SQL IMMUTABLE;

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_packages (
  tenant_uuid uuid NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_code text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_scope_packages_pk PRIMARY KEY (tenant_uuid, package_id),
  CONSTRAINT setid_scope_packages_code_unique UNIQUE (tenant_uuid, scope_code, package_code),
  CONSTRAINT setid_scope_packages_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_packages_code_check CHECK (package_code ~ '^[A-Z0-9_]{1,16}$'),
  CONSTRAINT setid_scope_packages_status_check CHECK (status IN ('active', 'disabled')),
  CONSTRAINT setid_scope_packages_deflt_active_check CHECK (package_code <> 'DEFLT' OR status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.global_setid_scope_packages (
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_code text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT global_scope_packages_pk PRIMARY KEY (tenant_uuid, package_id),
  CONSTRAINT global_scope_packages_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_scope_packages_code_unique UNIQUE (tenant_uuid, scope_code, package_code),
  CONSTRAINT global_scope_packages_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT global_scope_packages_code_check CHECK (package_code ~ '^[A-Z0-9_]{1,16}$'),
  CONSTRAINT global_scope_packages_status_check CHECK (status IN ('active', 'disabled')),
  CONSTRAINT global_scope_packages_deflt_active_check CHECK (package_code <> 'DEFLT' OR status = 'active')
);

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_package_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_scope_package_events_event_id_unique UNIQUE (event_uuid),
  CONSTRAINT setid_scope_package_events_request_id_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT setid_scope_package_events_event_type_check CHECK (event_type IN ('BOOTSTRAP', 'CREATE', 'RENAME', 'DISABLE')),
  CONSTRAINT setid_scope_package_events_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_package_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS setid_scope_package_events_tenant_time_idx
  ON orgunit.setid_scope_package_events (tenant_uuid, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.global_setid_scope_package_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT global_scope_package_events_event_id_unique UNIQUE (event_uuid),
  CONSTRAINT global_scope_package_events_request_id_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT global_scope_package_events_event_type_check CHECK (event_type IN ('BOOTSTRAP', 'CREATE', 'RENAME', 'DISABLE')),
  CONSTRAINT global_scope_package_events_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_scope_package_events_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT global_scope_package_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS global_scope_package_events_tenant_time_idx
  ON orgunit.global_setid_scope_package_events (tenant_uuid, transaction_time DESC, id DESC);

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_package_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_code text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_scope_package_events(id),
  CONSTRAINT setid_scope_package_versions_pkg_fk FOREIGN KEY (tenant_uuid, package_id)
    REFERENCES orgunit.setid_scope_packages (tenant_uuid, package_id),
  CONSTRAINT setid_scope_package_versions_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_package_versions_code_check CHECK (package_code ~ '^[A-Z0-9_]{1,16}$'),
  CONSTRAINT setid_scope_package_versions_status_check CHECK (status IN ('active', 'disabled')),
  CONSTRAINT setid_scope_package_versions_deflt_active_check CHECK (package_code <> 'DEFLT' OR status = 'active'),
  CONSTRAINT setid_scope_package_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT setid_scope_package_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT setid_scope_package_versions_no_overlap EXCLUDE USING gist (
    tenant_uuid WITH =,
    package_id WITH =,
    validity WITH &&
  )
);

CREATE INDEX IF NOT EXISTS setid_scope_package_versions_lookup_idx
  ON orgunit.setid_scope_package_versions (tenant_uuid, package_id, lower(validity));

CREATE TABLE IF NOT EXISTS orgunit.global_setid_scope_package_versions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL DEFAULT orgunit.global_tenant_id(),
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_code text NOT NULL,
  name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.global_setid_scope_package_events(id),
  CONSTRAINT global_scope_package_versions_pkg_fk FOREIGN KEY (tenant_uuid, package_id)
    REFERENCES orgunit.global_setid_scope_packages (tenant_uuid, package_id),
  CONSTRAINT global_scope_package_versions_tenant_check CHECK (tenant_uuid = orgunit.global_tenant_id()),
  CONSTRAINT global_scope_package_versions_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT global_scope_package_versions_code_check CHECK (package_code ~ '^[A-Z0-9_]{1,16}$'),
  CONSTRAINT global_scope_package_versions_status_check CHECK (status IN ('active', 'disabled')),
  CONSTRAINT global_scope_package_versions_deflt_active_check CHECK (package_code <> 'DEFLT' OR status = 'active'),
  CONSTRAINT global_scope_package_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT global_scope_package_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT global_scope_package_versions_no_overlap EXCLUDE USING gist (
    tenant_uuid WITH =,
    package_id WITH =,
    validity WITH &&
  )
);

CREATE INDEX IF NOT EXISTS global_scope_package_versions_lookup_idx
  ON orgunit.global_setid_scope_package_versions (tenant_uuid, package_id, lower(validity));

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_subscription_events (
  id bigserial PRIMARY KEY,
  event_uuid uuid NOT NULL,
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_owner_tenant_uuid uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_code text NOT NULL,
  initiator_uuid uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_scope_subscription_events_event_id_unique UNIQUE (event_uuid),
  CONSTRAINT setid_scope_subscription_events_request_id_unique UNIQUE (tenant_uuid, request_code),
  CONSTRAINT setid_scope_subscription_events_event_type_check CHECK (event_type IN ('BOOTSTRAP', 'SUBSCRIBE')),
  CONSTRAINT setid_scope_subscription_events_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_subscription_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setid_scope_subscription_events_owner_check CHECK (
    package_owner_tenant_uuid = tenant_uuid OR package_owner_tenant_uuid = orgunit.global_tenant_id()
  ),
  CONSTRAINT setid_scope_subscription_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object')
);

CREATE INDEX IF NOT EXISTS setid_scope_subscription_events_tenant_idx
  ON orgunit.setid_scope_subscription_events (tenant_uuid, setid, scope_code, effective_date, id);

CREATE TABLE IF NOT EXISTS orgunit.setid_scope_subscriptions (
  id bigserial PRIMARY KEY,
  tenant_uuid uuid NOT NULL,
  setid text NOT NULL,
  scope_code text NOT NULL,
  package_id uuid NOT NULL,
  package_owner_tenant_uuid uuid NOT NULL,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES orgunit.setid_scope_subscription_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT setid_scope_subscriptions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT setid_scope_subscriptions_scope_code_check CHECK (orgunit.scope_code_is_valid(scope_code)),
  CONSTRAINT setid_scope_subscriptions_setid_fk FOREIGN KEY (tenant_uuid, setid) REFERENCES orgunit.setids (tenant_uuid, setid),
  CONSTRAINT setid_scope_subscriptions_validity_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT setid_scope_subscriptions_owner_check CHECK (
    package_owner_tenant_uuid = tenant_uuid OR package_owner_tenant_uuid = orgunit.global_tenant_id()
  ),
  CONSTRAINT setid_scope_subscriptions_no_overlap EXCLUDE USING gist (
    tenant_uuid WITH =,
    setid WITH =,
    scope_code WITH =,
    validity WITH &&
  )
);

CREATE INDEX IF NOT EXISTS setid_scope_subscriptions_lookup_idx
  ON orgunit.setid_scope_subscriptions (tenant_uuid, setid, scope_code, lower(validity));

ALTER TABLE orgunit.setid_scope_packages ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_packages FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_packages;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_packages
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_scope_package_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_package_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_package_events;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_package_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_scope_package_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_package_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_package_versions;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_package_versions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_scope_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_subscriptions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_subscriptions;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_subscriptions
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.setid_scope_subscription_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.setid_scope_subscription_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.setid_scope_subscription_events;
CREATE POLICY tenant_isolation ON orgunit.setid_scope_subscription_events
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

ALTER TABLE orgunit.global_setid_scope_packages ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setid_scope_packages FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setid_scope_packages;
CREATE POLICY share_scope ON orgunit.global_setid_scope_packages
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

ALTER TABLE orgunit.global_setid_scope_package_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setid_scope_package_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setid_scope_package_events;
CREATE POLICY share_scope ON orgunit.global_setid_scope_package_events
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

ALTER TABLE orgunit.global_setid_scope_package_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.global_setid_scope_package_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS share_scope ON orgunit.global_setid_scope_package_versions;
CREATE POLICY share_scope ON orgunit.global_setid_scope_package_versions
USING (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.allow_share_read', true) = 'on'
)
WITH CHECK (
  tenant_uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_tenant')::uuid = orgunit.global_tenant_id()
  AND current_setting('app.current_actor_scope', true) = 'saas'
);

-- end: modules/orgunit/infrastructure/persistence/schema/00008_orgunit_setid_scope_schema.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00009_orgunit_setid_scope_engine.sql
CREATE OR REPLACE FUNCTION orgunit.assert_scope_package_active_as_of(
  p_tenant_uuid uuid,
  p_scope_code text,
  p_package_id uuid,
  p_package_owner_tenant_uuid uuid,
  p_as_of_date date
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_scope_mode text;
  v_ctx_tenant text;
  v_allow_share text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_NOT_FOUND';
  END IF;
  IF p_as_of_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'as_of_date is required';
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  v_ctx_tenant := current_setting('app.current_tenant');
  v_allow_share := current_setting('app.allow_share_read', true);

  IF p_package_owner_tenant_uuid = p_tenant_uuid THEN
    IF v_scope_mode = 'shared-only' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
    END IF;
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_packages p
      WHERE p.tenant_uuid = p_tenant_uuid
        AND p.scope_code = p_scope_code
        AND p.package_id = p_package_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_package_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.scope_code = p_scope_code
        AND v.package_id = p_package_id
        AND v.validity @> p_as_of_date
        AND v.status = 'active'
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_INACTIVE_AS_OF';
    END IF;
  ELSIF p_package_owner_tenant_uuid = orgunit.global_tenant_id() THEN
    IF v_scope_mode = 'tenant-only' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
    END IF;
    PERFORM set_config('app.current_tenant', orgunit.global_tenant_id()::text, true);
    PERFORM set_config('app.allow_share_read', 'on', true);
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.global_setid_scope_packages p
      WHERE p.tenant_uuid = orgunit.global_tenant_id()
        AND p.scope_code = p_scope_code
        AND p.package_id = p_package_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.global_setid_scope_package_versions v
      WHERE v.tenant_uuid = orgunit.global_tenant_id()
        AND v.scope_code = p_scope_code
        AND v.package_id = p_package_id
        AND v.validity @> p_as_of_date
        AND v.status = 'active'
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_INACTIVE_AS_OF';
    END IF;
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_OWNER_INVALID';
  END IF;

  PERFORM set_config('app.current_tenant', v_ctx_tenant, true);
  PERFORM set_config('app.allow_share_read', COALESCE(v_allow_share, 'off'), true);
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.resolve_scope_package(
  p_tenant_uuid uuid,
  p_setid text,
  p_scope_code text,
  p_as_of_date date
)
RETURNS TABLE(package_id uuid, package_owner_tenant_uuid uuid)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_setid text;
  v_scope_mode text;
  v_ctx_tenant text;
  v_allow_share text;
  v_package_id uuid;
  v_package_owner_tenant_uuid uuid;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_setid IS NULL OR btrim(p_setid) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_INVALID_ARGUMENT',
      DETAIL = 'setid is required';
  END IF;
  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_as_of_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = 'as_of_date is required';
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'SHARE is reserved';
  END IF;

  SELECT s.package_id, s.package_owner_tenant_uuid
  INTO v_package_id, v_package_owner_tenant_uuid
  FROM orgunit.setid_scope_subscriptions s
  WHERE s.tenant_uuid = p_tenant_uuid
    AND s.setid = v_setid
    AND s.scope_code = p_scope_code
    AND s.validity @> p_as_of_date
  ORDER BY lower(s.validity) DESC
  LIMIT 1;

  IF v_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_MISSING',
      DETAIL = format('setid=%s scope_code=%s as_of=%s', v_setid, p_scope_code, p_as_of_date);
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  v_ctx_tenant := current_setting('app.current_tenant');
  v_allow_share := current_setting('app.allow_share_read', true);

  IF v_package_owner_tenant_uuid = p_tenant_uuid THEN
    IF v_scope_mode = 'shared-only' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
    END IF;
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_package_versions v
      WHERE v.tenant_uuid = p_tenant_uuid
        AND v.scope_code = p_scope_code
        AND v.package_id = v_package_id
        AND v.validity @> p_as_of_date
        AND v.status = 'active'
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_INACTIVE_AS_OF';
    END IF;
  ELSIF v_package_owner_tenant_uuid = orgunit.global_tenant_id() THEN
    IF v_scope_mode = 'tenant-only' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
    END IF;
    PERFORM set_config('app.current_tenant', orgunit.global_tenant_id()::text, true);
    PERFORM set_config('app.allow_share_read', 'on', true);
    IF NOT EXISTS (
      SELECT 1
      FROM orgunit.global_setid_scope_package_versions v
      WHERE v.tenant_uuid = orgunit.global_tenant_id()
        AND v.scope_code = p_scope_code
        AND v.package_id = v_package_id
        AND v.validity @> p_as_of_date
        AND v.status = 'active'
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_INACTIVE_AS_OF';
    END IF;
  ELSE
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_OWNER_INVALID';
  END IF;

  PERFORM set_config('app.current_tenant', v_ctx_tenant, true);
  PERFORM set_config('app.allow_share_read', COALESCE(v_allow_share, 'off'), true);

  package_id := v_package_id;
  package_owner_tenant_uuid := v_package_owner_tenant_uuid;
  RETURN NEXT;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00009_orgunit_setid_scope_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00010_orgunit_setid_scope_kernel_privileges.sql
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'orgunit_kernel') THEN
    CREATE ROLE orgunit_kernel NOLOGIN NOBYPASSRLS;
  END IF;
END $$;

GRANT USAGE ON SCHEMA orgunit TO orgunit_kernel;

GRANT SELECT, INSERT, UPDATE ON TABLE
  orgunit.setid_scope_packages,
  orgunit.setid_scope_package_events,
  orgunit.setid_scope_package_versions,
  orgunit.setid_scope_subscriptions,
  orgunit.setid_scope_subscription_events,
  orgunit.global_setid_scope_packages,
  orgunit.global_setid_scope_package_events,
  orgunit.global_setid_scope_package_versions
TO orgunit_kernel;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA orgunit TO orgunit_kernel;

ALTER FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.resolve_scope_package(uuid, text, text, date)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.resolve_scope_package(uuid, text, text, date)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.resolve_scope_package(uuid, text, text, date)
  SET search_path = pg_catalog, orgunit;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_scope_packages, ' ||
      'orgunit.setid_scope_package_events, ' ||
      'orgunit.setid_scope_package_versions, ' ||
      'orgunit.setid_scope_subscriptions, ' ||
      'orgunit.setid_scope_subscription_events, ' ||
      'orgunit.global_setid_scope_packages, ' ||
      'orgunit.global_setid_scope_package_events, ' ||
      'orgunit.global_setid_scope_package_versions ' ||
      'FROM app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_nobypassrls') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_scope_packages, ' ||
      'orgunit.setid_scope_package_events, ' ||
      'orgunit.setid_scope_package_versions, ' ||
      'orgunit.setid_scope_subscriptions, ' ||
      'orgunit.setid_scope_subscription_events, ' ||
      'orgunit.global_setid_scope_packages, ' ||
      'orgunit.global_setid_scope_package_events, ' ||
      'orgunit.global_setid_scope_package_versions ' ||
      'FROM app_nobypassrls';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE ' ||
      'orgunit.setid_scope_packages, ' ||
      'orgunit.setid_scope_package_events, ' ||
      'orgunit.setid_scope_package_versions, ' ||
      'orgunit.setid_scope_subscriptions, ' ||
      'orgunit.setid_scope_subscription_events, ' ||
      'orgunit.global_setid_scope_packages, ' ||
      'orgunit.global_setid_scope_package_events, ' ||
      'orgunit.global_setid_scope_package_versions ' ||
      'FROM superadmin_runtime';
  END IF;
END $$;

REVOKE ALL ON TABLE orgunit.global_setid_scope_packages FROM PUBLIC;
REVOKE ALL ON TABLE orgunit.global_setid_scope_package_versions FROM PUBLIC;
REVOKE ALL ON TABLE orgunit.global_setid_scope_package_events FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE ALL ON TABLE orgunit.global_setid_scope_packages FROM app_runtime';
    EXECUTE 'REVOKE ALL ON TABLE orgunit.global_setid_scope_package_versions FROM app_runtime';
    EXECUTE 'REVOKE ALL ON TABLE orgunit.global_setid_scope_package_events FROM app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT SELECT ON TABLE orgunit.global_setid_scope_packages TO superadmin_runtime';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.global_setid_scope_package_versions TO superadmin_runtime';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.global_setid_scope_package_events TO superadmin_runtime';
  END IF;
END $$;

REVOKE EXECUTE ON FUNCTION orgunit.resolve_scope_package(uuid, text, text, date) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date) FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.resolve_scope_package(uuid, text, text, date) TO app_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date) TO app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.resolve_scope_package(uuid, text, text, date) TO superadmin_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.assert_scope_package_active_as_of(uuid, text, uuid, uuid, date) TO superadmin_runtime';
  END IF;
END $$;

-- end: modules/orgunit/infrastructure/persistence/schema/00010_orgunit_setid_scope_kernel_privileges.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00011_orgunit_setid_scope_write_engine.sql
CREATE OR REPLACE FUNCTION orgunit.submit_scope_package_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_scope_code text,
  p_package_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_evt_db_id bigint;
  v_payload jsonb;
  v_scope_mode text;
  v_package_code text;
  v_owner_setid text;
  v_name text;
  v_status text;
  v_owner_status text;
  v_existing_pkg orgunit.setid_scope_packages%ROWTYPE;
  v_existing_version orgunit.setid_scope_package_versions%ROWTYPE;
  v_next_start date;
  v_current_end date;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'REQUEST_CODE_REQUIRED';
  END IF;
  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_NOT_FOUND';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('BOOTSTRAP', 'CREATE', 'RENAME', 'DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  IF v_scope_mode = 'shared-only' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  INSERT INTO orgunit.setid_scope_package_events (
    event_uuid,
    tenant_uuid,
    scope_code,
    package_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_scope_code,
    p_package_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_scope_package_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF EXISTS (
    SELECT 1
    FROM orgunit.setid_scope_package_versions
    WHERE last_event_id = v_evt_db_id
  ) THEN
    RETURN v_evt_db_id;
  END IF;

  IF p_event_type IN ('BOOTSTRAP', 'CREATE') THEN
    v_package_code := upper(btrim(COALESCE(v_payload->>'package_code', '')));
    v_owner_setid := NULLIF(btrim(COALESCE(v_payload->>'owner_setid', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');

    IF v_package_code = '' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_INVALID';
    END IF;
    IF v_package_code !~ '^[A-Z0-9_]{1,16}$' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_INVALID';
    END IF;
    IF p_event_type = 'CREATE' AND v_package_code = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_RESERVED';
    END IF;
    IF v_owner_setid IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'owner_setid is required';
    END IF;
    v_owner_setid := orgunit.normalize_setid(v_owner_setid);
    IF v_owner_setid = 'SHARE' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_RESERVED_WORD',
        DETAIL = 'SHARE is reserved';
    END IF;
    SELECT status INTO v_owner_status
    FROM orgunit.setids
    WHERE tenant_uuid = p_tenant_uuid AND setid = v_owner_setid;
    IF v_owner_status IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_NOT_FOUND',
        DETAIL = format('setid=%s', v_owner_setid);
    END IF;
    IF v_owner_status <> 'active' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SETID_DISABLED',
        DETAIL = format('setid=%s', v_owner_setid);
    END IF;
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    IF EXISTS (
      SELECT 1
      FROM orgunit.setid_scope_packages
      WHERE tenant_uuid = p_tenant_uuid
        AND scope_code = p_scope_code
        AND package_code = v_package_code
        AND package_id <> p_package_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_DUPLICATE';
    END IF;

    v_status := 'active';

    INSERT INTO orgunit.setid_scope_packages (
      tenant_uuid,
      scope_code,
      package_id,
      package_code,
      owner_setid,
      name,
      status
    )
    VALUES (
      p_tenant_uuid,
      p_scope_code,
      p_package_id,
      v_package_code,
      v_owner_setid,
      v_name,
      v_status
    )
    ON CONFLICT (tenant_uuid, package_id) DO UPDATE
    SET scope_code = EXCLUDED.scope_code,
        package_code = EXCLUDED.package_code,
        owner_setid = EXCLUDED.owner_setid,
        name = EXCLUDED.name,
        status = EXCLUDED.status,
        updated_at = now();
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    SELECT * INTO v_existing_pkg
    FROM orgunit.setid_scope_packages
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id
    FOR UPDATE;

    IF v_existing_pkg.package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;

    v_package_code := v_existing_pkg.package_code;
    v_owner_setid := v_existing_pkg.owner_setid;
    v_status := v_existing_pkg.status;

    UPDATE orgunit.setid_scope_packages
    SET name = v_name,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id;
  ELSIF p_event_type = 'DISABLE' THEN
    SELECT * INTO v_existing_pkg
    FROM orgunit.setid_scope_packages
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id
    FOR UPDATE;

    IF v_existing_pkg.package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;
    IF v_existing_pkg.package_code = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_DEFLT_FORBIDDEN';
    END IF;

    v_package_code := v_existing_pkg.package_code;
    v_owner_setid := v_existing_pkg.owner_setid;
    v_name := v_existing_pkg.name;
    v_status := 'disabled';

    UPDATE orgunit.setid_scope_packages
    SET status = 'disabled',
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id;
  END IF;

  SELECT min(lower(validity)) INTO v_next_start
  FROM orgunit.setid_scope_package_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND package_id = p_package_id
    AND lower(validity) > p_effective_date;

  SELECT * INTO v_existing_version
  FROM orgunit.setid_scope_package_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND package_id = p_package_id
    AND validity @> p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  BEGIN
    IF FOUND THEN
      v_current_end := upper(v_existing_version.validity);
      IF lower(v_existing_version.validity) = p_effective_date THEN
        UPDATE orgunit.setid_scope_package_versions
        SET scope_code = p_scope_code,
            package_code = v_package_code,
            owner_setid = v_owner_setid,
            name = v_name,
            status = v_status,
            last_event_id = v_evt_db_id
        WHERE id = v_existing_version.id;
      ELSE
        UPDATE orgunit.setid_scope_package_versions
        SET validity = daterange(lower(v_existing_version.validity), p_effective_date, '[)')
        WHERE id = v_existing_version.id;

        INSERT INTO orgunit.setid_scope_package_versions (
          tenant_uuid,
          scope_code,
          package_id,
          package_code,
          owner_setid,
          name,
          status,
          validity,
          last_event_id
        )
        VALUES (
          p_tenant_uuid,
          p_scope_code,
          p_package_id,
          v_package_code,
          v_owner_setid,
          v_name,
          v_status,
          daterange(p_effective_date, v_current_end, '[)'),
          v_evt_db_id
        );
      END IF;
    ELSE
      INSERT INTO orgunit.setid_scope_package_versions (
        tenant_uuid,
        scope_code,
        package_id,
        package_code,
        owner_setid,
        name,
        status,
        validity,
        last_event_id
      )
      VALUES (
        p_tenant_uuid,
        p_scope_code,
        p_package_id,
        v_package_code,
        v_owner_setid,
        v_name,
        v_status,
        daterange(p_effective_date, v_next_start, '[)'),
        v_evt_db_id
      );
    END IF;
  EXCEPTION
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_VERSION_OVERLAP',
        DETAIL = format('package_id=%s effective_date=%s', p_package_id, p_effective_date);
  END;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_global_scope_package_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_scope_code text,
  p_package_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_evt_db_id bigint;
  v_payload jsonb;
  v_scope_mode text;
  v_package_code text;
  v_name text;
  v_status text;
  v_existing_pkg orgunit.global_setid_scope_packages%ROWTYPE;
  v_existing_version orgunit.global_setid_scope_package_versions%ROWTYPE;
  v_next_start date;
  v_current_end date;
BEGIN
  IF p_tenant_uuid <> orgunit.global_tenant_id() THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'ACTOR_SCOPE_FORBIDDEN',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;

  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.assert_actor_scope_saas();

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'REQUEST_CODE_REQUIRED';
  END IF;
  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_NOT_FOUND';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('BOOTSTRAP', 'CREATE', 'RENAME', 'DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  IF v_scope_mode = 'tenant-only' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_SCOPE_MISMATCH';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  INSERT INTO orgunit.global_setid_scope_package_events (
    event_uuid,
    tenant_uuid,
    scope_code,
    package_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_scope_code,
    p_package_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.global_setid_scope_package_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF EXISTS (
    SELECT 1
    FROM orgunit.global_setid_scope_package_versions
    WHERE last_event_id = v_evt_db_id
  ) THEN
    RETURN v_evt_db_id;
  END IF;

  IF p_event_type IN ('BOOTSTRAP', 'CREATE') THEN
    v_package_code := upper(btrim(COALESCE(v_payload->>'package_code', '')));
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');

    IF v_package_code = '' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_INVALID';
    END IF;
    IF v_package_code !~ '^[A-Z0-9_]{1,16}$' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_INVALID';
    END IF;
    IF p_event_type = 'CREATE' AND v_package_code = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_RESERVED';
    END IF;
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    IF EXISTS (
      SELECT 1
      FROM orgunit.global_setid_scope_packages
      WHERE tenant_uuid = p_tenant_uuid
        AND scope_code = p_scope_code
        AND package_code = v_package_code
        AND package_id <> p_package_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_CODE_DUPLICATE';
    END IF;

    v_status := 'active';

    INSERT INTO orgunit.global_setid_scope_packages (
      tenant_uuid,
      scope_code,
      package_id,
      package_code,
      name,
      status
    )
    VALUES (
      p_tenant_uuid,
      p_scope_code,
      p_package_id,
      v_package_code,
      v_name,
      v_status
    )
    ON CONFLICT (tenant_uuid, package_id) DO UPDATE
    SET scope_code = EXCLUDED.scope_code,
        package_code = EXCLUDED.package_code,
        name = EXCLUDED.name,
        status = EXCLUDED.status,
        updated_at = now();
  ELSIF p_event_type = 'RENAME' THEN
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SCOPE_PACKAGE_INVALID_ARGUMENT',
        DETAIL = 'name is required';
    END IF;

    SELECT * INTO v_existing_pkg
    FROM orgunit.global_setid_scope_packages
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id
    FOR UPDATE;

    IF v_existing_pkg.package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;

    v_package_code := v_existing_pkg.package_code;
    v_status := v_existing_pkg.status;

    UPDATE orgunit.global_setid_scope_packages
    SET name = v_name,
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id;
  ELSIF p_event_type = 'DISABLE' THEN
    SELECT * INTO v_existing_pkg
    FROM orgunit.global_setid_scope_packages
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id
    FOR UPDATE;

    IF v_existing_pkg.package_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_NOT_FOUND';
    END IF;
    IF v_existing_pkg.package_code = 'DEFLT' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_DEFLT_FORBIDDEN';
    END IF;

    v_package_code := v_existing_pkg.package_code;
    v_name := v_existing_pkg.name;
    v_status := 'disabled';

    UPDATE orgunit.global_setid_scope_packages
    SET status = 'disabled',
        updated_at = now()
    WHERE tenant_uuid = p_tenant_uuid
      AND package_id = p_package_id;
  END IF;

  SELECT min(lower(validity)) INTO v_next_start
  FROM orgunit.global_setid_scope_package_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND package_id = p_package_id
    AND lower(validity) > p_effective_date;

  SELECT * INTO v_existing_version
  FROM orgunit.global_setid_scope_package_versions
  WHERE tenant_uuid = p_tenant_uuid
    AND package_id = p_package_id
    AND validity @> p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  BEGIN
    IF FOUND THEN
      v_current_end := upper(v_existing_version.validity);
      IF lower(v_existing_version.validity) = p_effective_date THEN
        UPDATE orgunit.global_setid_scope_package_versions
        SET scope_code = p_scope_code,
            package_code = v_package_code,
            name = v_name,
            status = v_status,
            last_event_id = v_evt_db_id
        WHERE id = v_existing_version.id;
      ELSE
        UPDATE orgunit.global_setid_scope_package_versions
        SET validity = daterange(lower(v_existing_version.validity), p_effective_date, '[)')
        WHERE id = v_existing_version.id;

        INSERT INTO orgunit.global_setid_scope_package_versions (
          tenant_uuid,
          scope_code,
          package_id,
          package_code,
          name,
          status,
          validity,
          last_event_id
        )
        VALUES (
          p_tenant_uuid,
          p_scope_code,
          p_package_id,
          v_package_code,
          v_name,
          v_status,
          daterange(p_effective_date, v_current_end, '[)'),
          v_evt_db_id
        );
      END IF;
    ELSE
      INSERT INTO orgunit.global_setid_scope_package_versions (
        tenant_uuid,
        scope_code,
        package_id,
        package_code,
        name,
        status,
        validity,
        last_event_id
      )
      VALUES (
        p_tenant_uuid,
        p_scope_code,
        p_package_id,
        v_package_code,
        v_name,
        v_status,
        daterange(p_effective_date, v_next_start, '[)'),
        v_evt_db_id
      );
    END IF;
  EXCEPTION
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'PACKAGE_VERSION_OVERLAP',
        DETAIL = format('package_id=%s effective_date=%s', p_package_id, p_effective_date);
  END;

  RETURN v_evt_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION orgunit.submit_scope_subscription_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_setid text,
  p_scope_code text,
  p_package_id uuid,
  p_package_owner_tenant_uuid uuid,
  p_event_type text,
  p_effective_date date,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid text;
  v_evt_db_id bigint;
  v_scope_mode text;
  v_existing orgunit.setid_scope_subscriptions%ROWTYPE;
  v_next_start date;
  v_current_end date;
  v_setid_status text;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);
  PERFORM orgunit.lock_setid_governance(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_INVALID_ARGUMENT',
      DETAIL = 'event_uuid is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'REQUEST_CODE_REQUIRED';
  END IF;
  IF p_scope_code IS NULL OR NOT orgunit.scope_code_is_valid(p_scope_code) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_CODE_INVALID';
  END IF;
  IF p_package_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_NOT_FOUND';
  END IF;
  IF p_package_owner_tenant_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_OWNER_INVALID';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_INVALID_ARGUMENT',
      DETAIL = 'initiator_uuid is required';
  END IF;
  IF p_event_type NOT IN ('BOOTSTRAP', 'SUBSCRIBE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SCOPE_SUBSCRIPTION_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := orgunit.normalize_setid(p_setid);
  IF v_setid = 'SHARE' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_RESERVED_WORD',
      DETAIL = 'SHARE is reserved';
  END IF;

  SELECT status INTO v_setid_status
  FROM orgunit.setids
  WHERE tenant_uuid = p_tenant_uuid AND setid = v_setid;

  IF v_setid_status IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_NOT_FOUND',
      DETAIL = format('setid=%s', v_setid);
  END IF;
  IF v_setid_status <> 'active' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'SETID_DISABLED',
      DETAIL = format('setid=%s', v_setid);
  END IF;

  IF p_package_owner_tenant_uuid <> p_tenant_uuid
     AND p_package_owner_tenant_uuid <> orgunit.global_tenant_id() THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PACKAGE_OWNER_INVALID';
  END IF;

  v_scope_mode := orgunit.scope_code_share_mode(p_scope_code);
  IF v_scope_mode = 'shared-only' THEN
    PERFORM orgunit.assert_actor_scope_saas();
  END IF;

  PERFORM orgunit.assert_scope_package_active_as_of(
    p_tenant_uuid,
    p_scope_code,
    p_package_id,
    p_package_owner_tenant_uuid,
    p_effective_date
  );

  INSERT INTO orgunit.setid_scope_subscription_events (
    event_uuid,
    tenant_uuid,
    setid,
    scope_code,
    package_id,
    package_owner_tenant_uuid,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    v_setid,
    p_scope_code,
    p_package_id,
    p_package_owner_tenant_uuid,
    p_event_type,
    p_effective_date,
    '{}'::jsonb,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (tenant_uuid, request_code) DO NOTHING;

  SELECT id INTO v_evt_db_id
  FROM orgunit.setid_scope_subscription_events
  WHERE tenant_uuid = p_tenant_uuid AND request_code = p_request_code
  ORDER BY id DESC
  LIMIT 1;

  IF EXISTS (
    SELECT 1
    FROM orgunit.setid_scope_subscriptions
    WHERE last_event_id = v_evt_db_id
  ) THEN
    RETURN v_evt_db_id;
  END IF;

  SELECT min(lower(validity)) INTO v_next_start
  FROM orgunit.setid_scope_subscriptions
  WHERE tenant_uuid = p_tenant_uuid
    AND setid = v_setid
    AND scope_code = p_scope_code
    AND lower(validity) > p_effective_date;

  SELECT * INTO v_existing
  FROM orgunit.setid_scope_subscriptions
  WHERE tenant_uuid = p_tenant_uuid
    AND setid = v_setid
    AND scope_code = p_scope_code
    AND validity @> p_effective_date
  ORDER BY lower(validity) DESC
  LIMIT 1
  FOR UPDATE;

  BEGIN
    IF FOUND THEN
      v_current_end := upper(v_existing.validity);
      IF lower(v_existing.validity) = p_effective_date THEN
        UPDATE orgunit.setid_scope_subscriptions
        SET package_id = p_package_id,
            package_owner_tenant_uuid = p_package_owner_tenant_uuid,
            last_event_id = v_evt_db_id,
            updated_at = now()
        WHERE id = v_existing.id;
      ELSE
        UPDATE orgunit.setid_scope_subscriptions
        SET validity = daterange(lower(v_existing.validity), p_effective_date, '[)'),
            updated_at = now()
        WHERE id = v_existing.id;

        INSERT INTO orgunit.setid_scope_subscriptions (
          tenant_uuid,
          setid,
          scope_code,
          package_id,
          package_owner_tenant_uuid,
          validity,
          last_event_id
        )
        VALUES (
          p_tenant_uuid,
          v_setid,
          p_scope_code,
          p_package_id,
          p_package_owner_tenant_uuid,
          daterange(p_effective_date, v_current_end, '[)'),
          v_evt_db_id
        );
      END IF;
    ELSE
      INSERT INTO orgunit.setid_scope_subscriptions (
        tenant_uuid,
        setid,
        scope_code,
        package_id,
        package_owner_tenant_uuid,
        validity,
        last_event_id
      )
      VALUES (
        p_tenant_uuid,
        v_setid,
        p_scope_code,
        p_package_id,
        p_package_owner_tenant_uuid,
        daterange(p_effective_date, v_next_start, '[)'),
        v_evt_db_id
      );
    END IF;
  EXCEPTION
    WHEN exclusion_violation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'SUBSCRIPTION_OVERLAP',
        DETAIL = format('setid=%s scope_code=%s effective_date=%s', v_setid, p_scope_code, p_effective_date);
  END;

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00011_orgunit_setid_scope_write_engine.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00012_orgunit_scope_package_owner_setid.sql
ALTER TABLE orgunit.setid_scope_packages
  ADD COLUMN IF NOT EXISTS owner_setid text;

ALTER TABLE orgunit.setid_scope_packages
  ADD CONSTRAINT setid_scope_packages_owner_format_check
    CHECK (owner_setid ~ '^[A-Z0-9]{5}$');

ALTER TABLE orgunit.setid_scope_packages
  ADD CONSTRAINT setid_scope_packages_owner_fk
    FOREIGN KEY (tenant_uuid, owner_setid)
    REFERENCES orgunit.setids (tenant_uuid, setid);

CREATE INDEX IF NOT EXISTS setid_scope_packages_owner_lookup_idx
  ON orgunit.setid_scope_packages (tenant_uuid, scope_code, owner_setid, status);

ALTER TABLE orgunit.setid_scope_package_versions
  ADD COLUMN IF NOT EXISTS owner_setid text;

ALTER TABLE orgunit.setid_scope_package_versions
  ADD CONSTRAINT setid_scope_package_versions_owner_format_check
    CHECK (owner_setid ~ '^[A-Z0-9]{5}$');

ALTER TABLE orgunit.setid_scope_package_versions
  ADD CONSTRAINT setid_scope_package_versions_owner_fk
    FOREIGN KEY (tenant_uuid, owner_setid)
    REFERENCES orgunit.setids (tenant_uuid, setid);

CREATE INDEX IF NOT EXISTS setid_scope_package_versions_owner_lookup_idx
  ON orgunit.setid_scope_package_versions (tenant_uuid, scope_code, owner_setid, lower(validity));

ALTER TABLE orgunit.setid_scope_package_versions
  ADD CONSTRAINT setid_scope_package_versions_owner_scope_no_overlap
  EXCLUDE USING gist (
    tenant_uuid WITH =,
    scope_code gist_text_ops WITH =,
    owner_setid gist_text_ops WITH =,
    validity WITH &&
  )
  WHERE (status = 'active');

-- end: modules/orgunit/infrastructure/persistence/schema/00012_orgunit_scope_package_owner_setid.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00012_orgunit_setid_scope_write_kernel_privileges.sql
ALTER FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit;

ALTER FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid)
  SET search_path = pg_catalog, orgunit;

REVOKE EXECUTE ON FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid) FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) TO app_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) TO app_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid) TO app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) TO superadmin_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_global_scope_package_event(uuid, uuid, text, uuid, text, date, jsonb, text, uuid) TO superadmin_runtime';
    EXECUTE 'GRANT EXECUTE ON FUNCTION orgunit.submit_scope_subscription_event(uuid, uuid, text, text, uuid, uuid, text, date, text, uuid) TO superadmin_runtime';
  END IF;
END $$;

-- end: modules/orgunit/infrastructure/persistence/schema/00012_orgunit_setid_scope_write_kernel_privileges.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00013_orgunit_scope_package_owner_setid_not_null.sql
ALTER TABLE orgunit.setid_scope_packages
  ALTER COLUMN owner_setid SET NOT NULL;

ALTER TABLE orgunit.setid_scope_package_versions
  ALTER COLUMN owner_setid SET NOT NULL;

-- end: modules/orgunit/infrastructure/persistence/schema/00013_orgunit_scope_package_owner_setid_not_null.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00014_orgunit_org_code_kernel_privileges.sql
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'orgunit_kernel') THEN
    CREATE ROLE orgunit_kernel NOLOGIN NOBYPASSRLS;
  END IF;
END $$;

GRANT USAGE ON SCHEMA orgunit TO orgunit_kernel;

ALTER TABLE IF EXISTS orgunit.org_unit_codes OWNER TO orgunit_kernel;

GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE
  orgunit.org_events,
  orgunit.org_unit_versions,
  orgunit.org_trees,
  orgunit.org_unit_codes
TO orgunit_kernel;

ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, text, int, text, date, jsonb, text, uuid)
  OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, text, int, text, date, jsonb, text, uuid)
  SECURITY DEFINER;
ALTER FUNCTION orgunit.submit_org_event(uuid, uuid, text, int, text, date, jsonb, text, uuid)
  SET search_path = pg_catalog, orgunit, public;

REVOKE ALL ON TABLE orgunit.org_unit_codes FROM PUBLIC;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE orgunit.org_unit_codes FROM app';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.org_unit_codes TO app';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE orgunit.org_unit_codes FROM app_runtime';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.org_unit_codes TO app_runtime';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_nobypassrls') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE orgunit.org_unit_codes FROM app_nobypassrls';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.org_unit_codes TO app_nobypassrls';
  END IF;
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'superadmin_runtime') THEN
    EXECUTE 'REVOKE INSERT, UPDATE, DELETE, TRUNCATE ON TABLE orgunit.org_unit_codes FROM superadmin_runtime';
    EXECUTE 'GRANT SELECT ON TABLE orgunit.org_unit_codes TO superadmin_runtime';
  END IF;
END $$;

CREATE OR REPLACE FUNCTION orgunit.guard_org_unit_codes_write()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF current_user <> 'orgunit_kernel' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORGUNIT_CODES_WRITE_FORBIDDEN',
      DETAIL = format('role=%s', current_user);
  END IF;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;

ALTER FUNCTION orgunit.guard_org_unit_codes_write() OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.guard_org_unit_codes_write() SET search_path = pg_catalog, orgunit, public;

DROP TRIGGER IF EXISTS guard_org_unit_codes_write ON orgunit.org_unit_codes;
CREATE TRIGGER guard_org_unit_codes_write
BEFORE INSERT OR UPDATE OR DELETE ON orgunit.org_unit_codes
FOR EACH ROW EXECUTE FUNCTION orgunit.guard_org_unit_codes_write();

-- end: modules/orgunit/infrastructure/persistence/schema/00014_orgunit_org_code_kernel_privileges.sql

-- begin: modules/orgunit/infrastructure/persistence/schema/00015_orgunit_org_id_allocator.sql
CREATE TABLE IF NOT EXISTS orgunit.org_id_allocators (
  tenant_uuid uuid NOT NULL,
  next_org_id int NOT NULL CHECK (next_org_id BETWEEN 10000000 AND 100000000),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_uuid)
);

ALTER TABLE orgunit.org_id_allocators ENABLE ROW LEVEL SECURITY;
ALTER TABLE orgunit.org_id_allocators FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON orgunit.org_id_allocators;
CREATE POLICY tenant_isolation ON orgunit.org_id_allocators
USING (tenant_uuid = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_uuid = current_setting('app.current_tenant')::uuid);

CREATE OR REPLACE FUNCTION orgunit.allocate_org_id(p_tenant_uuid uuid)
RETURNS int
LANGUAGE plpgsql
AS $$
DECLARE
  v_next int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  INSERT INTO orgunit.org_id_allocators (tenant_uuid, next_org_id)
  VALUES (p_tenant_uuid, 10000001)
  ON CONFLICT (tenant_uuid) DO UPDATE
  SET next_org_id = orgunit.org_id_allocators.next_org_id + 1,
      updated_at = now()
  WHERE orgunit.org_id_allocators.next_org_id <= 99999999
  RETURNING next_org_id - 1 INTO v_next;

  IF v_next IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_ID_EXHAUSTED',
      DETAIL = format('tenant_uuid=%s', p_tenant_uuid);
  END IF;

  RETURN v_next;
END;
$$;

ALTER TABLE IF EXISTS orgunit.org_id_allocators OWNER TO orgunit_kernel;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE orgunit.org_id_allocators TO orgunit_kernel;

ALTER FUNCTION orgunit.allocate_org_id(uuid) OWNER TO orgunit_kernel;
ALTER FUNCTION orgunit.allocate_org_id(uuid) SECURITY DEFINER;
ALTER FUNCTION orgunit.allocate_org_id(uuid) SET search_path = pg_catalog, orgunit, public;

CREATE OR REPLACE FUNCTION orgunit.submit_org_event(
  p_event_uuid uuid,
  p_tenant_uuid uuid,
  p_hierarchy_type text,
  p_org_id int,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_code text,
  p_initiator_uuid uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing orgunit.org_events%ROWTYPE;
  v_payload jsonb;
  v_org_id int;
BEGIN
  PERFORM orgunit.assert_current_tenant(p_tenant_uuid);

  IF p_event_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'event_uuid is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_code IS NULL OR btrim(p_request_code) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'request_code is required';
  END IF;
  IF p_initiator_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'initiator_uuid is required';
  END IF;

  IF p_hierarchy_type <> 'OrgUnit' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported hierarchy_type: %s', p_hierarchy_type);
  END IF;
  IF p_event_type NOT IN ('CREATE','MOVE','RENAME','DISABLE','SET_BUSINESS_UNIT') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'ORG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_lock_key := format('org:write-lock:%s:%s', p_tenant_uuid, p_hierarchy_type);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF p_event_type = 'SET_BUSINESS_UNIT' THEN
    IF NOT (v_payload ? 'is_business_unit') THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_INVALID_ARGUMENT',
        DETAIL = 'is_business_unit is required';
    END IF;
    BEGIN
      PERFORM (v_payload->>'is_business_unit')::boolean;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_INVALID_ARGUMENT',
          DETAIL = format('is_business_unit=%s', v_payload->>'is_business_unit');
    END;
  END IF;

  IF p_event_type = 'CREATE' AND p_org_id IS NULL THEN
    SELECT * INTO v_existing
    FROM orgunit.org_events
    WHERE event_uuid = p_event_uuid;

    IF FOUND THEN
      IF v_existing.tenant_uuid <> p_tenant_uuid
        OR v_existing.hierarchy_type <> p_hierarchy_type
        OR v_existing.event_type <> p_event_type
        OR v_existing.effective_date <> p_effective_date
        OR v_existing.payload <> v_payload
        OR v_existing.request_code <> p_request_code
        OR v_existing.initiator_uuid <> p_initiator_uuid
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'ORG_IDEMPOTENCY_REUSED',
          DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
      END IF;

      RETURN v_existing.id;
    END IF;

    v_org_id := orgunit.allocate_org_id(p_tenant_uuid);
  ELSE
    IF p_org_id IS NULL THEN
      RAISE EXCEPTION USING MESSAGE = 'ORG_INVALID_ARGUMENT', DETAIL = 'org_id is required';
    END IF;
    v_org_id := p_org_id;
  END IF;

  INSERT INTO orgunit.org_events (
    event_uuid,
    tenant_uuid,
    hierarchy_type,
    org_id,
    event_type,
    effective_date,
    payload,
    request_code,
    initiator_uuid
  )
  VALUES (
    p_event_uuid,
    p_tenant_uuid,
    p_hierarchy_type,
    v_org_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_code,
    p_initiator_uuid
  )
  ON CONFLICT (event_uuid) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM orgunit.org_events
    WHERE event_uuid = p_event_uuid;

    IF v_existing.tenant_uuid <> p_tenant_uuid
      OR v_existing.hierarchy_type <> p_hierarchy_type
      OR v_existing.org_id <> v_org_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_code <> p_request_code
      OR v_existing.initiator_uuid <> p_initiator_uuid
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'ORG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_uuid=%s existing_id=%s', p_event_uuid, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM orgunit.replay_org_unit_versions(p_tenant_uuid, p_hierarchy_type);

  RETURN v_event_db_id;
END;
$$;

-- end: modules/orgunit/infrastructure/persistence/schema/00015_orgunit_org_id_allocator.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00001_jobcatalog_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE SCHEMA IF NOT EXISTS jobcatalog;


-- end: modules/jobcatalog/infrastructure/persistence/schema/00001_jobcatalog_schema.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00002_jobcatalog_job_family_groups.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_family_groups (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_groups_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_groups_tenant_setid_code_key UNIQUE (tenant_id, code),
  CONSTRAINT job_family_groups_tenant_setid_id_unique UNIQUE (tenant_id, setid, id)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_group_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_family_group_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_group_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_group_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_family_group_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT job_family_group_events_one_per_day_unique UNIQUE (tenant_id, setid, job_family_group_id, effective_date),
  CONSTRAINT job_family_group_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT job_family_group_events_group_fk
    FOREIGN KEY (tenant_id, setid, job_family_group_id) REFERENCES jobcatalog.job_family_groups(tenant_id, setid, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_family_group_events_tenant_effective_idx
  ON jobcatalog.job_family_group_events (tenant_id, setid, job_family_group_id, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_group_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_family_group_id uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_family_group_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_group_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_group_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_family_group_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_family_group_versions_group_fk
    FOREIGN KEY (tenant_id, setid, job_family_group_id) REFERENCES jobcatalog.job_family_groups(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_family_group_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_family_group_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_family_group_versions_active_day_gist
  ON jobcatalog.job_family_group_versions
  USING gist (tenant_id gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_family_group_versions_lookup_btree
  ON jobcatalog.job_family_group_versions (tenant_id, setid, job_family_group_id, lower(validity));

ALTER TABLE jobcatalog.job_family_groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_groups FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_groups;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_groups
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_group_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_group_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_group_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_group_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_group_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_group_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_group_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_group_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00002_jobcatalog_job_family_groups.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00003_jobcatalog_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'tenant_id is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_id THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.normalize_package_id(p_package_id text)
RETURNS uuid
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v uuid;
BEGIN
  IF p_package_id IS NULL OR btrim(p_package_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'package_id is required';
  END IF;
  BEGIN
    v := btrim(p_package_id)::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('package_id=%s', p_package_id);
  END;
  RETURN v;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_group_versions(
  p_tenant_id uuid,
  p_setid text,
  p_job_family_group_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid uuid;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  v_setid := jobcatalog.normalize_package_id(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_family_group_versions
  WHERE tenant_id = p_tenant_id AND package_id = v_setid AND job_family_group_id = p_job_family_group_id;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_family_group_events
    WHERE tenant_id = p_tenant_id
      AND package_id = v_setid
      AND job_family_group_id = p_job_family_group_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb)
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_family_group_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.package_id = v_setid
      AND e.job_family_group_id = p_job_family_group_id
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_family_group_versions (
      tenant_id,
      package_id,
      job_family_group_id,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_id,
      v_setid,
      p_job_family_group_id,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_family_group_versions
      WHERE tenant_id = p_tenant_id
        AND package_id = v_setid
        AND job_family_group_id = p_job_family_group_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_family_group_id=%s', p_job_family_group_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_family_group_versions
      WHERE tenant_id = p_tenant_id
        AND package_id = v_setid
        AND job_family_group_id = p_job_family_group_id
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_family_group_id=%s', p_job_family_group_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_group_versions(
  p_tenant_id uuid,
  p_package_id uuid,
  p_job_family_group_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM jobcatalog.replay_job_family_group_versions(p_tenant_id, p_package_id::text, p_job_family_group_id);
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_family_group_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_setid text,
  p_job_family_group_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid uuid;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_family_group_events%ROWTYPE;
  v_existing_group jobcatalog.job_family_groups%ROWTYPE;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_job_family_group_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_family_group_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := jobcatalog.normalize_package_id(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('code', 'name', 'description', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_family_groups (tenant_id, package_id, id, code)
    VALUES (p_tenant_id, v_setid, p_job_family_group_id, v_code)
    ON CONFLICT (id) DO NOTHING;

    SELECT * INTO v_existing_group
    FROM jobcatalog.job_family_groups
    WHERE id = p_job_family_group_id;

    IF v_existing_group.tenant_id <> p_tenant_id
      OR v_existing_group.package_id <> v_setid
      OR v_existing_group.code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_family_group_id=%s', p_job_family_group_id);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_family_groups
      WHERE tenant_id = p_tenant_id AND package_id = v_setid AND id = p_job_family_group_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_family_group_id=%s', p_job_family_group_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_family_group_events (
    event_id, tenant_id, package_id, job_family_group_id, event_type, effective_date, payload, request_id, initiator_id
  )
  VALUES (
    p_event_id, p_tenant_id, v_setid, p_job_family_group_id, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_family_group_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.package_id <> v_setid
      OR v_existing.job_family_group_id <> p_job_family_group_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_family_group_versions(p_tenant_id, v_setid, p_job_family_group_id);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00003_jobcatalog_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00004_jobcatalog_job_families.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_families (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_families_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_families_tenant_setid_code_key UNIQUE (tenant_id, code),
  CONSTRAINT job_families_tenant_setid_id_unique UNIQUE (tenant_id, setid, id)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_family_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_family_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT job_family_events_one_per_day_unique UNIQUE (tenant_id, setid, job_family_id, effective_date),
  CONSTRAINT job_family_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT job_family_events_family_fk
    FOREIGN KEY (tenant_id, setid, job_family_id) REFERENCES jobcatalog.job_families(tenant_id, setid, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_family_events_tenant_effective_idx
  ON jobcatalog.job_family_events (tenant_id, setid, job_family_id, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_family_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_family_id uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  job_family_group_id uuid NOT NULL,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_family_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_family_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_family_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_family_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_family_versions_family_fk
    FOREIGN KEY (tenant_id, setid, job_family_id) REFERENCES jobcatalog.job_families(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_family_versions_group_fk
    FOREIGN KEY (tenant_id, setid, job_family_group_id) REFERENCES jobcatalog.job_family_groups(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_family_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_family_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_family_versions_active_day_gist
  ON jobcatalog.job_family_versions
  USING gist (tenant_id gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_family_versions_lookup_btree
  ON jobcatalog.job_family_versions (tenant_id, setid, job_family_id, lower(validity));

ALTER TABLE jobcatalog.job_families ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_families FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_families;
CREATE POLICY tenant_isolation ON jobcatalog.job_families
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_family_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_family_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_family_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_family_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00004_jobcatalog_job_families.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00005_jobcatalog_job_family_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_versions(
  p_tenant_id uuid,
  p_setid text,
  p_job_family_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid uuid;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
  v_group_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  v_setid := jobcatalog.normalize_package_id(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_family_versions
  WHERE tenant_id = p_tenant_id AND package_id = v_setid AND job_family_id = p_job_family_id;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_family_events
    WHERE tenant_id = p_tenant_id
      AND package_id = v_setid
      AND job_family_id = p_job_family_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_group_id := NULLIF(btrim(COALESCE(v_row.payload->>'job_family_group_id', '')), '')::uuid;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb),
        'job_family_group_id', v_group_id::text
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
      IF v_row.payload ? 'job_family_group_id' THEN
        v_state := jsonb_set(v_state, '{job_family_group_id}', to_jsonb(v_row.payload->>'job_family_group_id'), true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_family_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.package_id = v_setid
      AND e.job_family_id = p_job_family_id
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_family_versions (
      tenant_id,
      package_id,
      job_family_id,
      validity,
      name,
      description,
      is_active,
      external_refs,
      job_family_group_id,
      last_event_id
    ) VALUES (
      p_tenant_id,
      v_setid,
      p_job_family_id,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      NULLIF(btrim(COALESCE(v_state->>'job_family_group_id', '')), '')::uuid,
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_family_versions
      WHERE tenant_id = p_tenant_id
        AND package_id = v_setid
        AND job_family_id = p_job_family_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_family_id=%s', p_job_family_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_family_versions
      WHERE tenant_id = p_tenant_id
        AND package_id = v_setid
        AND job_family_id = p_job_family_id
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_family_id=%s', p_job_family_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_family_versions(
  p_tenant_id uuid,
  p_package_id uuid,
  p_job_family_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM jobcatalog.replay_job_family_versions(p_tenant_id, p_package_id::text, p_job_family_id);
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_family_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_setid text,
  p_job_family_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid uuid;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_family_events%ROWTYPE;
  v_existing_family jobcatalog.job_families%ROWTYPE;
  v_group_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_job_family_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_family_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := jobcatalog.normalize_package_id(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('code', 'name', 'description', 'external_refs', 'job_family_group_id')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs', 'job_family_group_id')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF v_payload ? 'job_family_group_id' AND NULLIF(btrim(COALESCE(v_payload->>'job_family_group_id', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_group_id must be non-empty';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs' OR v_payload ? 'job_family_group_id') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'code/name is required';
    END IF;

    BEGIN
      v_group_id := NULLIF(btrim(COALESCE(v_payload->>'job_family_group_id', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_group_id must be uuid';
    END;

    IF v_group_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_group_id is required';
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_family_groups
      WHERE tenant_id = p_tenant_id AND package_id = v_setid AND id = v_group_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_group_id=%s', v_group_id);
    END IF;

    INSERT INTO jobcatalog.job_families (tenant_id, package_id, id, code)
    VALUES (p_tenant_id, v_setid, p_job_family_id, v_code)
    ON CONFLICT (id) DO NOTHING;

    SELECT * INTO v_existing_family
    FROM jobcatalog.job_families
    WHERE id = p_job_family_id;

    IF v_existing_family.tenant_id <> p_tenant_id
      OR v_existing_family.package_id <> v_setid
      OR v_existing_family.code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_family_id=%s', p_job_family_id);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_families
      WHERE tenant_id = p_tenant_id AND package_id = v_setid AND id = p_job_family_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_family_id=%s', p_job_family_id);
    END IF;
  END IF;

  IF (p_event_type = 'CREATE' OR p_event_type = 'UPDATE') AND v_payload ? 'job_family_group_id' THEN
    BEGIN
      v_group_id := NULLIF(btrim(COALESCE(v_payload->>'job_family_group_id', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_group_id must be uuid';
    END;

    IF v_group_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_group_id must be non-empty';
    END IF;

    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_family_groups
      WHERE tenant_id = p_tenant_id AND package_id = v_setid AND id = v_group_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_group_id=%s', v_group_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_family_events (
    event_id, tenant_id, package_id, job_family_id, event_type, effective_date, payload, request_id, initiator_id
  )
  VALUES (
    p_event_id, p_tenant_id, v_setid, p_job_family_id, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_family_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.package_id <> v_setid
      OR v_existing.job_family_id <> p_job_family_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_family_versions(p_tenant_id, v_setid, p_job_family_id);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00005_jobcatalog_job_family_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00006_jobcatalog_job_levels.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_levels (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_levels_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_levels_tenant_setid_code_key UNIQUE (tenant_id, code),
  CONSTRAINT job_levels_tenant_setid_id_unique UNIQUE (tenant_id, setid, id)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_level_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_level_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_level_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_level_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_level_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT job_level_events_one_per_day_unique UNIQUE (tenant_id, setid, job_level_id, effective_date),
  CONSTRAINT job_level_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT job_level_events_level_fk
    FOREIGN KEY (tenant_id, setid, job_level_id) REFERENCES jobcatalog.job_levels(tenant_id, setid, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_level_events_tenant_effective_idx
  ON jobcatalog.job_level_events (tenant_id, setid, job_level_id, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_level_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_level_id uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_level_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_level_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_level_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_level_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_level_versions_level_fk
    FOREIGN KEY (tenant_id, setid, job_level_id) REFERENCES jobcatalog.job_levels(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_level_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_level_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_level_versions_active_day_gist
  ON jobcatalog.job_level_versions
  USING gist (tenant_id gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_level_versions_lookup_btree
  ON jobcatalog.job_level_versions (tenant_id, setid, job_level_id, lower(validity));

ALTER TABLE jobcatalog.job_levels ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_levels FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_levels;
CREATE POLICY tenant_isolation ON jobcatalog.job_levels
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_level_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_level_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_level_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_level_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_level_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_level_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_level_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_level_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00006_jobcatalog_job_levels.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00007_jobcatalog_job_level_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_level_versions(
  p_tenant_id uuid,
  p_setid text,
  p_job_level_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid uuid;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  v_setid := jobcatalog.normalize_package_id(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_level_versions
  WHERE tenant_id = p_tenant_id AND package_id = v_setid AND job_level_id = p_job_level_id;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_level_events
    WHERE tenant_id = p_tenant_id
      AND package_id = v_setid
      AND job_level_id = p_job_level_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb)
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_level_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.package_id = v_setid
      AND e.job_level_id = p_job_level_id
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_level_versions (
      tenant_id,
      package_id,
      job_level_id,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_id,
      v_setid,
      p_job_level_id,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    );

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_level_versions
      WHERE tenant_id = p_tenant_id
        AND package_id = v_setid
        AND job_level_id = p_job_level_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_level_id=%s', p_job_level_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_level_versions
      WHERE tenant_id = p_tenant_id
        AND package_id = v_setid
        AND job_level_id = p_job_level_id
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_level_id=%s', p_job_level_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_level_versions(
  p_tenant_id uuid,
  p_package_id uuid,
  p_job_level_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM jobcatalog.replay_job_level_versions(p_tenant_id, p_package_id::text, p_job_level_id);
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_level_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_setid text,
  p_job_level_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid uuid;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_level_events%ROWTYPE;
  v_existing_level jobcatalog.job_levels%ROWTYPE;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_job_level_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_level_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := jobcatalog.normalize_package_id(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('code', 'name', 'description', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_levels (tenant_id, package_id, id, code)
    VALUES (p_tenant_id, v_setid, p_job_level_id, v_code)
    ON CONFLICT (id) DO NOTHING;

    SELECT * INTO v_existing_level
    FROM jobcatalog.job_levels
    WHERE id = p_job_level_id;

    IF v_existing_level.tenant_id <> p_tenant_id
      OR v_existing_level.package_id <> v_setid
      OR v_existing_level.code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_level_id=%s', p_job_level_id);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_levels
      WHERE tenant_id = p_tenant_id AND package_id = v_setid AND id = p_job_level_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_level_id=%s', p_job_level_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_level_events (
    event_id, tenant_id, package_id, job_level_id, event_type, effective_date, payload, request_id, initiator_id
  )
  VALUES (
    p_event_id, p_tenant_id, v_setid, p_job_level_id, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_level_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.package_id <> v_setid
      OR v_existing.job_level_id <> p_job_level_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_level_versions(p_tenant_id, v_setid, p_job_level_id);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00007_jobcatalog_job_level_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00008_jobcatalog_job_profiles.sql
CREATE TABLE IF NOT EXISTS jobcatalog.job_profiles (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  code varchar(64) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profiles_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_profiles_tenant_setid_code_key UNIQUE (tenant_id, code),
  CONSTRAINT job_profiles_tenant_setid_id_unique UNIQUE (tenant_id, setid, id)
);

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_profile_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_events_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_profile_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE','DISABLE')),
  CONSTRAINT job_profile_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT job_profile_events_one_per_day_unique UNIQUE (tenant_id, setid, job_profile_id, effective_date),
  CONSTRAINT job_profile_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT job_profile_events_profile_fk
    FOREIGN KEY (tenant_id, setid, job_profile_id) REFERENCES jobcatalog.job_profiles(tenant_id, setid, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS job_profile_events_tenant_effective_idx
  ON jobcatalog.job_profile_events (tenant_id, setid, job_profile_id, effective_date, id);

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_profile_id uuid NOT NULL,
  validity daterange NOT NULL,
  name text NOT NULL,
  description text NULL,
  is_active boolean NOT NULL DEFAULT true,
  external_refs jsonb NOT NULL DEFAULT '{}'::jsonb,
  last_event_id bigint NOT NULL REFERENCES jobcatalog.job_profile_events(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_versions_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_profile_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT job_profile_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT job_profile_versions_profile_fk
    FOREIGN KEY (tenant_id, setid, job_profile_id) REFERENCES jobcatalog.job_profiles(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_profile_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      setid gist_text_ops WITH =,
      job_profile_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS job_profile_versions_active_day_gist
  ON jobcatalog.job_profile_versions
  USING gist (tenant_id gist_uuid_ops, setid gist_text_ops, validity)
  WHERE is_active = true;

CREATE INDEX IF NOT EXISTS job_profile_versions_lookup_btree
  ON jobcatalog.job_profile_versions (tenant_id, setid, job_profile_id, lower(validity));

CREATE TABLE IF NOT EXISTS jobcatalog.job_profile_version_job_families (
  tenant_id uuid NOT NULL,
  setid text NOT NULL,
  job_profile_version_id bigint NOT NULL,
  job_family_id uuid NOT NULL,
  is_primary boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT job_profile_version_job_families_setid_format_check CHECK (setid ~ '^[A-Z0-9]{5}$'),
  CONSTRAINT job_profile_version_job_families_version_fk
    FOREIGN KEY (job_profile_version_id) REFERENCES jobcatalog.job_profile_versions(id) ON DELETE CASCADE,
  CONSTRAINT job_profile_version_job_families_family_fk
    FOREIGN KEY (tenant_id, setid, job_family_id) REFERENCES jobcatalog.job_families(tenant_id, setid, id) ON DELETE RESTRICT,
  CONSTRAINT job_profile_version_job_families_unique UNIQUE (tenant_id, setid, job_profile_version_id, job_family_id)
);

CREATE UNIQUE INDEX IF NOT EXISTS job_profile_version_job_families_one_primary_unique
  ON jobcatalog.job_profile_version_job_families (tenant_id, setid, job_profile_version_id)
  WHERE is_primary = true;

CREATE INDEX IF NOT EXISTS job_profile_version_job_families_family_lookup_btree
  ON jobcatalog.job_profile_version_job_families (tenant_id, setid, job_family_id);

ALTER TABLE jobcatalog.job_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profiles FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profiles;
CREATE POLICY tenant_isolation ON jobcatalog.job_profiles
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_events;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_versions;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE jobcatalog.job_profile_version_job_families ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobcatalog.job_profile_version_job_families FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON jobcatalog.job_profile_version_job_families;
CREATE POLICY tenant_isolation ON jobcatalog.job_profile_version_job_families
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00008_jobcatalog_job_profiles.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00009_jobcatalog_job_profile_engine.sql
CREATE OR REPLACE FUNCTION jobcatalog.replay_job_profile_versions(
  p_tenant_id uuid,
  p_setid text,
  p_job_profile_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid uuid;
  v_state jsonb;
  v_prev jsonb;
  v_row RECORD;
  v_next_date date;
  v_validity daterange;
  v_version_id bigint;
  v_family_ids uuid[];
  v_primary_family_id uuid;
  v_family_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  v_setid := jobcatalog.normalize_package_id(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM jobcatalog.job_profile_versions
  WHERE tenant_id = p_tenant_id AND package_id = v_setid AND job_profile_id = p_job_profile_id;

  v_prev := NULL;
  FOR v_row IN
    SELECT id, event_type, effective_date, payload
    FROM jobcatalog.job_profile_events
    WHERE tenant_id = p_tenant_id
      AND package_id = v_setid
      AND job_profile_id = p_job_profile_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    v_state := COALESCE(v_prev, '{}'::jsonb);

    IF v_row.event_type = 'CREATE' THEN
      IF v_prev IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;
      v_state := jsonb_build_object(
        'name', v_row.payload->>'name',
        'description', v_row.payload->'description',
        'is_active', true,
        'external_refs', COALESCE(v_row.payload->'external_refs', '{}'::jsonb),
        'job_family_ids', COALESCE(v_row.payload->'job_family_ids', '[]'::jsonb),
        'primary_job_family_id', v_row.payload->>'primary_job_family_id'
      );
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;
      IF v_row.payload ? 'is_active' THEN
        v_state := jsonb_set(v_state, '{is_active}', v_row.payload->'is_active', true);
      END IF;
      IF v_row.payload ? 'name' THEN
        v_state := jsonb_set(v_state, '{name}', to_jsonb(v_row.payload->>'name'), true);
      END IF;
      IF v_row.payload ? 'description' THEN
        v_state := jsonb_set(v_state, '{description}', v_row.payload->'description', true);
      END IF;
      IF v_row.payload ? 'external_refs' THEN
        v_state := jsonb_set(v_state, '{external_refs}', v_row.payload->'external_refs', true);
      END IF;
      IF v_row.payload ? 'job_family_ids' THEN
        v_state := jsonb_set(v_state, '{job_family_ids}', v_row.payload->'job_family_ids', true);
      END IF;
      IF v_row.payload ? 'primary_job_family_id' THEN
        v_state := jsonb_set(v_state, '{primary_job_family_id}', to_jsonb(v_row.payload->>'primary_job_family_id'), true);
      END IF;
    ELSIF v_row.event_type = 'DISABLE' THEN
      IF v_prev IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_EVENT',
          DETAIL = 'DISABLE requires prior state';
      END IF;
      v_state := jsonb_set(v_state, '{is_active}', 'false'::jsonb, true);
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_EVENT',
        DETAIL = format('unsupported event_type=%s', v_row.event_type);
    END IF;

    IF jsonb_typeof(v_state->'job_family_ids') <> 'array' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_ids must be an array';
    END IF;
    IF jsonb_array_length(COALESCE(v_state->'job_family_ids', '[]'::jsonb)) = 0 THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_ids must be non-empty';
    END IF;

    BEGIN
      SELECT array_agg(NULLIF(btrim(value), '')::uuid) INTO v_family_ids
      FROM jsonb_array_elements_text(v_state->'job_family_ids') AS t(value);
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'job_family_ids contains invalid uuid';
    END;
    IF v_family_ids IS NULL OR array_length(v_family_ids, 1) IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_ids must be non-empty';
    END IF;
    IF (SELECT count(*) <> count(DISTINCT id) FROM unnest(v_family_ids) AS t(id)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'job_family_ids contains duplicates';
    END IF;

    BEGIN
      v_primary_family_id := NULLIF(btrim(COALESCE(v_state->>'primary_job_family_id', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'primary_job_family_id is invalid';
    END;
    IF v_primary_family_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'primary_job_family_id is required';
    END IF;
    IF NOT (v_primary_family_id = ANY(v_family_ids)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'primary_job_family_id must be included in job_family_ids';
    END IF;

    v_next_date := NULL;
    SELECT e.effective_date INTO v_next_date
    FROM jobcatalog.job_profile_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.package_id = v_setid
      AND e.job_profile_id = p_job_profile_id
      AND (e.effective_date, e.id) > (v_row.effective_date, v_row.id)
    ORDER BY e.effective_date ASC, e.id ASC
    LIMIT 1;

    v_validity := daterange(v_row.effective_date, v_next_date, '[)');

    INSERT INTO jobcatalog.job_profile_versions (
      tenant_id,
      package_id,
      job_profile_id,
      validity,
      name,
      description,
      is_active,
      external_refs,
      last_event_id
    ) VALUES (
      p_tenant_id,
      v_setid,
      p_job_profile_id,
      v_validity,
      COALESCE(NULLIF(btrim(v_state->>'name'), ''), '[missing]'),
      CASE
        WHEN jsonb_typeof(v_state->'description') = 'null' THEN NULL
        ELSE v_state->>'description'
      END,
      COALESCE((v_state->>'is_active')::boolean, true),
      COALESCE(v_state->'external_refs', '{}'::jsonb),
      v_row.id
    )
    RETURNING id INTO v_version_id;

    FOREACH v_family_id IN ARRAY v_family_ids LOOP
      INSERT INTO jobcatalog.job_profile_version_job_families (
        tenant_id,
        package_id,
        job_profile_version_id,
        job_family_id,
        is_primary
      ) VALUES (
        p_tenant_id,
        v_setid,
        v_version_id,
        v_family_id,
        v_family_id = v_primary_family_id
      );
    END LOOP;

    v_prev := v_state;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM jobcatalog.job_profile_versions
      WHERE tenant_id = p_tenant_id
        AND package_id = v_setid
        AND job_profile_id = p_job_profile_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_GAP',
      DETAIL = format('job_profile_id=%s', p_job_profile_id);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM (
      SELECT validity
      FROM jobcatalog.job_profile_versions
      WHERE tenant_id = p_tenant_id
        AND package_id = v_setid
        AND job_profile_id = p_job_profile_id
      ORDER BY lower(validity) DESC
      LIMIT 1
    ) last
    WHERE NOT upper_inf(last.validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_VALIDITY_NOT_INFINITE',
      DETAIL = format('job_profile_id=%s', p_job_profile_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.replay_job_profile_versions(
  p_tenant_id uuid,
  p_package_id uuid,
  p_job_profile_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM jobcatalog.replay_job_profile_versions(p_tenant_id, p_package_id::text, p_job_profile_id);
END;
$$;

CREATE OR REPLACE FUNCTION jobcatalog.submit_job_profile_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_setid text,
  p_job_profile_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_setid uuid;
  v_evt_db_id bigint;
  v_code text;
  v_name text;
  v_payload jsonb;
  v_existing jobcatalog.job_profile_events%ROWTYPE;
  v_existing_profile jobcatalog.job_profiles%ROWTYPE;
  v_family_ids uuid[];
  v_primary_family_id uuid;
  v_missing_family_id uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'event_id is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'request_id is required';
  END IF;
  IF p_job_profile_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'job_profile_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'effective_date is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE','DISABLE') THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type=%s', p_event_type);
  END IF;

  v_setid := jobcatalog.normalize_package_id(p_setid);

  v_lock_key := format('jobcatalog:write-lock:%s:%s', p_tenant_id, 'JobCatalog');
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'payload must be an object';
  END IF;

  IF p_event_type = 'CREATE' THEN
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('code', 'name', 'description', 'external_refs', 'job_family_ids', 'primary_job_family_id')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for CREATE';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF jsonb_typeof(v_payload->'job_family_ids') <> 'array' OR jsonb_array_length(v_payload->'job_family_ids') = 0 THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_ids must be a non-empty array';
    END IF;
    IF NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_id', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_id is required';
    END IF;
  ELSIF p_event_type = 'UPDATE' THEN
    IF v_payload ? 'code' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.code is not allowed for UPDATE';
    END IF;
    IF EXISTS (
      SELECT 1
      FROM jsonb_object_keys(v_payload) AS k
      WHERE k NOT IN ('name', 'description', 'is_active', 'external_refs', 'job_family_ids', 'primary_job_family_id')
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload has unknown keys for UPDATE';
    END IF;
    IF v_payload ? 'name' AND NULLIF(btrim(COALESCE(v_payload->>'name', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.name must be non-empty';
    END IF;
    IF v_payload ? 'description' AND jsonb_typeof(v_payload->'description') NOT IN ('string','null') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.description must be string or null';
    END IF;
    IF v_payload ? 'is_active' AND jsonb_typeof(v_payload->'is_active') <> 'boolean' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.is_active must be boolean';
    END IF;
    IF v_payload ? 'external_refs' AND jsonb_typeof(v_payload->'external_refs') <> 'object' THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.external_refs must be an object';
    END IF;
    IF v_payload ? 'job_family_ids' THEN
      IF jsonb_typeof(v_payload->'job_family_ids') <> 'array' OR jsonb_array_length(v_payload->'job_family_ids') = 0 THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.job_family_ids must be a non-empty array';
      END IF;
      IF NOT (v_payload ? 'primary_job_family_id') THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.primary_job_family_id is required when job_family_ids is present';
      END IF;
    END IF;
    IF v_payload ? 'primary_job_family_id' AND NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_id', '')), '') IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_id must be non-empty';
    END IF;
    IF NOT (v_payload ? 'name' OR v_payload ? 'description' OR v_payload ? 'is_active' OR v_payload ? 'external_refs' OR v_payload ? 'job_family_ids' OR v_payload ? 'primary_job_family_id') THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'UPDATE payload must include at least one patch field';
    END IF;
  ELSE
    IF v_payload <> '{}'::jsonb THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'DISABLE payload must be empty';
    END IF;
  END IF;

  IF v_payload ? 'job_family_ids' THEN
    BEGIN
      SELECT array_agg(NULLIF(btrim(value), '')::uuid) INTO v_family_ids
      FROM jsonb_array_elements_text(v_payload->'job_family_ids') AS t(value);
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.job_family_ids contains invalid uuid';
    END;
    IF v_family_ids IS NULL OR array_length(v_family_ids, 1) IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_ids must be non-empty';
    END IF;
    IF (SELECT count(*) <> count(DISTINCT id) FROM unnest(v_family_ids) AS t(id)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.job_family_ids contains duplicates';
    END IF;
  END IF;

  IF v_payload ? 'primary_job_family_id' THEN
    BEGIN
      v_primary_family_id := NULLIF(btrim(COALESCE(v_payload->>'primary_job_family_id', '')), '')::uuid;
    EXCEPTION
      WHEN invalid_text_representation THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
          DETAIL = 'payload.primary_job_family_id is invalid';
    END;
    IF v_primary_family_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_id must be non-empty';
    END IF;
  END IF;

  IF v_family_ids IS NOT NULL AND v_primary_family_id IS NOT NULL THEN
    IF NOT (v_primary_family_id = ANY(v_family_ids)) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'payload.primary_job_family_id must be included in payload.job_family_ids';
    END IF;
  END IF;

  IF p_event_type = 'CREATE' THEN
    v_code := NULLIF(btrim(COALESCE(v_payload->>'code', '')), '');
    v_name := NULLIF(btrim(COALESCE(v_payload->>'name', '')), '');
    IF v_code IS NULL OR v_name IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = 'code/name is required';
    END IF;

    INSERT INTO jobcatalog.job_profiles (tenant_id, package_id, id, code)
    VALUES (p_tenant_id, v_setid, p_job_profile_id, v_code)
    ON CONFLICT (id) DO NOTHING;

    SELECT * INTO v_existing_profile
    FROM jobcatalog.job_profiles
    WHERE id = p_job_profile_id;

    IF v_existing_profile.tenant_id <> p_tenant_id
      OR v_existing_profile.package_id <> v_setid
      OR v_existing_profile.code <> v_code
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
        DETAIL = format('job_profile_id=%s', p_job_profile_id);
    END IF;
  ELSE
    IF NOT EXISTS (
      SELECT 1 FROM jobcatalog.job_profiles
      WHERE tenant_id = p_tenant_id AND package_id = v_setid AND id = p_job_profile_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_NOT_FOUND',
        DETAIL = format('job_profile_id=%s', p_job_profile_id);
    END IF;
  END IF;

  IF v_family_ids IS NOT NULL THEN
    SELECT missing.job_family_id INTO v_missing_family_id
    FROM (
      SELECT t.id AS job_family_id
      FROM unnest(v_family_ids) AS t(id)
      LEFT JOIN jobcatalog.job_families f
        ON f.tenant_id = p_tenant_id
       AND f.package_id = v_setid
       AND f.id = t.id
      WHERE f.id IS NULL
      LIMIT 1
    ) missing;
    IF v_missing_family_id IS NOT NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_id=%s', v_missing_family_id);
    END IF;
  END IF;

  IF v_primary_family_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_families
      WHERE tenant_id = p_tenant_id AND package_id = v_setid AND id = v_primary_family_id
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_family_id=%s', v_primary_family_id);
    END IF;
  END IF;

  INSERT INTO jobcatalog.job_profile_events (
    event_id, tenant_id, package_id, job_profile_id, event_type, effective_date, payload, request_id, initiator_id
  )
  VALUES (
    p_event_id, p_tenant_id, v_setid, p_job_profile_id, p_event_type, p_effective_date, v_payload, p_request_id, p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_evt_db_id;

  IF v_evt_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM jobcatalog.job_profile_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.package_id <> v_setid
      OR v_existing.job_profile_id <> p_job_profile_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM jobcatalog.replay_job_profile_versions(p_tenant_id, v_setid, p_job_profile_id);

  RETURN v_evt_db_id;
END;
$$;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00009_jobcatalog_job_profile_engine.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00010_jobcatalog_read.sql
CREATE OR REPLACE FUNCTION jobcatalog.get_job_catalog_snapshot(
  p_tenant_id uuid,
  p_setid text,
  p_query_date date
)
RETURNS TABLE (
  groups jsonb,
  families jsonb,
  levels jsonb,
  profiles jsonb
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_setid uuid;
BEGIN
  PERFORM jobcatalog.assert_current_tenant(p_tenant_id);
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'JOBCATALOG_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  v_setid := jobcatalog.normalize_package_id(p_setid);

  RETURN QUERY
  SELECT
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_family_group_id', g.id,
          'code', g.code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY g.code
      )
      FROM jobcatalog.job_family_groups g
      JOIN jobcatalog.job_family_group_versions v
        ON v.tenant_id = p_tenant_id
       AND v.package_id = v_setid
       AND v.job_family_group_id = g.id
       AND v.validity @> p_query_date
      WHERE g.tenant_id = p_tenant_id
        AND g.package_id = v_setid
    ), '[]'::jsonb) AS groups,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_family_id', f.id,
          'code', f.code,
          'job_family_group_id', v.job_family_group_id,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY f.code
      )
      FROM jobcatalog.job_families f
      JOIN jobcatalog.job_family_versions v
        ON v.tenant_id = p_tenant_id
       AND v.package_id = v_setid
       AND v.job_family_id = f.id
       AND v.validity @> p_query_date
      WHERE f.tenant_id = p_tenant_id
        AND f.package_id = v_setid
    ), '[]'::jsonb) AS families,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_level_id', l.id,
          'code', l.code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id
        )
        ORDER BY l.code
      )
      FROM jobcatalog.job_levels l
      JOIN jobcatalog.job_level_versions v
        ON v.tenant_id = p_tenant_id
       AND v.package_id = v_setid
       AND v.job_level_id = l.id
       AND v.validity @> p_query_date
      WHERE l.tenant_id = p_tenant_id
        AND l.package_id = v_setid
    ), '[]'::jsonb) AS levels,
    COALESCE((
      SELECT jsonb_agg(
        jsonb_build_object(
          'job_profile_id', p.id,
          'code', p.code,
          'name', v.name,
          'description', v.description,
          'is_active', v.is_active,
          'external_refs', v.external_refs,
          'valid_from', lower(v.validity),
          'valid_to_excl', upper(v.validity),
          'last_event_db_id', v.last_event_id,
          'job_family_ids', COALESCE(fam.job_family_ids, '[]'::jsonb),
          'primary_job_family_id', fam.primary_job_family_id
        )
        ORDER BY p.code
      )
      FROM jobcatalog.job_profiles p
      JOIN jobcatalog.job_profile_versions v
        ON v.tenant_id = p_tenant_id
       AND v.package_id = v_setid
       AND v.job_profile_id = p.id
       AND v.validity @> p_query_date
      LEFT JOIN LATERAL (
        SELECT
          jsonb_agg(f.job_family_id ORDER BY f.job_family_id) AS job_family_ids,
          (
            SELECT f2.job_family_id
            FROM jobcatalog.job_profile_version_job_families f2
            WHERE f2.tenant_id = p_tenant_id
              AND f2.package_id = v_setid
              AND f2.job_profile_version_id = v.id
              AND f2.is_primary = true
            LIMIT 1
          ) AS primary_job_family_id
        FROM jobcatalog.job_profile_version_job_families f
        WHERE f.tenant_id = p_tenant_id
          AND f.package_id = v_setid
          AND f.job_profile_version_id = v.id
      ) fam ON true
      WHERE p.tenant_id = p_tenant_id
        AND p.package_id = v_setid
    ), '[]'::jsonb) AS profiles;
END;
$$;


-- end: modules/jobcatalog/infrastructure/persistence/schema/00010_jobcatalog_read.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00011_jobcatalog_package_id_schema.sql
ALTER TABLE jobcatalog.job_family_groups
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_family_groups
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_groups
  DROP CONSTRAINT IF EXISTS job_family_groups_setid_format_check;
ALTER TABLE jobcatalog.job_family_groups
  DROP CONSTRAINT IF EXISTS job_family_groups_tenant_setid_code_key;
ALTER TABLE jobcatalog.job_family_groups
  DROP CONSTRAINT IF EXISTS job_family_groups_tenant_setid_id_unique CASCADE;
ALTER TABLE jobcatalog.job_family_groups
  ADD CONSTRAINT job_family_groups_tenant_pkg_code_key UNIQUE (tenant_id, package_id, code);
ALTER TABLE jobcatalog.job_family_groups
  ADD CONSTRAINT job_family_groups_tenant_pkg_id_unique UNIQUE (tenant_id, package_id, id);

ALTER TABLE jobcatalog.job_family_group_events
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_family_group_events
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_group_events
  DROP CONSTRAINT IF EXISTS job_family_group_events_setid_format_check;
ALTER TABLE jobcatalog.job_family_group_events
  DROP CONSTRAINT IF EXISTS job_family_group_events_one_per_day_unique;
ALTER TABLE jobcatalog.job_family_group_events
  DROP CONSTRAINT IF EXISTS job_family_group_events_group_fk;
ALTER TABLE jobcatalog.job_family_group_events
  ADD CONSTRAINT job_family_group_events_one_per_day_unique UNIQUE (tenant_id, package_id, job_family_group_id, effective_date);
ALTER TABLE jobcatalog.job_family_group_events
  ADD CONSTRAINT job_family_group_events_group_fk
    FOREIGN KEY (tenant_id, package_id, job_family_group_id)
    REFERENCES jobcatalog.job_family_groups(tenant_id, package_id, id) ON DELETE RESTRICT;

DROP INDEX IF EXISTS jobcatalog.job_family_group_events_tenant_effective_idx;
CREATE INDEX IF NOT EXISTS job_family_group_events_tenant_effective_idx
  ON jobcatalog.job_family_group_events (tenant_id, package_id, job_family_group_id, effective_date, id);

ALTER TABLE jobcatalog.job_family_group_versions
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_family_group_versions
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_group_versions
  DROP CONSTRAINT IF EXISTS job_family_group_versions_setid_format_check;
ALTER TABLE jobcatalog.job_family_group_versions
  DROP CONSTRAINT IF EXISTS job_family_group_versions_group_fk;
ALTER TABLE jobcatalog.job_family_group_versions
  DROP CONSTRAINT IF EXISTS job_family_group_versions_no_overlap;
ALTER TABLE jobcatalog.job_family_group_versions
  ADD CONSTRAINT job_family_group_versions_group_fk
    FOREIGN KEY (tenant_id, package_id, job_family_group_id)
    REFERENCES jobcatalog.job_family_groups(tenant_id, package_id, id) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_family_group_versions
  ADD CONSTRAINT job_family_group_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      package_id gist_uuid_ops WITH =,
      job_family_group_id gist_uuid_ops WITH =,
      validity WITH &&
    );

DROP INDEX IF EXISTS jobcatalog.job_family_group_versions_active_day_gist;
CREATE INDEX IF NOT EXISTS job_family_group_versions_active_day_gist
  ON jobcatalog.job_family_group_versions
  USING gist (tenant_id gist_uuid_ops, package_id gist_uuid_ops, validity)
  WHERE is_active = true;

DROP INDEX IF EXISTS jobcatalog.job_family_group_versions_lookup_btree;
CREATE INDEX IF NOT EXISTS job_family_group_versions_lookup_btree
  ON jobcatalog.job_family_group_versions (tenant_id, package_id, job_family_group_id, lower(validity));

ALTER TABLE jobcatalog.job_families
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_families
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_families
  DROP CONSTRAINT IF EXISTS job_families_setid_format_check;
ALTER TABLE jobcatalog.job_families
  DROP CONSTRAINT IF EXISTS job_families_tenant_setid_code_key;
ALTER TABLE jobcatalog.job_families
  DROP CONSTRAINT IF EXISTS job_families_tenant_setid_id_unique CASCADE;
ALTER TABLE jobcatalog.job_families
  ADD CONSTRAINT job_families_tenant_pkg_code_key UNIQUE (tenant_id, package_id, code);
ALTER TABLE jobcatalog.job_families
  ADD CONSTRAINT job_families_tenant_pkg_id_unique UNIQUE (tenant_id, package_id, id);

ALTER TABLE jobcatalog.job_family_events
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_family_events
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_events
  DROP CONSTRAINT IF EXISTS job_family_events_setid_format_check;
ALTER TABLE jobcatalog.job_family_events
  DROP CONSTRAINT IF EXISTS job_family_events_one_per_day_unique;
ALTER TABLE jobcatalog.job_family_events
  DROP CONSTRAINT IF EXISTS job_family_events_family_fk;
ALTER TABLE jobcatalog.job_family_events
  ADD CONSTRAINT job_family_events_one_per_day_unique UNIQUE (tenant_id, package_id, job_family_id, effective_date);
ALTER TABLE jobcatalog.job_family_events
  ADD CONSTRAINT job_family_events_family_fk
    FOREIGN KEY (tenant_id, package_id, job_family_id)
    REFERENCES jobcatalog.job_families(tenant_id, package_id, id) ON DELETE RESTRICT;

DROP INDEX IF EXISTS jobcatalog.job_family_events_tenant_effective_idx;
CREATE INDEX IF NOT EXISTS job_family_events_tenant_effective_idx
  ON jobcatalog.job_family_events (tenant_id, package_id, job_family_id, effective_date, id);

ALTER TABLE jobcatalog.job_family_versions
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_family_versions
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_family_versions
  DROP CONSTRAINT IF EXISTS job_family_versions_setid_format_check;
ALTER TABLE jobcatalog.job_family_versions
  DROP CONSTRAINT IF EXISTS job_family_versions_family_fk;
ALTER TABLE jobcatalog.job_family_versions
  DROP CONSTRAINT IF EXISTS job_family_versions_group_fk;
ALTER TABLE jobcatalog.job_family_versions
  DROP CONSTRAINT IF EXISTS job_family_versions_no_overlap;
ALTER TABLE jobcatalog.job_family_versions
  ADD CONSTRAINT job_family_versions_family_fk
    FOREIGN KEY (tenant_id, package_id, job_family_id)
    REFERENCES jobcatalog.job_families(tenant_id, package_id, id) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_family_versions
  ADD CONSTRAINT job_family_versions_group_fk
    FOREIGN KEY (tenant_id, package_id, job_family_group_id)
    REFERENCES jobcatalog.job_family_groups(tenant_id, package_id, id) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_family_versions
  ADD CONSTRAINT job_family_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      package_id gist_uuid_ops WITH =,
      job_family_id gist_uuid_ops WITH =,
      validity WITH &&
    );

DROP INDEX IF EXISTS jobcatalog.job_family_versions_active_day_gist;
CREATE INDEX IF NOT EXISTS job_family_versions_active_day_gist
  ON jobcatalog.job_family_versions
  USING gist (tenant_id gist_uuid_ops, package_id gist_uuid_ops, validity)
  WHERE is_active = true;

DROP INDEX IF EXISTS jobcatalog.job_family_versions_lookup_btree;
CREATE INDEX IF NOT EXISTS job_family_versions_lookup_btree
  ON jobcatalog.job_family_versions (tenant_id, package_id, job_family_id, lower(validity));

ALTER TABLE jobcatalog.job_levels
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_levels
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_levels
  DROP CONSTRAINT IF EXISTS job_levels_setid_format_check;
ALTER TABLE jobcatalog.job_levels
  DROP CONSTRAINT IF EXISTS job_levels_tenant_setid_code_key;
ALTER TABLE jobcatalog.job_levels
  DROP CONSTRAINT IF EXISTS job_levels_tenant_setid_id_unique CASCADE;
ALTER TABLE jobcatalog.job_levels
  ADD CONSTRAINT job_levels_tenant_pkg_code_key UNIQUE (tenant_id, package_id, code);
ALTER TABLE jobcatalog.job_levels
  ADD CONSTRAINT job_levels_tenant_pkg_id_unique UNIQUE (tenant_id, package_id, id);

ALTER TABLE jobcatalog.job_level_events
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_level_events
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_level_events
  DROP CONSTRAINT IF EXISTS job_level_events_setid_format_check;
ALTER TABLE jobcatalog.job_level_events
  DROP CONSTRAINT IF EXISTS job_level_events_one_per_day_unique;
ALTER TABLE jobcatalog.job_level_events
  DROP CONSTRAINT IF EXISTS job_level_events_level_fk;
ALTER TABLE jobcatalog.job_level_events
  ADD CONSTRAINT job_level_events_one_per_day_unique UNIQUE (tenant_id, package_id, job_level_id, effective_date);
ALTER TABLE jobcatalog.job_level_events
  ADD CONSTRAINT job_level_events_level_fk
    FOREIGN KEY (tenant_id, package_id, job_level_id)
    REFERENCES jobcatalog.job_levels(tenant_id, package_id, id) ON DELETE RESTRICT;

DROP INDEX IF EXISTS jobcatalog.job_level_events_tenant_effective_idx;
CREATE INDEX IF NOT EXISTS job_level_events_tenant_effective_idx
  ON jobcatalog.job_level_events (tenant_id, package_id, job_level_id, effective_date, id);

ALTER TABLE jobcatalog.job_level_versions
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_level_versions
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_level_versions
  DROP CONSTRAINT IF EXISTS job_level_versions_setid_format_check;
ALTER TABLE jobcatalog.job_level_versions
  DROP CONSTRAINT IF EXISTS job_level_versions_level_fk;
ALTER TABLE jobcatalog.job_level_versions
  DROP CONSTRAINT IF EXISTS job_level_versions_no_overlap;
ALTER TABLE jobcatalog.job_level_versions
  ADD CONSTRAINT job_level_versions_level_fk
    FOREIGN KEY (tenant_id, package_id, job_level_id)
    REFERENCES jobcatalog.job_levels(tenant_id, package_id, id) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_level_versions
  ADD CONSTRAINT job_level_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      package_id gist_uuid_ops WITH =,
      job_level_id gist_uuid_ops WITH =,
      validity WITH &&
    );

DROP INDEX IF EXISTS jobcatalog.job_level_versions_active_day_gist;
CREATE INDEX IF NOT EXISTS job_level_versions_active_day_gist
  ON jobcatalog.job_level_versions
  USING gist (tenant_id gist_uuid_ops, package_id gist_uuid_ops, validity)
  WHERE is_active = true;

DROP INDEX IF EXISTS jobcatalog.job_level_versions_lookup_btree;
CREATE INDEX IF NOT EXISTS job_level_versions_lookup_btree
  ON jobcatalog.job_level_versions (tenant_id, package_id, job_level_id, lower(validity));

ALTER TABLE jobcatalog.job_profiles
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_profiles
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_profiles
  DROP CONSTRAINT IF EXISTS job_profiles_setid_format_check;
ALTER TABLE jobcatalog.job_profiles
  DROP CONSTRAINT IF EXISTS job_profiles_tenant_setid_code_key;
ALTER TABLE jobcatalog.job_profiles
  DROP CONSTRAINT IF EXISTS job_profiles_tenant_setid_id_unique CASCADE;
ALTER TABLE jobcatalog.job_profiles
  ADD CONSTRAINT job_profiles_tenant_pkg_code_key UNIQUE (tenant_id, package_id, code);
ALTER TABLE jobcatalog.job_profiles
  ADD CONSTRAINT job_profiles_tenant_pkg_id_unique UNIQUE (tenant_id, package_id, id);

ALTER TABLE jobcatalog.job_profile_events
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_profile_events
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_profile_events
  DROP CONSTRAINT IF EXISTS job_profile_events_setid_format_check;
ALTER TABLE jobcatalog.job_profile_events
  DROP CONSTRAINT IF EXISTS job_profile_events_one_per_day_unique;
ALTER TABLE jobcatalog.job_profile_events
  DROP CONSTRAINT IF EXISTS job_profile_events_profile_fk;
ALTER TABLE jobcatalog.job_profile_events
  ADD CONSTRAINT job_profile_events_one_per_day_unique UNIQUE (tenant_id, package_id, job_profile_id, effective_date);
ALTER TABLE jobcatalog.job_profile_events
  ADD CONSTRAINT job_profile_events_profile_fk
    FOREIGN KEY (tenant_id, package_id, job_profile_id)
    REFERENCES jobcatalog.job_profiles(tenant_id, package_id, id) ON DELETE RESTRICT;

DROP INDEX IF EXISTS jobcatalog.job_profile_events_tenant_effective_idx;
CREATE INDEX IF NOT EXISTS job_profile_events_tenant_effective_idx
  ON jobcatalog.job_profile_events (tenant_id, package_id, job_profile_id, effective_date, id);

ALTER TABLE jobcatalog.job_profile_versions
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_profile_versions
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_profile_versions
  DROP CONSTRAINT IF EXISTS job_profile_versions_setid_format_check;
ALTER TABLE jobcatalog.job_profile_versions
  DROP CONSTRAINT IF EXISTS job_profile_versions_profile_fk;
ALTER TABLE jobcatalog.job_profile_versions
  DROP CONSTRAINT IF EXISTS job_profile_versions_no_overlap;
ALTER TABLE jobcatalog.job_profile_versions
  ADD CONSTRAINT job_profile_versions_profile_fk
    FOREIGN KEY (tenant_id, package_id, job_profile_id)
    REFERENCES jobcatalog.job_profiles(tenant_id, package_id, id) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_profile_versions
  ADD CONSTRAINT job_profile_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      package_id gist_uuid_ops WITH =,
      job_profile_id gist_uuid_ops WITH =,
      validity WITH &&
    );

DROP INDEX IF EXISTS jobcatalog.job_profile_versions_active_day_gist;
CREATE INDEX IF NOT EXISTS job_profile_versions_active_day_gist
  ON jobcatalog.job_profile_versions
  USING gist (tenant_id gist_uuid_ops, package_id gist_uuid_ops, validity)
  WHERE is_active = true;

DROP INDEX IF EXISTS jobcatalog.job_profile_versions_lookup_btree;
CREATE INDEX IF NOT EXISTS job_profile_versions_lookup_btree
  ON jobcatalog.job_profile_versions (tenant_id, package_id, job_profile_id, lower(validity));

ALTER TABLE jobcatalog.job_profile_version_job_families
  ADD COLUMN package_id uuid;
ALTER TABLE jobcatalog.job_profile_version_job_families
  ALTER COLUMN setid DROP NOT NULL;
ALTER TABLE jobcatalog.job_profile_version_job_families
  DROP CONSTRAINT IF EXISTS job_profile_version_job_families_setid_format_check;
ALTER TABLE jobcatalog.job_profile_version_job_families
  DROP CONSTRAINT IF EXISTS job_profile_version_job_families_family_fk;
ALTER TABLE jobcatalog.job_profile_version_job_families
  DROP CONSTRAINT IF EXISTS job_profile_version_job_families_unique;
ALTER TABLE jobcatalog.job_profile_version_job_families
  ADD CONSTRAINT job_profile_version_job_families_family_fk
    FOREIGN KEY (tenant_id, package_id, job_family_id)
    REFERENCES jobcatalog.job_families(tenant_id, package_id, id) ON DELETE RESTRICT;
ALTER TABLE jobcatalog.job_profile_version_job_families
  ADD CONSTRAINT job_profile_version_job_families_unique
    UNIQUE (tenant_id, package_id, job_profile_version_id, job_family_id);

DROP INDEX IF EXISTS jobcatalog.job_profile_version_job_families_one_primary_unique;
CREATE UNIQUE INDEX IF NOT EXISTS job_profile_version_job_families_one_primary_unique
  ON jobcatalog.job_profile_version_job_families (tenant_id, package_id, job_profile_version_id)
  WHERE is_primary = true;

DROP INDEX IF EXISTS jobcatalog.job_profile_version_job_families_family_lookup_btree;
CREATE INDEX IF NOT EXISTS job_profile_version_job_families_family_lookup_btree
  ON jobcatalog.job_profile_version_job_families (tenant_id, package_id, job_family_id);

-- end: modules/jobcatalog/infrastructure/persistence/schema/00011_jobcatalog_package_id_schema.sql

-- begin: modules/jobcatalog/infrastructure/persistence/schema/00012_jobcatalog_package_code_schema.sql
ALTER TABLE jobcatalog.job_family_groups
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_family_group_events
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_family_group_versions
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_families
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_family_events
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_family_versions
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_levels
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_level_events
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_level_versions
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_profiles
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_profile_events
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_profile_versions
  ADD COLUMN IF NOT EXISTS package_code text;

ALTER TABLE jobcatalog.job_profile_version_job_families
  ADD COLUMN IF NOT EXISTS package_code text;

-- end: modules/jobcatalog/infrastructure/persistence/schema/00012_jobcatalog_package_code_schema.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00001_staffing_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE SCHEMA IF NOT EXISTS staffing;


-- end: modules/staffing/infrastructure/persistence/schema/00001_staffing_schema.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00002_staffing_tables.sql
CREATE TABLE IF NOT EXISTS staffing.positions (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id)
);

CREATE TABLE IF NOT EXISTS staffing.position_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  position_id uuid NOT NULL,
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT position_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE')),
  CONSTRAINT position_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT position_events_payload_allowed_keys_check CHECK (
    (
      payload
      - 'org_unit_id'
      - 'name'
      - 'reports_to_position_id'
      - 'job_profile_id'
      - 'lifecycle_status'
      - 'capacity_fte'
    ) = '{}'::jsonb
  ),
  CONSTRAINT position_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT position_events_one_per_day_unique UNIQUE (tenant_id, position_id, effective_date),
  CONSTRAINT position_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT position_events_position_fk FOREIGN KEY (tenant_id, position_id) REFERENCES staffing.positions(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS position_events_tenant_position_effective_idx
  ON staffing.position_events (tenant_id, position_id, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.position_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  position_id uuid NOT NULL,
  org_unit_id int NOT NULL CHECK (org_unit_id BETWEEN 10000000 AND 99999999),
  reports_to_position_id uuid NULL,
  name text NULL,
  lifecycle_status text NOT NULL DEFAULT 'active',
  capacity_fte numeric(9,2) NOT NULL DEFAULT 1.0,
  profile jsonb NOT NULL DEFAULT '{}'::jsonb,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.position_events(id),
  CONSTRAINT position_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT position_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT position_versions_capacity_fte_check CHECK (capacity_fte > 0),
  CONSTRAINT position_versions_profile_is_object_check CHECK (jsonb_typeof(profile) = 'object'),
  CONSTRAINT position_versions_lifecycle_status_check CHECK (lifecycle_status IN ('active','disabled')),
  CONSTRAINT position_versions_position_fk FOREIGN KEY (tenant_id, position_id) REFERENCES staffing.positions(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT position_versions_reports_to_fk FOREIGN KEY (tenant_id, reports_to_position_id) REFERENCES staffing.positions(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT position_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      position_id gist_uuid_ops WITH =,
      validity WITH &&
    )
);

CREATE INDEX IF NOT EXISTS position_versions_lookup_btree
  ON staffing.position_versions (tenant_id, position_id, lower(validity));

ALTER TABLE staffing.position_versions
  ADD COLUMN IF NOT EXISTS jobcatalog_setid text NULL,
  ADD COLUMN IF NOT EXISTS jobcatalog_setid_as_of date NULL,
  ADD COLUMN IF NOT EXISTS job_profile_id uuid NULL;

ALTER TABLE staffing.position_versions
  DROP CONSTRAINT IF EXISTS position_versions_jobcatalog_setid_format_check,
  DROP CONSTRAINT IF EXISTS position_versions_jobcatalog_setid_requires_bu_check,
  DROP CONSTRAINT IF EXISTS position_versions_job_profile_requires_setid_check,
  DROP CONSTRAINT IF EXISTS position_versions_job_profile_fk;

ALTER TABLE staffing.position_versions
  ADD CONSTRAINT position_versions_jobcatalog_setid_format_check CHECK (jobcatalog_setid IS NULL OR jobcatalog_setid ~ '^[A-Z0-9]{5}$'),
  ADD CONSTRAINT position_versions_jobcatalog_setid_as_of_check CHECK (jobcatalog_setid IS NULL OR jobcatalog_setid_as_of IS NOT NULL),
  ADD CONSTRAINT position_versions_job_profile_requires_setid_check CHECK (job_profile_id IS NULL OR jobcatalog_setid IS NOT NULL);

CREATE TABLE IF NOT EXISTS staffing.assignments (
  tenant_id uuid NOT NULL,
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  person_uuid uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, id),
  CONSTRAINT assignments_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignments_tenant_person_type_unique UNIQUE (tenant_id, person_uuid, assignment_type)
);

CREATE TABLE IF NOT EXISTS staffing.assignment_events (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  assignment_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  event_type text NOT NULL,
  effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT assignment_events_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignment_events_event_type_check CHECK (event_type IN ('CREATE','UPDATE')),
  CONSTRAINT assignment_events_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT assignment_events_payload_allowed_keys_check CHECK (
    (
      payload
      - 'position_id'
      - 'status'
      - 'allocated_fte'
      - 'profile'
    ) = '{}'::jsonb
  ),
  CONSTRAINT assignment_events_event_id_unique UNIQUE (event_id),
  CONSTRAINT assignment_events_one_per_day_unique UNIQUE (tenant_id, assignment_id, effective_date),
  CONSTRAINT assignment_events_request_id_unique UNIQUE (tenant_id, request_id),
  CONSTRAINT assignment_events_assignment_fk FOREIGN KEY (tenant_id, assignment_id) REFERENCES staffing.assignments(tenant_id, id) ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS assignment_events_tenant_assignment_effective_idx
  ON staffing.assignment_events (tenant_id, assignment_id, effective_date, id);

CREATE TABLE IF NOT EXISTS staffing.assignment_event_corrections (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL,
  tenant_id uuid NOT NULL,
  assignment_id uuid NOT NULL,
  target_effective_date date NOT NULL,
  replacement_payload jsonb NOT NULL,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT assignment_event_corrections_replacement_payload_obj_check CHECK (jsonb_typeof(replacement_payload) = 'object'),
  CONSTRAINT assignment_event_corrections_event_id_unique UNIQUE (event_id),
  CONSTRAINT assignment_event_corrections_target_unique UNIQUE (tenant_id, assignment_id, target_effective_date),
  CONSTRAINT assignment_event_corrections_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE TABLE IF NOT EXISTS staffing.assignment_event_rescinds (
  id bigserial PRIMARY KEY,
  event_id uuid NOT NULL,
  tenant_id uuid NOT NULL,
  assignment_id uuid NOT NULL,
  target_effective_date date NOT NULL,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  request_id text NOT NULL,
  initiator_id uuid NOT NULL,
  transaction_time timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT assignment_event_rescinds_payload_is_object_check CHECK (jsonb_typeof(payload) = 'object'),
  CONSTRAINT assignment_event_rescinds_event_id_unique UNIQUE (event_id),
  CONSTRAINT assignment_event_rescinds_target_unique UNIQUE (tenant_id, assignment_id, target_effective_date),
  CONSTRAINT assignment_event_rescinds_request_id_unique UNIQUE (tenant_id, request_id)
);

CREATE TABLE IF NOT EXISTS staffing.assignment_versions (
  id bigserial PRIMARY KEY,
  tenant_id uuid NOT NULL,
  assignment_id uuid NOT NULL,
  person_uuid uuid NOT NULL,
  position_id uuid NOT NULL,
  assignment_type text NOT NULL DEFAULT 'primary',
  status text NOT NULL DEFAULT 'active',
  allocated_fte numeric(9,2) NOT NULL DEFAULT 1.0,
  validity daterange NOT NULL,
  last_event_id bigint NOT NULL REFERENCES staffing.assignment_events(id),
  CONSTRAINT assignment_versions_validity_check CHECK (NOT isempty(validity)),
  CONSTRAINT assignment_versions_validity_bounds_check CHECK (lower_inc(validity) AND NOT upper_inc(validity)),
  CONSTRAINT assignment_versions_allocated_fte_check CHECK (allocated_fte > 0),
  CONSTRAINT assignment_versions_status_check CHECK (status IN ('active','inactive')),
  CONSTRAINT assignment_versions_assignment_type_check CHECK (assignment_type IN ('primary')),
  CONSTRAINT assignment_versions_assignment_fk FOREIGN KEY (tenant_id, assignment_id) REFERENCES staffing.assignments(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT assignment_versions_position_fk FOREIGN KEY (tenant_id, position_id) REFERENCES staffing.positions(tenant_id, id) ON DELETE RESTRICT,
  CONSTRAINT assignment_versions_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      assignment_id gist_uuid_ops WITH =,
      validity WITH &&
    ),
  CONSTRAINT assignment_versions_position_no_overlap
    EXCLUDE USING gist (
      tenant_id gist_uuid_ops WITH =,
      position_id gist_uuid_ops WITH =,
      validity WITH &&
    )
    WHERE (status = 'active')
);

CREATE INDEX IF NOT EXISTS assignment_versions_person_lookup_btree
  ON staffing.assignment_versions (tenant_id, person_uuid, lower(validity));

ALTER TABLE staffing.assignment_versions
  ADD COLUMN IF NOT EXISTS profile jsonb NOT NULL DEFAULT '{}'::jsonb;

ALTER TABLE staffing.assignment_versions
  DROP CONSTRAINT IF EXISTS assignment_versions_profile_is_object_check;

ALTER TABLE staffing.assignment_versions
  ADD CONSTRAINT assignment_versions_profile_is_object_check CHECK (jsonb_typeof(profile) = 'object');

ALTER TABLE staffing.positions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.positions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.positions;
CREATE POLICY tenant_isolation ON staffing.positions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.position_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.position_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.position_events;
CREATE POLICY tenant_isolation ON staffing.position_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.position_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.position_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.position_versions;
CREATE POLICY tenant_isolation ON staffing.position_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignments FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignments;
CREATE POLICY tenant_isolation ON staffing.assignments
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_events FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_events;
CREATE POLICY tenant_isolation ON staffing.assignment_events
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_event_corrections ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_event_corrections FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_event_corrections;
CREATE POLICY tenant_isolation ON staffing.assignment_event_corrections
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_event_rescinds ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_event_rescinds FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_event_rescinds;
CREATE POLICY tenant_isolation ON staffing.assignment_event_rescinds
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

ALTER TABLE staffing.assignment_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffing.assignment_versions FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON staffing.assignment_versions;
CREATE POLICY tenant_isolation ON staffing.assignment_versions
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/staffing/infrastructure/persistence/schema/00002_staffing_tables.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00003_staffing_engine.sql
CREATE OR REPLACE FUNCTION staffing.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'tenant_id is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_id THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_position_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_position_id uuid,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_reports_to_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.position_events%ROWTYPE;
  v_payload jsonb;
  v_prev_effective_max date;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_position_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'position_id is required';
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);

  IF v_payload ? 'reports_to_position_id' THEN
    v_reports_to_lock_key := format('staffing:position-reports-to:%s', p_tenant_id);
    PERFORM pg_advisory_xact_lock(hashtextextended(v_reports_to_lock_key, 0));
  END IF;

  v_lock_key := format('staffing:position:%s:%s', p_tenant_id, p_position_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  INSERT INTO staffing.positions (tenant_id, id)
  VALUES (p_tenant_id, p_position_id)
  ON CONFLICT DO NOTHING;

  INSERT INTO staffing.position_events (
    event_id,
    tenant_id,
    position_id,
    event_type,
    effective_date,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_position_id,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.position_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.position_id <> p_position_id
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  IF p_event_type = 'UPDATE' AND v_payload ? 'reports_to_position_id' THEN
    SELECT max(effective_date) INTO v_prev_effective_max
    FROM staffing.position_events
    WHERE tenant_id = p_tenant_id
      AND position_id = p_position_id
      AND id <> v_event_db_id;

    IF v_prev_effective_max IS NOT NULL AND p_effective_date <= v_prev_effective_max THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('reports_to_position_id updates must be forward-only: effective_date=%s last_effective_date=%s', p_effective_date, v_prev_effective_max);
    END IF;
  END IF;

  PERFORM staffing.replay_position_versions(p_tenant_id, p_position_id);

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.replay_position_versions(
  p_tenant_id uuid,
  p_position_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_prev_effective date;
  v_last_validity daterange;
  v_org_unit_id int;
  v_reports_to_position_id uuid;
  v_jobcatalog_setid text;
  v_jobcatalog_setid_as_of date;
  v_jobcatalog_package_id uuid;
  v_job_profile_id uuid;
  v_name text;
  v_lifecycle_status text;
  v_capacity_fte numeric(9,2);
  v_profile jsonb;
  v_tmp_text text;
  v_target_status text;
  v_row RECORD;
  v_validity daterange;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_position_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'position_id is required';
  END IF;

  v_lock_key := format('staffing:position:%s:%s', p_tenant_id, p_position_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM staffing.position_versions
  WHERE tenant_id = p_tenant_id AND position_id = p_position_id;

  v_org_unit_id := NULL;
  v_reports_to_position_id := NULL;
  v_jobcatalog_setid := NULL;
  v_jobcatalog_setid_as_of := NULL;
  v_job_profile_id := NULL;
  v_name := NULL;
  v_lifecycle_status := 'active';
  v_capacity_fte := 1.0;
  v_profile := '{}'::jsonb;
  v_prev_effective := NULL;

  FOR v_row IN
    SELECT
      e.id AS event_db_id,
      e.event_type,
      e.effective_date,
      e.payload,
      lead(effective_date) OVER (ORDER BY effective_date ASC, id ASC) AS next_effective
    FROM staffing.position_events e
    WHERE e.tenant_id = p_tenant_id
      AND e.position_id = p_position_id
    ORDER BY effective_date ASC, id ASC
  LOOP
    IF v_row.event_type = 'CREATE' THEN
      IF v_prev_effective IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_tmp_text := NULLIF(btrim(v_row.payload->>'org_unit_id'), '');
      IF v_tmp_text IS NULL THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_INVALID_ARGUMENT',
          DETAIL = 'org_unit_id is required';
      END IF;
      BEGIN
        v_org_unit_id := v_tmp_text::int;
      EXCEPTION
        WHEN invalid_text_representation THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('org_unit_id=%s', v_row.payload->>'org_unit_id');
      END;

      v_name := NULLIF(btrim(v_row.payload->>'name'), '');

      IF v_row.payload ? 'reports_to_position_id' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'reports_to_position_id'), '');
        IF v_tmp_text IS NULL THEN
          v_reports_to_position_id := NULL;
        ELSE
          BEGIN
            v_reports_to_position_id := v_tmp_text::uuid;
          EXCEPTION
            WHEN invalid_text_representation THEN
              RAISE EXCEPTION USING
                MESSAGE = 'STAFFING_INVALID_ARGUMENT',
                DETAIL = format('reports_to_position_id=%s', v_row.payload->>'reports_to_position_id');
          END;
        END IF;
      ELSE
        v_reports_to_position_id := NULL;
      END IF;

      IF v_row.payload ? 'lifecycle_status' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'lifecycle_status'), '');
        IF v_tmp_text IS NULL OR v_tmp_text NOT IN ('active','disabled') THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('lifecycle_status=%s', v_row.payload->>'lifecycle_status');
        END IF;
        v_lifecycle_status := v_tmp_text;
      ELSE
        v_lifecycle_status := 'active';
      END IF;

      IF v_row.payload ? 'capacity_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'capacity_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'capacity_fte is required';
        END IF;
        BEGIN
          v_capacity_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_INVALID_ARGUMENT',
              DETAIL = format('capacity_fte=%s', v_row.payload->>'capacity_fte');
        END;
        IF v_capacity_fte <= 0 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('capacity_fte=%s', v_row.payload->>'capacity_fte');
        END IF;
      ELSE
        v_capacity_fte := 1.0;
      END IF;

      IF v_row.payload ? 'job_profile_id' THEN
        IF v_row.payload->'job_profile_id' IS NULL THEN
          v_job_profile_id := NULL;
        ELSE
          v_tmp_text := NULLIF(btrim(v_row.payload->>'job_profile_id'), '');
          IF v_tmp_text IS NULL THEN
            v_job_profile_id := NULL;
          ELSE
            BEGIN
              v_job_profile_id := v_tmp_text::uuid;
            EXCEPTION
              WHEN invalid_text_representation THEN
                RAISE EXCEPTION USING
                  MESSAGE = 'STAFFING_INVALID_ARGUMENT',
                  DETAIL = format('job_profile_id=%s', v_row.payload->>'job_profile_id');
            END;
          END IF;
        END IF;
      END IF;
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev_effective IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;

      IF v_row.payload ? 'org_unit_id' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'org_unit_id'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'org_unit_id is required';
        END IF;
        BEGIN
          v_org_unit_id := v_tmp_text::int;
        EXCEPTION
          WHEN invalid_text_representation THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_INVALID_ARGUMENT',
              DETAIL = format('org_unit_id=%s', v_row.payload->>'org_unit_id');
        END;
      END IF;

      IF v_row.payload ? 'reports_to_position_id' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'reports_to_position_id'), '');
        IF v_tmp_text IS NULL THEN
          v_reports_to_position_id := NULL;
        ELSE
          BEGIN
            v_reports_to_position_id := v_tmp_text::uuid;
          EXCEPTION
            WHEN invalid_text_representation THEN
              RAISE EXCEPTION USING
                MESSAGE = 'STAFFING_INVALID_ARGUMENT',
                DETAIL = format('reports_to_position_id=%s', v_row.payload->>'reports_to_position_id');
          END;
        END IF;
      END IF;

      IF v_row.payload ? 'name' THEN
        v_name := NULLIF(btrim(v_row.payload->>'name'), '');
      END IF;

      IF v_row.payload ? 'lifecycle_status' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'lifecycle_status'), '');
        IF v_tmp_text IS NULL OR v_tmp_text NOT IN ('active','disabled') THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('lifecycle_status=%s', v_row.payload->>'lifecycle_status');
        END IF;
        v_lifecycle_status := v_tmp_text;
      END IF;

      IF v_row.payload ? 'capacity_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'capacity_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'capacity_fte is required';
        END IF;
        BEGIN
          v_capacity_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_INVALID_ARGUMENT',
              DETAIL = format('capacity_fte=%s', v_row.payload->>'capacity_fte');
        END;
        IF v_capacity_fte <= 0 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('capacity_fte=%s', v_row.payload->>'capacity_fte');
        END IF;
      END IF;

      IF v_row.payload ? 'job_profile_id' THEN
        IF v_row.payload->'job_profile_id' IS NULL THEN
          v_job_profile_id := NULL;
        ELSE
          v_tmp_text := NULLIF(btrim(v_row.payload->>'job_profile_id'), '');
          IF v_tmp_text IS NULL THEN
            v_job_profile_id := NULL;
          ELSE
            BEGIN
              v_job_profile_id := v_tmp_text::uuid;
            EXCEPTION
              WHEN invalid_text_representation THEN
                RAISE EXCEPTION USING
                  MESSAGE = 'STAFFING_INVALID_ARGUMENT',
                  DETAIL = format('job_profile_id=%s', v_row.payload->>'job_profile_id');
            END;
          END IF;
        END IF;
      END IF;
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_row.event_type);
    END IF;

    IF v_org_unit_id IS NOT NULL THEN
      IF NOT EXISTS (
        SELECT 1
        FROM orgunit.org_unit_versions ouv
        WHERE ouv.tenant_uuid = p_tenant_id
          AND ouv.hierarchy_type = 'OrgUnit'
          AND ouv.org_id = v_org_unit_id
          AND ouv.status = 'active'
          AND ouv.validity @> v_row.effective_date
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_ORG_UNIT_NOT_FOUND_AS_OF',
          DETAIL = format('org_unit_id=%s as_of=%s', v_org_unit_id, v_row.effective_date);
      END IF;
    END IF;

    IF v_job_profile_id IS NULL THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = 'job_profile_id is required';
    END IF;

    v_jobcatalog_setid := orgunit.resolve_setid(p_tenant_id, v_org_unit_id, v_row.effective_date);
    v_jobcatalog_setid_as_of := v_row.effective_date;
    SELECT package_id
    INTO v_jobcatalog_package_id
    FROM orgunit.resolve_scope_package(p_tenant_id, v_jobcatalog_setid, 'jobcatalog', v_row.effective_date);

    IF NOT EXISTS (
      SELECT 1
      FROM jobcatalog.job_profile_versions jpv
      WHERE jpv.tenant_id = p_tenant_id
        AND jpv.package_id = v_jobcatalog_package_id
        AND jpv.job_profile_id = v_job_profile_id
        AND jpv.is_active = true
        AND jpv.validity @> v_row.effective_date
      LIMIT 1
    ) THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'JOBCATALOG_REFERENCE_NOT_FOUND',
        DETAIL = format('job_profile_id=%s', v_job_profile_id);
    END IF;

    IF v_reports_to_position_id IS NOT NULL THEN
      IF v_reports_to_position_id = p_position_id THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_REPORTS_TO_SELF',
          DETAIL = format('position_id=%s', p_position_id);
      END IF;

      SELECT lifecycle_status INTO v_target_status
      FROM staffing.position_versions pv
      WHERE pv.tenant_id = p_tenant_id
        AND pv.position_id = v_reports_to_position_id
        AND pv.validity @> v_row.effective_date
      ORDER BY lower(pv.validity) DESC
      LIMIT 1;
      IF NOT FOUND THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_NOT_FOUND_AS_OF',
          DETAIL = format('position_id=%s as_of=%s', v_reports_to_position_id, v_row.effective_date);
      END IF;
      IF v_target_status <> 'active' THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_DISABLED_AS_OF',
          DETAIL = format('position_id=%s as_of=%s', v_reports_to_position_id, v_row.effective_date);
      END IF;

      IF EXISTS (
        WITH RECURSIVE chain AS (
          SELECT pv.position_id, pv.reports_to_position_id
          FROM staffing.position_versions pv
          WHERE pv.tenant_id = p_tenant_id
            AND pv.position_id = v_reports_to_position_id
            AND pv.validity @> v_row.effective_date
          UNION ALL
          SELECT pv.position_id, pv.reports_to_position_id
          FROM staffing.position_versions pv
          JOIN chain c ON pv.position_id = c.reports_to_position_id
          WHERE pv.tenant_id = p_tenant_id
            AND pv.validity @> v_row.effective_date
            AND c.reports_to_position_id IS NOT NULL
        )
        SELECT 1
        FROM chain
        WHERE position_id = p_position_id
           OR reports_to_position_id = p_position_id
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_REPORTS_TO_CYCLE',
          DETAIL = format('position_id=%s', p_position_id);
      END IF;
    END IF;

    IF v_row.next_effective IS NULL THEN
      v_validity := daterange(v_row.effective_date, NULL, '[)');
    ELSE
      v_validity := daterange(v_row.effective_date, v_row.next_effective, '[)');
    END IF;

    IF v_lifecycle_status = 'disabled' THEN
      IF EXISTS (
        SELECT 1
        FROM staffing.assignment_versions av
        WHERE av.tenant_id = p_tenant_id
          AND av.position_id = p_position_id
          AND av.status = 'active'
          AND av.validity && v_validity
        LIMIT 1
      ) THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_HAS_ACTIVE_ASSIGNMENT_AS_OF',
          DETAIL = format('position_id=%s as_of=%s', p_position_id, v_row.effective_date);
      END IF;
    END IF;

    INSERT INTO staffing.position_versions (
      tenant_id,
      position_id,
      org_unit_id,
      reports_to_position_id,
      name,
      lifecycle_status,
      capacity_fte,
      profile,
      validity,
      last_event_id,
      jobcatalog_setid,
      jobcatalog_setid_as_of,
      job_profile_id
    )
    VALUES (
      p_tenant_id,
      p_position_id,
      v_org_unit_id,
      v_reports_to_position_id,
      v_name,
      v_lifecycle_status,
      v_capacity_fte,
      v_profile,
      v_validity,
      v_row.event_db_id,
      v_jobcatalog_setid,
      v_jobcatalog_setid_as_of,
      v_job_profile_id
    );

    IF v_lifecycle_status = 'active' THEN
      PERFORM staffing.assert_position_capacity(p_tenant_id, p_position_id, v_validity);
    END IF;

    v_prev_effective := v_row.effective_date;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM staffing.position_versions
      WHERE tenant_id = p_tenant_id AND position_id = p_position_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_GAP',
      DETAIL = 'position_versions must be gapless';
  END IF;

  SELECT validity INTO v_last_validity
  FROM staffing.position_versions
  WHERE tenant_id = p_tenant_id AND position_id = p_position_id
  ORDER BY lower(validity) DESC
  LIMIT 1;
  IF v_last_validity IS NOT NULL AND upper(v_last_validity) IS NOT NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_NOT_INFINITE',
      DETAIL = 'position_versions must end at infinity';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.assert_position_capacity(
  p_tenant_id uuid,
  p_position_id uuid,
  p_validity daterange
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_position_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'position_id is required';
  END IF;
  IF p_validity IS NULL OR isempty(p_validity) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'validity is required';
  END IF;

  IF EXISTS (
    SELECT 1
    FROM staffing.assignment_versions av
    JOIN staffing.position_versions pv
      ON pv.tenant_id = av.tenant_id
     AND pv.position_id = av.position_id
     AND pv.validity && av.validity
    WHERE av.tenant_id = p_tenant_id
      AND av.position_id = p_position_id
      AND av.status = 'active'
      AND av.validity && p_validity
      AND av.allocated_fte > pv.capacity_fte
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_POSITION_CAPACITY_EXCEEDED',
      DETAIL = format('position_id=%s', p_position_id);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.replay_assignment_versions(
  p_tenant_id uuid,
  p_assignment_id uuid
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_prev_effective date;
  v_last_validity daterange;
  v_person_uuid uuid;
  v_assignment_type text;
  v_position_id uuid;
  v_status text;
  v_allocated_fte numeric(9,2);
  v_profile jsonb;
  v_tmp_text text;
  v_row RECORD;
  v_validity daterange;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_assignment_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'assignment_id is required';
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_id, p_assignment_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  DELETE FROM staffing.assignment_versions
  WHERE tenant_id = p_tenant_id AND assignment_id = p_assignment_id;

  v_person_uuid := NULL;
  v_assignment_type := NULL;
  v_position_id := NULL;
  v_status := 'active';
  v_allocated_fte := 1.0;
  v_profile := '{}'::jsonb;
  v_prev_effective := NULL;

  FOR v_row IN
    WITH base AS (
      SELECT
        e.id AS event_db_id,
        e.event_type,
        e.effective_date,
        e.person_uuid,
        e.assignment_type,
        COALESCE(c.replacement_payload, e.payload) AS payload,
        (r.id IS NOT NULL) AS is_rescinded
      FROM staffing.assignment_events e
      LEFT JOIN staffing.assignment_event_corrections c
        ON c.tenant_id = e.tenant_id
       AND c.assignment_id = e.assignment_id
       AND c.target_effective_date = e.effective_date
      LEFT JOIN staffing.assignment_event_rescinds r
        ON r.tenant_id = e.tenant_id
       AND r.assignment_id = e.assignment_id
       AND r.target_effective_date = e.effective_date
      WHERE e.tenant_id = p_tenant_id
        AND e.assignment_id = p_assignment_id
    ),
    filtered AS (
      SELECT *
      FROM base
      WHERE NOT is_rescinded
    ),
    ordered AS (
      SELECT
        event_db_id,
        event_type,
        effective_date,
        person_uuid,
        assignment_type,
        payload,
        lead(effective_date) OVER (ORDER BY effective_date ASC, event_db_id ASC) AS next_effective
      FROM filtered
    )
    SELECT *
    FROM ordered
    ORDER BY effective_date ASC, event_db_id ASC
  LOOP
    IF v_row.event_type = 'CREATE' THEN
      IF v_prev_effective IS NOT NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'CREATE must be the first event';
      END IF;

      v_person_uuid := v_row.person_uuid;
      v_assignment_type := v_row.assignment_type;

      v_position_id := NULLIF(v_row.payload->>'position_id', '')::uuid;
      IF v_position_id IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_ARGUMENT',
          DETAIL = 'position_id is required';
      END IF;
      v_status := 'active';

      IF v_row.payload ? 'allocated_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'allocated_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = 'allocated_fte is required';
        END IF;
        BEGIN
          v_allocated_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
              DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END;
        IF v_allocated_fte <= 0 OR v_allocated_fte > 1 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END IF;
      END IF;

      IF v_row.payload ? 'profile' THEN
        IF jsonb_typeof(v_row.payload->'profile') <> 'object' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_PROFILE_INVALID',
            DETAIL = 'profile must be an object';
        END IF;
        v_profile := v_row.payload->'profile';
      END IF;
    ELSIF v_row.event_type = 'UPDATE' THEN
      IF v_prev_effective IS NULL THEN
        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_INVALID_EVENT',
          DETAIL = 'UPDATE requires prior state';
      END IF;

      IF v_row.payload ? 'position_id' THEN
        v_position_id := NULLIF(v_row.payload->>'position_id', '')::uuid;
        IF v_position_id IS NULL THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = 'position_id is required';
	      END IF;
      END IF;

      IF v_row.payload ? 'status' THEN
        v_status := NULLIF(btrim(v_row.payload->>'status'), '');
        IF v_status IS NULL OR v_status NOT IN ('active','inactive') THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_INVALID_ARGUMENT',
            DETAIL = format('invalid status: %s', v_row.payload->>'status');
	        END IF;
      END IF;

      IF v_row.payload ? 'allocated_fte' THEN
        v_tmp_text := NULLIF(btrim(v_row.payload->>'allocated_fte'), '');
        IF v_tmp_text IS NULL THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = 'allocated_fte is required';
        END IF;
        BEGIN
          v_allocated_fte := v_tmp_text::numeric;
        EXCEPTION
          WHEN others THEN
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
              DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END;
        IF v_allocated_fte <= 0 OR v_allocated_fte > 1 THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_ALLOCATED_FTE_INVALID',
            DETAIL = format('allocated_fte=%s', v_row.payload->>'allocated_fte');
        END IF;
      END IF;

      IF v_row.payload ? 'profile' THEN
        IF jsonb_typeof(v_row.payload->'profile') <> 'object' THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_ASSIGNMENT_PROFILE_INVALID',
            DETAIL = 'profile must be an object';
        END IF;
        v_profile := v_row.payload->'profile';
      END IF;
    ELSE
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'STAFFING_INVALID_ARGUMENT',
        DETAIL = format('unexpected event_type: %s', v_row.event_type);
    END IF;

    IF v_row.next_effective IS NULL THEN
      v_validity := daterange(v_row.effective_date, NULL, '[)');
    ELSE
      v_validity := daterange(v_row.effective_date, v_row.next_effective, '[)');
    END IF;

    IF v_status = 'active' THEN
      IF NOT EXISTS (
        SELECT 1
        FROM staffing.position_versions pv
        WHERE pv.tenant_id = p_tenant_id
          AND pv.position_id = v_position_id
          AND pv.lifecycle_status = 'active'
          AND pv.validity @> v_row.effective_date
        LIMIT 1
      ) THEN
        IF EXISTS (
          SELECT 1
          FROM staffing.position_versions pv
          WHERE pv.tenant_id = p_tenant_id
            AND pv.position_id = v_position_id
            AND pv.validity @> v_row.effective_date
          LIMIT 1
        ) THEN
          RAISE EXCEPTION USING
            ERRCODE = 'P0001',
            MESSAGE = 'STAFFING_POSITION_DISABLED_AS_OF',
            DETAIL = format('position_id=%s as_of=%s', v_position_id, v_row.effective_date);
        END IF;

        RAISE EXCEPTION USING
          ERRCODE = 'P0001',
          MESSAGE = 'STAFFING_POSITION_NOT_FOUND_AS_OF',
          DETAIL = format('position_id=%s as_of=%s', v_position_id, v_row.effective_date);
      END IF;
    END IF;

    INSERT INTO staffing.assignment_versions (
      tenant_id,
      assignment_id,
      person_uuid,
      position_id,
      assignment_type,
      status,
      allocated_fte,
      profile,
      validity,
      last_event_id
    )
    VALUES (
      p_tenant_id,
      p_assignment_id,
      v_person_uuid,
      v_position_id,
      v_assignment_type,
      v_status,
      v_allocated_fte,
      v_profile,
      v_validity,
      v_row.event_db_id
    );

    IF v_status = 'active' THEN
      PERFORM staffing.assert_position_capacity(p_tenant_id, v_position_id, v_validity);
    END IF;

    v_prev_effective := v_row.effective_date;
  END LOOP;

  IF EXISTS (
    WITH ordered AS (
      SELECT
        validity,
        lag(validity) OVER (ORDER BY lower(validity)) AS prev_validity
      FROM staffing.assignment_versions
      WHERE tenant_id = p_tenant_id AND assignment_id = p_assignment_id
    )
    SELECT 1
    FROM ordered
    WHERE prev_validity IS NOT NULL
      AND lower(validity) <> upper(prev_validity)
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_GAP',
      DETAIL = 'assignment_versions must be gapless';
  END IF;

  SELECT validity INTO v_last_validity
  FROM staffing.assignment_versions
  WHERE tenant_id = p_tenant_id AND assignment_id = p_assignment_id
  ORDER BY lower(validity) DESC
  LIMIT 1;

  IF v_last_validity IS NOT NULL AND NOT upper_inf(v_last_validity) THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_VALIDITY_NOT_INFINITE',
      DETAIL = 'last assignment version validity must be unbounded (infinity)';
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_assignment_event(
  p_event_id uuid,
  p_tenant_id uuid,
  p_assignment_id uuid,
  p_person_uuid uuid,
  p_assignment_type text,
  p_event_type text,
  p_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_event_db_id bigint;
  v_existing staffing.assignment_events%ROWTYPE;
  v_payload jsonb;
  v_existing_assignment_id uuid;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_assignment_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_id is required';
  END IF;
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'person_uuid is required';
  END IF;
  IF p_assignment_type IS NULL OR btrim(p_assignment_type) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_type is required';
  END IF;
  IF p_assignment_type <> 'primary' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = format('unsupported assignment_type: %s', p_assignment_type);
  END IF;
  IF p_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;
  IF p_event_type NOT IN ('CREATE','UPDATE') THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = format('unsupported event_type: %s', p_event_type);
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_id, p_assignment_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  INSERT INTO staffing.assignments (tenant_id, id, person_uuid, assignment_type)
  VALUES (p_tenant_id, p_assignment_id, p_person_uuid, p_assignment_type)
  ON CONFLICT (tenant_id, person_uuid, assignment_type) DO NOTHING;

  SELECT id INTO v_existing_assignment_id
  FROM staffing.assignments
  WHERE tenant_id = p_tenant_id AND person_uuid = p_person_uuid AND assignment_type = p_assignment_type;

  IF v_existing_assignment_id IS NULL THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'assignment identity missing';
  END IF;
  IF v_existing_assignment_id <> p_assignment_id THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_ID_MISMATCH',
      DETAIL = format('assignment_id=%s existing_id=%s', p_assignment_id, v_existing_assignment_id);
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);

  INSERT INTO staffing.assignment_events (
    event_id,
    tenant_id,
    assignment_id,
    person_uuid,
    assignment_type,
    event_type,
    effective_date,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_assignment_id,
    p_person_uuid,
    p_assignment_type,
    p_event_type,
    p_effective_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT (event_id) DO NOTHING
  RETURNING id INTO v_event_db_id;

  IF v_event_db_id IS NULL THEN
    SELECT * INTO v_existing
    FROM staffing.assignment_events
    WHERE event_id = p_event_id;

    IF v_existing.tenant_id <> p_tenant_id
      OR v_existing.assignment_id <> p_assignment_id
      OR v_existing.person_uuid <> p_person_uuid
      OR v_existing.assignment_type <> p_assignment_type
      OR v_existing.event_type <> p_event_type
      OR v_existing.effective_date <> p_effective_date
      OR v_existing.payload <> v_payload
      OR v_existing.request_id <> p_request_id
      OR v_existing.initiator_id <> p_initiator_id
    THEN
      RAISE EXCEPTION USING
        MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
        DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing.id);
    END IF;

    RETURN v_existing.id;
  END IF;

  PERFORM staffing.replay_assignment_versions(p_tenant_id, p_assignment_id);

  RETURN v_event_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_assignment_event_correction(
  p_event_id uuid,
  p_tenant_id uuid,
  p_assignment_id uuid,
  p_target_effective_date date,
  p_replacement_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_target staffing.assignment_events%ROWTYPE;
  v_existing_by_event staffing.assignment_event_corrections%ROWTYPE;
  v_existing_by_request staffing.assignment_event_corrections%ROWTYPE;
  v_existing_by_target staffing.assignment_event_corrections%ROWTYPE;
  v_payload jsonb;
  v_correction_db_id bigint;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_assignment_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_id is required';
  END IF;
  IF p_target_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'target_effective_date is required';
  END IF;
  IF p_replacement_payload IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'replacement_payload is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_payload := p_replacement_payload;
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'replacement_payload must be an object';
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_id, p_assignment_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_target
  FROM staffing.assignment_events
  WHERE tenant_id = p_tenant_id
    AND assignment_id = p_assignment_id
    AND effective_date = p_target_effective_date
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_EVENT_NOT_FOUND',
      DETAIL = format('assignment_id=%s target_effective_date=%s', p_assignment_id, p_target_effective_date);
  END IF;

  IF EXISTS (
    SELECT 1
    FROM staffing.assignment_event_rescinds r
    WHERE r.tenant_id = p_tenant_id
      AND r.assignment_id = p_assignment_id
      AND r.target_effective_date = p_target_effective_date
    LIMIT 1
  ) THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_EVENT_ALREADY_RESCINDED',
      DETAIL = format('assignment_id=%s target_effective_date=%s', p_assignment_id, p_target_effective_date);
  END IF;

  INSERT INTO staffing.assignment_event_corrections (
    event_id,
    tenant_id,
    assignment_id,
    target_effective_date,
    replacement_payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_assignment_id,
    p_target_effective_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT DO NOTHING
  RETURNING id INTO v_correction_db_id;

  IF v_correction_db_id IS NULL THEN
    SELECT * INTO v_existing_by_event
    FROM staffing.assignment_event_corrections
    WHERE event_id = p_event_id;

    IF FOUND THEN
      IF v_existing_by_event.tenant_id <> p_tenant_id
        OR v_existing_by_event.assignment_id <> p_assignment_id
        OR v_existing_by_event.target_effective_date <> p_target_effective_date
        OR v_existing_by_event.replacement_payload <> v_payload
        OR v_existing_by_event.request_id <> p_request_id
        OR v_existing_by_event.initiator_id <> p_initiator_id
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
          DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing_by_event.id);
      END IF;
      v_correction_db_id := v_existing_by_event.id;
    ELSE
      SELECT * INTO v_existing_by_request
      FROM staffing.assignment_event_corrections
      WHERE tenant_id = p_tenant_id
        AND request_id = p_request_id
      LIMIT 1;

      IF FOUND THEN
        IF v_existing_by_request.tenant_id <> p_tenant_id
          OR v_existing_by_request.assignment_id <> p_assignment_id
          OR v_existing_by_request.target_effective_date <> p_target_effective_date
          OR v_existing_by_request.replacement_payload <> v_payload
          OR v_existing_by_request.request_id <> p_request_id
          OR v_existing_by_request.initiator_id <> p_initiator_id
        THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
            DETAIL = format('request_id=%s existing_id=%s', p_request_id, v_existing_by_request.id);
        END IF;
        v_correction_db_id := v_existing_by_request.id;
      ELSE
        SELECT * INTO v_existing_by_target
        FROM staffing.assignment_event_corrections
        WHERE tenant_id = p_tenant_id
          AND assignment_id = p_assignment_id
          AND target_effective_date = p_target_effective_date
        LIMIT 1;

        IF FOUND THEN
          IF v_existing_by_target.replacement_payload = v_payload THEN
            v_correction_db_id := v_existing_by_target.id;
          ELSE
            RAISE EXCEPTION USING
              MESSAGE = 'STAFFING_ASSIGNMENT_EVENT_ALREADY_CORRECTED',
              DETAIL = format('assignment_id=%s target_effective_date=%s existing_id=%s', p_assignment_id, p_target_effective_date, v_existing_by_target.id);
          END IF;
        ELSE
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'correction insert failed';
        END IF;
      END IF;
    END IF;
  END IF;

  PERFORM staffing.replay_assignment_versions(p_tenant_id, p_assignment_id);

  RETURN v_correction_db_id;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.submit_assignment_event_rescind(
  p_event_id uuid,
  p_tenant_id uuid,
  p_assignment_id uuid,
  p_target_effective_date date,
  p_payload jsonb,
  p_request_id text,
  p_initiator_id uuid
)
RETURNS bigint
LANGUAGE plpgsql
AS $$
DECLARE
  v_lock_key text;
  v_target staffing.assignment_events%ROWTYPE;
  v_existing_by_event staffing.assignment_event_rescinds%ROWTYPE;
  v_existing_by_request staffing.assignment_event_rescinds%ROWTYPE;
  v_existing_by_target staffing.assignment_event_rescinds%ROWTYPE;
  v_payload jsonb;
  v_rescind_db_id bigint;
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);

  IF p_event_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'event_id is required';
  END IF;
  IF p_assignment_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'assignment_id is required';
  END IF;
  IF p_target_effective_date IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'target_effective_date is required';
  END IF;
  IF p_request_id IS NULL OR btrim(p_request_id) = '' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'request_id is required';
  END IF;
  IF p_initiator_id IS NULL THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'initiator_id is required';
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb);
  IF jsonb_typeof(v_payload) <> 'object' THEN
    RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'payload must be an object';
  END IF;

  v_lock_key := format('staffing:assignment:%s:%s', p_tenant_id, p_assignment_id);
  PERFORM pg_advisory_xact_lock(hashtextextended(v_lock_key, 0));

  SELECT * INTO v_target
  FROM staffing.assignment_events
  WHERE tenant_id = p_tenant_id
    AND assignment_id = p_assignment_id
    AND effective_date = p_target_effective_date
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_EVENT_NOT_FOUND',
      DETAIL = format('assignment_id=%s target_effective_date=%s', p_assignment_id, p_target_effective_date);
  END IF;

  IF v_target.event_type = 'CREATE' THEN
    RAISE EXCEPTION USING
      MESSAGE = 'STAFFING_ASSIGNMENT_CREATE_CANNOT_RESCIND',
      DETAIL = format('assignment_id=%s target_effective_date=%s', p_assignment_id, p_target_effective_date);
  END IF;

  INSERT INTO staffing.assignment_event_rescinds (
    event_id,
    tenant_id,
    assignment_id,
    target_effective_date,
    payload,
    request_id,
    initiator_id
  )
  VALUES (
    p_event_id,
    p_tenant_id,
    p_assignment_id,
    p_target_effective_date,
    v_payload,
    p_request_id,
    p_initiator_id
  )
  ON CONFLICT DO NOTHING
  RETURNING id INTO v_rescind_db_id;

  IF v_rescind_db_id IS NULL THEN
    SELECT * INTO v_existing_by_event
    FROM staffing.assignment_event_rescinds
    WHERE event_id = p_event_id;

    IF FOUND THEN
      IF v_existing_by_event.tenant_id <> p_tenant_id
        OR v_existing_by_event.assignment_id <> p_assignment_id
        OR v_existing_by_event.target_effective_date <> p_target_effective_date
        OR v_existing_by_event.payload <> v_payload
        OR v_existing_by_event.request_id <> p_request_id
        OR v_existing_by_event.initiator_id <> p_initiator_id
      THEN
        RAISE EXCEPTION USING
          MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
          DETAIL = format('event_id=%s existing_id=%s', p_event_id, v_existing_by_event.id);
      END IF;
      v_rescind_db_id := v_existing_by_event.id;
    ELSE
      SELECT * INTO v_existing_by_request
      FROM staffing.assignment_event_rescinds
      WHERE tenant_id = p_tenant_id
        AND request_id = p_request_id
      LIMIT 1;

      IF FOUND THEN
        IF v_existing_by_request.tenant_id <> p_tenant_id
          OR v_existing_by_request.assignment_id <> p_assignment_id
          OR v_existing_by_request.target_effective_date <> p_target_effective_date
          OR v_existing_by_request.payload <> v_payload
          OR v_existing_by_request.request_id <> p_request_id
          OR v_existing_by_request.initiator_id <> p_initiator_id
        THEN
          RAISE EXCEPTION USING
            MESSAGE = 'STAFFING_IDEMPOTENCY_REUSED',
            DETAIL = format('request_id=%s existing_id=%s', p_request_id, v_existing_by_request.id);
        END IF;
        v_rescind_db_id := v_existing_by_request.id;
      ELSE
        SELECT * INTO v_existing_by_target
        FROM staffing.assignment_event_rescinds
        WHERE tenant_id = p_tenant_id
          AND assignment_id = p_assignment_id
          AND target_effective_date = p_target_effective_date
        LIMIT 1;

        IF FOUND THEN
          v_rescind_db_id := v_existing_by_target.id;
        ELSE
          RAISE EXCEPTION USING MESSAGE = 'STAFFING_INVALID_ARGUMENT', DETAIL = 'rescind insert failed';
        END IF;
      END IF;
    END IF;
  END IF;

  PERFORM staffing.replay_assignment_versions(p_tenant_id, p_assignment_id);

  RETURN v_rescind_db_id;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00003_staffing_engine.sql

-- begin: modules/staffing/infrastructure/persistence/schema/00015_staffing_read.sql
CREATE OR REPLACE FUNCTION staffing.get_position_snapshot(
  p_tenant_id uuid,
  p_query_date date
)
RETURNS TABLE (
  position_id uuid,
  org_unit_id int,
  reports_to_position_id uuid,
  jobcatalog_setid text,
  jobcatalog_setid_as_of date,
  job_profile_id uuid,
  job_profile_code text,
  name text,
  lifecycle_status text,
  capacity_fte numeric(9,2),
  effective_date date
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

	  RETURN QUERY
	  SELECT
    pv.position_id,
    pv.org_unit_id,
    pv.reports_to_position_id,
    pv.jobcatalog_setid,
    pv.jobcatalog_setid_as_of,
    pv.job_profile_id,
	    jp.code::text AS job_profile_code,
	    pv.name,
	    pv.lifecycle_status,
	    pv.capacity_fte,
	    lower(pv.validity) AS effective_date
  FROM staffing.position_versions pv
  LEFT JOIN LATERAL orgunit.resolve_scope_package(
    p_tenant_id,
    pv.jobcatalog_setid,
    'jobcatalog',
    pv.jobcatalog_setid_as_of
  ) sp(package_id, package_owner_tenant_uuid)
    ON pv.jobcatalog_setid IS NOT NULL
  LEFT JOIN jobcatalog.job_profiles jp
    ON jp.tenant_id = pv.tenant_id
   AND jp.package_id = sp.package_id
   AND jp.id = pv.job_profile_id
  WHERE pv.tenant_id = p_tenant_id
    AND pv.validity @> p_query_date;
END;
$$;

CREATE OR REPLACE FUNCTION staffing.get_assignment_snapshot(
  p_tenant_id uuid,
  p_person_uuid uuid,
  p_query_date date
)
RETURNS TABLE (
  assignment_id uuid,
  person_uuid uuid,
  position_id uuid,
  status text,
  effective_date date
)
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM staffing.assert_current_tenant(p_tenant_id);
  IF p_person_uuid IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'person_uuid is required';
  END IF;
  IF p_query_date IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'STAFFING_INVALID_ARGUMENT',
      DETAIL = 'query_date is required';
  END IF;

  RETURN QUERY
  SELECT
    av.assignment_id,
    av.person_uuid,
    av.position_id,
    av.status,
    lower(av.validity) AS effective_date
  FROM staffing.assignment_versions av
  WHERE av.tenant_id = p_tenant_id
    AND av.person_uuid = p_person_uuid
    AND av.validity @> p_query_date;
END;
$$;

-- end: modules/staffing/infrastructure/persistence/schema/00015_staffing_read.sql

-- begin: modules/person/infrastructure/persistence/schema/00001_person_schema.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE SCHEMA IF NOT EXISTS person;


-- end: modules/person/infrastructure/persistence/schema/00001_person_schema.sql

-- begin: modules/person/infrastructure/persistence/schema/00002_person_persons.sql
CREATE TABLE IF NOT EXISTS person.persons (
  tenant_id uuid NOT NULL,
  person_uuid uuid NOT NULL DEFAULT gen_random_uuid(),
  pernr text NOT NULL,
  display_name text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tenant_id, person_uuid),
  CONSTRAINT persons_pernr_trim_check CHECK (btrim(pernr) = pernr),
  CONSTRAINT persons_pernr_digits_max8_check CHECK (pernr ~ '^[0-9]{1,8}$'),
  CONSTRAINT persons_pernr_canonical_check CHECK (pernr = '0' OR pernr !~ '^0'),
  CONSTRAINT persons_display_name_trim_check CHECK (btrim(display_name) = display_name),
  CONSTRAINT persons_display_name_nonempty_check CHECK (display_name <> ''),
  CONSTRAINT persons_status_check CHECK (status IN ('active','inactive')),
  CONSTRAINT persons_tenant_pernr_unique UNIQUE (tenant_id, pernr)
);

CREATE INDEX IF NOT EXISTS persons_tenant_display_name_idx
  ON person.persons (tenant_id, display_name);

ALTER TABLE person.persons ENABLE ROW LEVEL SECURITY;
ALTER TABLE person.persons FORCE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS tenant_isolation ON person.persons;
CREATE POLICY tenant_isolation ON person.persons
USING (tenant_id = current_setting('app.current_tenant')::uuid)
WITH CHECK (tenant_id = current_setting('app.current_tenant')::uuid);

-- end: modules/person/infrastructure/persistence/schema/00002_person_persons.sql

-- begin: modules/person/infrastructure/persistence/schema/00003_person_engine.sql
CREATE OR REPLACE FUNCTION person.assert_current_tenant(p_tenant_id uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_ctx_raw text;
  v_ctx_tenant uuid;
BEGIN
  IF p_tenant_id IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_INVALID_ARGUMENT',
      DETAIL = 'tenant_id is required';
  END IF;

  v_ctx_raw := current_setting('app.current_tenant', true);
  IF v_ctx_raw IS NULL OR btrim(v_ctx_raw) = '' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_CONTEXT_MISSING',
      DETAIL = 'app.current_tenant is required';
  END IF;

  BEGIN
    v_ctx_tenant := v_ctx_raw::uuid;
  EXCEPTION
    WHEN invalid_text_representation THEN
      RAISE EXCEPTION USING
        ERRCODE = 'P0001',
        MESSAGE = 'RLS_TENANT_CONTEXT_INVALID',
        DETAIL = format('app.current_tenant=%s', v_ctx_raw);
  END;

  IF v_ctx_tenant <> p_tenant_id THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'RLS_TENANT_MISMATCH',
      DETAIL = format('tenant_param=%s tenant_ctx=%s', p_tenant_id, v_ctx_tenant);
  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION person.normalize_pernr(p_pernr text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  v text;
BEGIN
  IF p_pernr IS NULL THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_PERNR_INVALID',
      DETAIL = 'pernr is required';
  END IF;

  v := btrim(p_pernr);
  IF v = '' OR v !~ '^[0-9]{1,8}$' THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'PERSON_PERNR_INVALID',
      DETAIL = format('pernr=%s', v);
  END IF;

  v := regexp_replace(v, '^0+', '');
  IF v = '' THEN
    v := '0';
  END IF;
  RETURN v;
END;
$$;


-- end: modules/person/infrastructure/persistence/schema/00003_person_engine.sql

